import require$$0$1 from 'node:url';
import require$$1$1 from 'node:path/win32';
import require$$2 from 'node:path';
import require$$1 from 'node:os';
import require$$0 from 'url';
import { y as requireSemver } from './taze.CWW-GbSg.mjs';
import { a as requireLib$1, r as requireLib$2 } from './taze.DCXPW1kL.mjs';

var npa = {exports: {}};

var commonjs = {};

var hasRequiredCommonjs;

function requireCommonjs () {
	if (hasRequiredCommonjs) return commonjs;
	hasRequiredCommonjs = 1;
	/**
	 * @module LRUCache
	 */
	Object.defineProperty(commonjs, "__esModule", { value: true });
	commonjs.LRUCache = void 0;
	const perf = typeof performance === 'object' &&
	    performance &&
	    typeof performance.now === 'function'
	    ? performance
	    : Date;
	const warned = new Set();
	/* c8 ignore start */
	const PROCESS = (typeof process === 'object' && !!process ? process : {});
	/* c8 ignore start */
	const emitWarning = (msg, type, code, fn) => {
	    typeof PROCESS.emitWarning === 'function'
	        ? PROCESS.emitWarning(msg, type, code, fn)
	        : console.error(`[${code}] ${type}: ${msg}`);
	};
	let AC = globalThis.AbortController;
	let AS = globalThis.AbortSignal;
	/* c8 ignore start */
	if (typeof AC === 'undefined') {
	    //@ts-ignore
	    AS = class AbortSignal {
	        onabort;
	        _onabort = [];
	        reason;
	        aborted = false;
	        addEventListener(_, fn) {
	            this._onabort.push(fn);
	        }
	    };
	    //@ts-ignore
	    AC = class AbortController {
	        constructor() {
	            warnACPolyfill();
	        }
	        signal = new AS();
	        abort(reason) {
	            if (this.signal.aborted)
	                return;
	            //@ts-ignore
	            this.signal.reason = reason;
	            //@ts-ignore
	            this.signal.aborted = true;
	            //@ts-ignore
	            for (const fn of this.signal._onabort) {
	                fn(reason);
	            }
	            this.signal.onabort?.(reason);
	        }
	    };
	    let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1';
	    const warnACPolyfill = () => {
	        if (!printACPolyfillWarning)
	            return;
	        printACPolyfillWarning = false;
	        emitWarning('AbortController is not defined. If using lru-cache in ' +
	            'node 14, load an AbortController polyfill from the ' +
	            '`node-abort-controller` package. A minimal polyfill is ' +
	            'provided for use by LRUCache.fetch(), but it should not be ' +
	            'relied upon in other contexts (eg, passing it to other APIs that ' +
	            'use AbortController/AbortSignal might have undesirable effects). ' +
	            'You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.', 'NO_ABORT_CONTROLLER', 'ENOTSUP', warnACPolyfill);
	    };
	}
	/* c8 ignore stop */
	const shouldWarn = (code) => !warned.has(code);
	const isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
	/* c8 ignore start */
	// This is a little bit ridiculous, tbh.
	// The maximum array length is 2^32-1 or thereabouts on most JS impls.
	// And well before that point, you're caching the entire world, I mean,
	// that's ~32GB of just integers for the next/prev links, plus whatever
	// else to hold that many keys and values.  Just filling the memory with
	// zeroes at init time is brutal when you get that big.
	// But why not be complete?
	// Maybe in the future, these limits will have expanded.
	const getUintArray = (max) => !isPosInt(max)
	    ? null
	    : max <= Math.pow(2, 8)
	        ? Uint8Array
	        : max <= Math.pow(2, 16)
	            ? Uint16Array
	            : max <= Math.pow(2, 32)
	                ? Uint32Array
	                : max <= Number.MAX_SAFE_INTEGER
	                    ? ZeroArray
	                    : null;
	/* c8 ignore stop */
	class ZeroArray extends Array {
	    constructor(size) {
	        super(size);
	        this.fill(0);
	    }
	}
	class Stack {
	    heap;
	    length;
	    // private constructor
	    static #constructing = false;
	    static create(max) {
	        const HeapCls = getUintArray(max);
	        if (!HeapCls)
	            return [];
	        Stack.#constructing = true;
	        const s = new Stack(max, HeapCls);
	        Stack.#constructing = false;
	        return s;
	    }
	    constructor(max, HeapCls) {
	        /* c8 ignore start */
	        if (!Stack.#constructing) {
	            throw new TypeError('instantiate Stack using Stack.create(n)');
	        }
	        /* c8 ignore stop */
	        this.heap = new HeapCls(max);
	        this.length = 0;
	    }
	    push(n) {
	        this.heap[this.length++] = n;
	    }
	    pop() {
	        return this.heap[--this.length];
	    }
	}
	/**
	 * Default export, the thing you're using this module to get.
	 *
	 * The `K` and `V` types define the key and value types, respectively. The
	 * optional `FC` type defines the type of the `context` object passed to
	 * `cache.fetch()` and `cache.memo()`.
	 *
	 * Keys and values **must not** be `null` or `undefined`.
	 *
	 * All properties from the options object (with the exception of `max`,
	 * `maxSize`, `fetchMethod`, `memoMethod`, `dispose` and `disposeAfter`) are
	 * added as normal public members. (The listed options are read-only getters.)
	 *
	 * Changing any of these will alter the defaults for subsequent method calls.
	 */
	class LRUCache {
	    // options that cannot be changed without disaster
	    #max;
	    #maxSize;
	    #dispose;
	    #onInsert;
	    #disposeAfter;
	    #fetchMethod;
	    #memoMethod;
	    /**
	     * {@link LRUCache.OptionsBase.ttl}
	     */
	    ttl;
	    /**
	     * {@link LRUCache.OptionsBase.ttlResolution}
	     */
	    ttlResolution;
	    /**
	     * {@link LRUCache.OptionsBase.ttlAutopurge}
	     */
	    ttlAutopurge;
	    /**
	     * {@link LRUCache.OptionsBase.updateAgeOnGet}
	     */
	    updateAgeOnGet;
	    /**
	     * {@link LRUCache.OptionsBase.updateAgeOnHas}
	     */
	    updateAgeOnHas;
	    /**
	     * {@link LRUCache.OptionsBase.allowStale}
	     */
	    allowStale;
	    /**
	     * {@link LRUCache.OptionsBase.noDisposeOnSet}
	     */
	    noDisposeOnSet;
	    /**
	     * {@link LRUCache.OptionsBase.noUpdateTTL}
	     */
	    noUpdateTTL;
	    /**
	     * {@link LRUCache.OptionsBase.maxEntrySize}
	     */
	    maxEntrySize;
	    /**
	     * {@link LRUCache.OptionsBase.sizeCalculation}
	     */
	    sizeCalculation;
	    /**
	     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
	     */
	    noDeleteOnFetchRejection;
	    /**
	     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
	     */
	    noDeleteOnStaleGet;
	    /**
	     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
	     */
	    allowStaleOnFetchAbort;
	    /**
	     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
	     */
	    allowStaleOnFetchRejection;
	    /**
	     * {@link LRUCache.OptionsBase.ignoreFetchAbort}
	     */
	    ignoreFetchAbort;
	    // computed properties
	    #size;
	    #calculatedSize;
	    #keyMap;
	    #keyList;
	    #valList;
	    #next;
	    #prev;
	    #head;
	    #tail;
	    #free;
	    #disposed;
	    #sizes;
	    #starts;
	    #ttls;
	    #hasDispose;
	    #hasFetchMethod;
	    #hasDisposeAfter;
	    #hasOnInsert;
	    /**
	     * Do not call this method unless you need to inspect the
	     * inner workings of the cache.  If anything returned by this
	     * object is modified in any way, strange breakage may occur.
	     *
	     * These fields are private for a reason!
	     *
	     * @internal
	     */
	    static unsafeExposeInternals(c) {
	        return {
	            // properties
	            starts: c.#starts,
	            ttls: c.#ttls,
	            sizes: c.#sizes,
	            keyMap: c.#keyMap,
	            keyList: c.#keyList,
	            valList: c.#valList,
	            next: c.#next,
	            prev: c.#prev,
	            get head() {
	                return c.#head;
	            },
	            get tail() {
	                return c.#tail;
	            },
	            free: c.#free,
	            // methods
	            isBackgroundFetch: (p) => c.#isBackgroundFetch(p),
	            backgroundFetch: (k, index, options, context) => c.#backgroundFetch(k, index, options, context),
	            moveToTail: (index) => c.#moveToTail(index),
	            indexes: (options) => c.#indexes(options),
	            rindexes: (options) => c.#rindexes(options),
	            isStale: (index) => c.#isStale(index),
	        };
	    }
	    // Protected read-only members
	    /**
	     * {@link LRUCache.OptionsBase.max} (read-only)
	     */
	    get max() {
	        return this.#max;
	    }
	    /**
	     * {@link LRUCache.OptionsBase.maxSize} (read-only)
	     */
	    get maxSize() {
	        return this.#maxSize;
	    }
	    /**
	     * The total computed size of items in the cache (read-only)
	     */
	    get calculatedSize() {
	        return this.#calculatedSize;
	    }
	    /**
	     * The number of items stored in the cache (read-only)
	     */
	    get size() {
	        return this.#size;
	    }
	    /**
	     * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
	     */
	    get fetchMethod() {
	        return this.#fetchMethod;
	    }
	    get memoMethod() {
	        return this.#memoMethod;
	    }
	    /**
	     * {@link LRUCache.OptionsBase.dispose} (read-only)
	     */
	    get dispose() {
	        return this.#dispose;
	    }
	    /**
	     * {@link LRUCache.OptionsBase.onInsert} (read-only)
	     */
	    get onInsert() {
	        return this.#onInsert;
	    }
	    /**
	     * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
	     */
	    get disposeAfter() {
	        return this.#disposeAfter;
	    }
	    constructor(options) {
	        const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, onInsert, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort, } = options;
	        if (max !== 0 && !isPosInt(max)) {
	            throw new TypeError('max option must be a nonnegative integer');
	        }
	        const UintArray = max ? getUintArray(max) : Array;
	        if (!UintArray) {
	            throw new Error('invalid max value: ' + max);
	        }
	        this.#max = max;
	        this.#maxSize = maxSize;
	        this.maxEntrySize = maxEntrySize || this.#maxSize;
	        this.sizeCalculation = sizeCalculation;
	        if (this.sizeCalculation) {
	            if (!this.#maxSize && !this.maxEntrySize) {
	                throw new TypeError('cannot set sizeCalculation without setting maxSize or maxEntrySize');
	            }
	            if (typeof this.sizeCalculation !== 'function') {
	                throw new TypeError('sizeCalculation set to non-function');
	            }
	        }
	        if (memoMethod !== undefined &&
	            typeof memoMethod !== 'function') {
	            throw new TypeError('memoMethod must be a function if defined');
	        }
	        this.#memoMethod = memoMethod;
	        if (fetchMethod !== undefined &&
	            typeof fetchMethod !== 'function') {
	            throw new TypeError('fetchMethod must be a function if specified');
	        }
	        this.#fetchMethod = fetchMethod;
	        this.#hasFetchMethod = !!fetchMethod;
	        this.#keyMap = new Map();
	        this.#keyList = new Array(max).fill(undefined);
	        this.#valList = new Array(max).fill(undefined);
	        this.#next = new UintArray(max);
	        this.#prev = new UintArray(max);
	        this.#head = 0;
	        this.#tail = 0;
	        this.#free = Stack.create(max);
	        this.#size = 0;
	        this.#calculatedSize = 0;
	        if (typeof dispose === 'function') {
	            this.#dispose = dispose;
	        }
	        if (typeof onInsert === 'function') {
	            this.#onInsert = onInsert;
	        }
	        if (typeof disposeAfter === 'function') {
	            this.#disposeAfter = disposeAfter;
	            this.#disposed = [];
	        }
	        else {
	            this.#disposeAfter = undefined;
	            this.#disposed = undefined;
	        }
	        this.#hasDispose = !!this.#dispose;
	        this.#hasOnInsert = !!this.#onInsert;
	        this.#hasDisposeAfter = !!this.#disposeAfter;
	        this.noDisposeOnSet = !!noDisposeOnSet;
	        this.noUpdateTTL = !!noUpdateTTL;
	        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
	        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
	        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
	        this.ignoreFetchAbort = !!ignoreFetchAbort;
	        // NB: maxEntrySize is set to maxSize if it's set
	        if (this.maxEntrySize !== 0) {
	            if (this.#maxSize !== 0) {
	                if (!isPosInt(this.#maxSize)) {
	                    throw new TypeError('maxSize must be a positive integer if specified');
	                }
	            }
	            if (!isPosInt(this.maxEntrySize)) {
	                throw new TypeError('maxEntrySize must be a positive integer if specified');
	            }
	            this.#initializeSizeTracking();
	        }
	        this.allowStale = !!allowStale;
	        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
	        this.updateAgeOnGet = !!updateAgeOnGet;
	        this.updateAgeOnHas = !!updateAgeOnHas;
	        this.ttlResolution =
	            isPosInt(ttlResolution) || ttlResolution === 0
	                ? ttlResolution
	                : 1;
	        this.ttlAutopurge = !!ttlAutopurge;
	        this.ttl = ttl || 0;
	        if (this.ttl) {
	            if (!isPosInt(this.ttl)) {
	                throw new TypeError('ttl must be a positive integer if specified');
	            }
	            this.#initializeTTLTracking();
	        }
	        // do not allow completely unbounded caches
	        if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
	            throw new TypeError('At least one of max, maxSize, or ttl is required');
	        }
	        if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
	            const code = 'LRU_CACHE_UNBOUNDED';
	            if (shouldWarn(code)) {
	                warned.add(code);
	                const msg = 'TTL caching without ttlAutopurge, max, or maxSize can ' +
	                    'result in unbounded memory consumption.';
	                emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache);
	            }
	        }
	    }
	    /**
	     * Return the number of ms left in the item's TTL. If item is not in cache,
	     * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.
	     */
	    getRemainingTTL(key) {
	        return this.#keyMap.has(key) ? Infinity : 0;
	    }
	    #initializeTTLTracking() {
	        const ttls = new ZeroArray(this.#max);
	        const starts = new ZeroArray(this.#max);
	        this.#ttls = ttls;
	        this.#starts = starts;
	        this.#setItemTTL = (index, ttl, start = perf.now()) => {
	            starts[index] = ttl !== 0 ? start : 0;
	            ttls[index] = ttl;
	            if (ttl !== 0 && this.ttlAutopurge) {
	                const t = setTimeout(() => {
	                    if (this.#isStale(index)) {
	                        this.#delete(this.#keyList[index], 'expire');
	                    }
	                }, ttl + 1);
	                // unref() not supported on all platforms
	                /* c8 ignore start */
	                if (t.unref) {
	                    t.unref();
	                }
	                /* c8 ignore stop */
	            }
	        };
	        this.#updateItemAge = index => {
	            starts[index] = ttls[index] !== 0 ? perf.now() : 0;
	        };
	        this.#statusTTL = (status, index) => {
	            if (ttls[index]) {
	                const ttl = ttls[index];
	                const start = starts[index];
	                /* c8 ignore next */
	                if (!ttl || !start)
	                    return;
	                status.ttl = ttl;
	                status.start = start;
	                status.now = cachedNow || getNow();
	                const age = status.now - start;
	                status.remainingTTL = ttl - age;
	            }
	        };
	        // debounce calls to perf.now() to 1s so we're not hitting
	        // that costly call repeatedly.
	        let cachedNow = 0;
	        const getNow = () => {
	            const n = perf.now();
	            if (this.ttlResolution > 0) {
	                cachedNow = n;
	                const t = setTimeout(() => (cachedNow = 0), this.ttlResolution);
	                // not available on all platforms
	                /* c8 ignore start */
	                if (t.unref) {
	                    t.unref();
	                }
	                /* c8 ignore stop */
	            }
	            return n;
	        };
	        this.getRemainingTTL = key => {
	            const index = this.#keyMap.get(key);
	            if (index === undefined) {
	                return 0;
	            }
	            const ttl = ttls[index];
	            const start = starts[index];
	            if (!ttl || !start) {
	                return Infinity;
	            }
	            const age = (cachedNow || getNow()) - start;
	            return ttl - age;
	        };
	        this.#isStale = index => {
	            const s = starts[index];
	            const t = ttls[index];
	            return !!t && !!s && (cachedNow || getNow()) - s > t;
	        };
	    }
	    // conditionally set private methods related to TTL
	    #updateItemAge = () => { };
	    #statusTTL = () => { };
	    #setItemTTL = () => { };
	    /* c8 ignore stop */
	    #isStale = () => false;
	    #initializeSizeTracking() {
	        const sizes = new ZeroArray(this.#max);
	        this.#calculatedSize = 0;
	        this.#sizes = sizes;
	        this.#removeItemSize = index => {
	            this.#calculatedSize -= sizes[index];
	            sizes[index] = 0;
	        };
	        this.#requireSize = (k, v, size, sizeCalculation) => {
	            // provisionally accept background fetches.
	            // actual value size will be checked when they return.
	            if (this.#isBackgroundFetch(v)) {
	                return 0;
	            }
	            if (!isPosInt(size)) {
	                if (sizeCalculation) {
	                    if (typeof sizeCalculation !== 'function') {
	                        throw new TypeError('sizeCalculation must be a function');
	                    }
	                    size = sizeCalculation(v, k);
	                    if (!isPosInt(size)) {
	                        throw new TypeError('sizeCalculation return invalid (expect positive integer)');
	                    }
	                }
	                else {
	                    throw new TypeError('invalid size value (must be positive integer). ' +
	                        'When maxSize or maxEntrySize is used, sizeCalculation ' +
	                        'or size must be set.');
	                }
	            }
	            return size;
	        };
	        this.#addItemSize = (index, size, status) => {
	            sizes[index] = size;
	            if (this.#maxSize) {
	                const maxSize = this.#maxSize - sizes[index];
	                while (this.#calculatedSize > maxSize) {
	                    this.#evict(true);
	                }
	            }
	            this.#calculatedSize += sizes[index];
	            if (status) {
	                status.entrySize = size;
	                status.totalCalculatedSize = this.#calculatedSize;
	            }
	        };
	    }
	    #removeItemSize = _i => { };
	    #addItemSize = (_i, _s, _st) => { };
	    #requireSize = (_k, _v, size, sizeCalculation) => {
	        if (size || sizeCalculation) {
	            throw new TypeError('cannot set size without setting maxSize or maxEntrySize on cache');
	        }
	        return 0;
	    };
	    *#indexes({ allowStale = this.allowStale } = {}) {
	        if (this.#size) {
	            for (let i = this.#tail; true;) {
	                if (!this.#isValidIndex(i)) {
	                    break;
	                }
	                if (allowStale || !this.#isStale(i)) {
	                    yield i;
	                }
	                if (i === this.#head) {
	                    break;
	                }
	                else {
	                    i = this.#prev[i];
	                }
	            }
	        }
	    }
	    *#rindexes({ allowStale = this.allowStale } = {}) {
	        if (this.#size) {
	            for (let i = this.#head; true;) {
	                if (!this.#isValidIndex(i)) {
	                    break;
	                }
	                if (allowStale || !this.#isStale(i)) {
	                    yield i;
	                }
	                if (i === this.#tail) {
	                    break;
	                }
	                else {
	                    i = this.#next[i];
	                }
	            }
	        }
	    }
	    #isValidIndex(index) {
	        return (index !== undefined &&
	            this.#keyMap.get(this.#keyList[index]) === index);
	    }
	    /**
	     * Return a generator yielding `[key, value]` pairs,
	     * in order from most recently used to least recently used.
	     */
	    *entries() {
	        for (const i of this.#indexes()) {
	            if (this.#valList[i] !== undefined &&
	                this.#keyList[i] !== undefined &&
	                !this.#isBackgroundFetch(this.#valList[i])) {
	                yield [this.#keyList[i], this.#valList[i]];
	            }
	        }
	    }
	    /**
	     * Inverse order version of {@link LRUCache.entries}
	     *
	     * Return a generator yielding `[key, value]` pairs,
	     * in order from least recently used to most recently used.
	     */
	    *rentries() {
	        for (const i of this.#rindexes()) {
	            if (this.#valList[i] !== undefined &&
	                this.#keyList[i] !== undefined &&
	                !this.#isBackgroundFetch(this.#valList[i])) {
	                yield [this.#keyList[i], this.#valList[i]];
	            }
	        }
	    }
	    /**
	     * Return a generator yielding the keys in the cache,
	     * in order from most recently used to least recently used.
	     */
	    *keys() {
	        for (const i of this.#indexes()) {
	            const k = this.#keyList[i];
	            if (k !== undefined &&
	                !this.#isBackgroundFetch(this.#valList[i])) {
	                yield k;
	            }
	        }
	    }
	    /**
	     * Inverse order version of {@link LRUCache.keys}
	     *
	     * Return a generator yielding the keys in the cache,
	     * in order from least recently used to most recently used.
	     */
	    *rkeys() {
	        for (const i of this.#rindexes()) {
	            const k = this.#keyList[i];
	            if (k !== undefined &&
	                !this.#isBackgroundFetch(this.#valList[i])) {
	                yield k;
	            }
	        }
	    }
	    /**
	     * Return a generator yielding the values in the cache,
	     * in order from most recently used to least recently used.
	     */
	    *values() {
	        for (const i of this.#indexes()) {
	            const v = this.#valList[i];
	            if (v !== undefined &&
	                !this.#isBackgroundFetch(this.#valList[i])) {
	                yield this.#valList[i];
	            }
	        }
	    }
	    /**
	     * Inverse order version of {@link LRUCache.values}
	     *
	     * Return a generator yielding the values in the cache,
	     * in order from least recently used to most recently used.
	     */
	    *rvalues() {
	        for (const i of this.#rindexes()) {
	            const v = this.#valList[i];
	            if (v !== undefined &&
	                !this.#isBackgroundFetch(this.#valList[i])) {
	                yield this.#valList[i];
	            }
	        }
	    }
	    /**
	     * Iterating over the cache itself yields the same results as
	     * {@link LRUCache.entries}
	     */
	    [Symbol.iterator]() {
	        return this.entries();
	    }
	    /**
	     * A String value that is used in the creation of the default string
	     * description of an object. Called by the built-in method
	     * `Object.prototype.toString`.
	     */
	    [Symbol.toStringTag] = 'LRUCache';
	    /**
	     * Find a value for which the supplied fn method returns a truthy value,
	     * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.
	     */
	    find(fn, getOptions = {}) {
	        for (const i of this.#indexes()) {
	            const v = this.#valList[i];
	            const value = this.#isBackgroundFetch(v)
	                ? v.__staleWhileFetching
	                : v;
	            if (value === undefined)
	                continue;
	            if (fn(value, this.#keyList[i], this)) {
	                return this.get(this.#keyList[i], getOptions);
	            }
	        }
	    }
	    /**
	     * Call the supplied function on each item in the cache, in order from most
	     * recently used to least recently used.
	     *
	     * `fn` is called as `fn(value, key, cache)`.
	     *
	     * If `thisp` is provided, function will be called in the `this`-context of
	     * the provided object, or the cache if no `thisp` object is provided.
	     *
	     * Does not update age or recenty of use, or iterate over stale values.
	     */
	    forEach(fn, thisp = this) {
	        for (const i of this.#indexes()) {
	            const v = this.#valList[i];
	            const value = this.#isBackgroundFetch(v)
	                ? v.__staleWhileFetching
	                : v;
	            if (value === undefined)
	                continue;
	            fn.call(thisp, value, this.#keyList[i], this);
	        }
	    }
	    /**
	     * The same as {@link LRUCache.forEach} but items are iterated over in
	     * reverse order.  (ie, less recently used items are iterated over first.)
	     */
	    rforEach(fn, thisp = this) {
	        for (const i of this.#rindexes()) {
	            const v = this.#valList[i];
	            const value = this.#isBackgroundFetch(v)
	                ? v.__staleWhileFetching
	                : v;
	            if (value === undefined)
	                continue;
	            fn.call(thisp, value, this.#keyList[i], this);
	        }
	    }
	    /**
	     * Delete any stale entries. Returns true if anything was removed,
	     * false otherwise.
	     */
	    purgeStale() {
	        let deleted = false;
	        for (const i of this.#rindexes({ allowStale: true })) {
	            if (this.#isStale(i)) {
	                this.#delete(this.#keyList[i], 'expire');
	                deleted = true;
	            }
	        }
	        return deleted;
	    }
	    /**
	     * Get the extended info about a given entry, to get its value, size, and
	     * TTL info simultaneously. Returns `undefined` if the key is not present.
	     *
	     * Unlike {@link LRUCache#dump}, which is designed to be portable and survive
	     * serialization, the `start` value is always the current timestamp, and the
	     * `ttl` is a calculated remaining time to live (negative if expired).
	     *
	     * Always returns stale values, if their info is found in the cache, so be
	     * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})
	     * if relevant.
	     */
	    info(key) {
	        const i = this.#keyMap.get(key);
	        if (i === undefined)
	            return undefined;
	        const v = this.#valList[i];
	        const value = this.#isBackgroundFetch(v)
	            ? v.__staleWhileFetching
	            : v;
	        if (value === undefined)
	            return undefined;
	        const entry = { value };
	        if (this.#ttls && this.#starts) {
	            const ttl = this.#ttls[i];
	            const start = this.#starts[i];
	            if (ttl && start) {
	                const remain = ttl - (perf.now() - start);
	                entry.ttl = remain;
	                entry.start = Date.now();
	            }
	        }
	        if (this.#sizes) {
	            entry.size = this.#sizes[i];
	        }
	        return entry;
	    }
	    /**
	     * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
	     * passed to {@link LRUCache#load}.
	     *
	     * The `start` fields are calculated relative to a portable `Date.now()`
	     * timestamp, even if `performance.now()` is available.
	     *
	     * Stale entries are always included in the `dump`, even if
	     * {@link LRUCache.OptionsBase.allowStale} is false.
	     *
	     * Note: this returns an actual array, not a generator, so it can be more
	     * easily passed around.
	     */
	    dump() {
	        const arr = [];
	        for (const i of this.#indexes({ allowStale: true })) {
	            const key = this.#keyList[i];
	            const v = this.#valList[i];
	            const value = this.#isBackgroundFetch(v)
	                ? v.__staleWhileFetching
	                : v;
	            if (value === undefined || key === undefined)
	                continue;
	            const entry = { value };
	            if (this.#ttls && this.#starts) {
	                entry.ttl = this.#ttls[i];
	                // always dump the start relative to a portable timestamp
	                // it's ok for this to be a bit slow, it's a rare operation.
	                const age = perf.now() - this.#starts[i];
	                entry.start = Math.floor(Date.now() - age);
	            }
	            if (this.#sizes) {
	                entry.size = this.#sizes[i];
	            }
	            arr.unshift([key, entry]);
	        }
	        return arr;
	    }
	    /**
	     * Reset the cache and load in the items in entries in the order listed.
	     *
	     * The shape of the resulting cache may be different if the same options are
	     * not used in both caches.
	     *
	     * The `start` fields are assumed to be calculated relative to a portable
	     * `Date.now()` timestamp, even if `performance.now()` is available.
	     */
	    load(arr) {
	        this.clear();
	        for (const [key, entry] of arr) {
	            if (entry.start) {
	                // entry.start is a portable timestamp, but we may be using
	                // node's performance.now(), so calculate the offset, so that
	                // we get the intended remaining TTL, no matter how long it's
	                // been on ice.
	                //
	                // it's ok for this to be a bit slow, it's a rare operation.
	                const age = Date.now() - entry.start;
	                entry.start = perf.now() - age;
	            }
	            this.set(key, entry.value, entry);
	        }
	    }
	    /**
	     * Add a value to the cache.
	     *
	     * Note: if `undefined` is specified as a value, this is an alias for
	     * {@link LRUCache#delete}
	     *
	     * Fields on the {@link LRUCache.SetOptions} options param will override
	     * their corresponding values in the constructor options for the scope
	     * of this single `set()` operation.
	     *
	     * If `start` is provided, then that will set the effective start
	     * time for the TTL calculation. Note that this must be a previous
	     * value of `performance.now()` if supported, or a previous value of
	     * `Date.now()` if not.
	     *
	     * Options object may also include `size`, which will prevent
	     * calling the `sizeCalculation` function and just use the specified
	     * number if it is a positive integer, and `noDisposeOnSet` which
	     * will prevent calling a `dispose` function in the case of
	     * overwrites.
	     *
	     * If the `size` (or return value of `sizeCalculation`) for a given
	     * entry is greater than `maxEntrySize`, then the item will not be
	     * added to the cache.
	     *
	     * Will update the recency of the entry.
	     *
	     * If the value is `undefined`, then this is an alias for
	     * `cache.delete(key)`. `undefined` is never stored in the cache.
	     */
	    set(k, v, setOptions = {}) {
	        if (v === undefined) {
	            this.delete(k);
	            return this;
	        }
	        const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status, } = setOptions;
	        let { noUpdateTTL = this.noUpdateTTL } = setOptions;
	        const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);
	        // if the item doesn't fit, don't do anything
	        // NB: maxEntrySize set to maxSize by default
	        if (this.maxEntrySize && size > this.maxEntrySize) {
	            if (status) {
	                status.set = 'miss';
	                status.maxEntrySizeExceeded = true;
	            }
	            // have to delete, in case something is there already.
	            this.#delete(k, 'set');
	            return this;
	        }
	        let index = this.#size === 0 ? undefined : this.#keyMap.get(k);
	        if (index === undefined) {
	            // addition
	            index = (this.#size === 0
	                ? this.#tail
	                : this.#free.length !== 0
	                    ? this.#free.pop()
	                    : this.#size === this.#max
	                        ? this.#evict(false)
	                        : this.#size);
	            this.#keyList[index] = k;
	            this.#valList[index] = v;
	            this.#keyMap.set(k, index);
	            this.#next[this.#tail] = index;
	            this.#prev[index] = this.#tail;
	            this.#tail = index;
	            this.#size++;
	            this.#addItemSize(index, size, status);
	            if (status)
	                status.set = 'add';
	            noUpdateTTL = false;
	            if (this.#hasOnInsert) {
	                this.#onInsert?.(v, k, 'add');
	            }
	        }
	        else {
	            // update
	            this.#moveToTail(index);
	            const oldVal = this.#valList[index];
	            if (v !== oldVal) {
	                if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
	                    oldVal.__abortController.abort(new Error('replaced'));
	                    const { __staleWhileFetching: s } = oldVal;
	                    if (s !== undefined && !noDisposeOnSet) {
	                        if (this.#hasDispose) {
	                            this.#dispose?.(s, k, 'set');
	                        }
	                        if (this.#hasDisposeAfter) {
	                            this.#disposed?.push([s, k, 'set']);
	                        }
	                    }
	                }
	                else if (!noDisposeOnSet) {
	                    if (this.#hasDispose) {
	                        this.#dispose?.(oldVal, k, 'set');
	                    }
	                    if (this.#hasDisposeAfter) {
	                        this.#disposed?.push([oldVal, k, 'set']);
	                    }
	                }
	                this.#removeItemSize(index);
	                this.#addItemSize(index, size, status);
	                this.#valList[index] = v;
	                if (status) {
	                    status.set = 'replace';
	                    const oldValue = oldVal && this.#isBackgroundFetch(oldVal)
	                        ? oldVal.__staleWhileFetching
	                        : oldVal;
	                    if (oldValue !== undefined)
	                        status.oldValue = oldValue;
	                }
	            }
	            else if (status) {
	                status.set = 'update';
	            }
	            if (this.#hasOnInsert) {
	                this.onInsert?.(v, k, v === oldVal ? 'update' : 'replace');
	            }
	        }
	        if (ttl !== 0 && !this.#ttls) {
	            this.#initializeTTLTracking();
	        }
	        if (this.#ttls) {
	            if (!noUpdateTTL) {
	                this.#setItemTTL(index, ttl, start);
	            }
	            if (status)
	                this.#statusTTL(status, index);
	        }
	        if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
	            const dt = this.#disposed;
	            let task;
	            while ((task = dt?.shift())) {
	                this.#disposeAfter?.(...task);
	            }
	        }
	        return this;
	    }
	    /**
	     * Evict the least recently used item, returning its value or
	     * `undefined` if cache is empty.
	     */
	    pop() {
	        try {
	            while (this.#size) {
	                const val = this.#valList[this.#head];
	                this.#evict(true);
	                if (this.#isBackgroundFetch(val)) {
	                    if (val.__staleWhileFetching) {
	                        return val.__staleWhileFetching;
	                    }
	                }
	                else if (val !== undefined) {
	                    return val;
	                }
	            }
	        }
	        finally {
	            if (this.#hasDisposeAfter && this.#disposed) {
	                const dt = this.#disposed;
	                let task;
	                while ((task = dt?.shift())) {
	                    this.#disposeAfter?.(...task);
	                }
	            }
	        }
	    }
	    #evict(free) {
	        const head = this.#head;
	        const k = this.#keyList[head];
	        const v = this.#valList[head];
	        if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {
	            v.__abortController.abort(new Error('evicted'));
	        }
	        else if (this.#hasDispose || this.#hasDisposeAfter) {
	            if (this.#hasDispose) {
	                this.#dispose?.(v, k, 'evict');
	            }
	            if (this.#hasDisposeAfter) {
	                this.#disposed?.push([v, k, 'evict']);
	            }
	        }
	        this.#removeItemSize(head);
	        // if we aren't about to use the index, then null these out
	        if (free) {
	            this.#keyList[head] = undefined;
	            this.#valList[head] = undefined;
	            this.#free.push(head);
	        }
	        if (this.#size === 1) {
	            this.#head = this.#tail = 0;
	            this.#free.length = 0;
	        }
	        else {
	            this.#head = this.#next[head];
	        }
	        this.#keyMap.delete(k);
	        this.#size--;
	        return head;
	    }
	    /**
	     * Check if a key is in the cache, without updating the recency of use.
	     * Will return false if the item is stale, even though it is technically
	     * in the cache.
	     *
	     * Check if a key is in the cache, without updating the recency of
	     * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set
	     * to `true` in either the options or the constructor.
	     *
	     * Will return `false` if the item is stale, even though it is technically in
	     * the cache. The difference can be determined (if it matters) by using a
	     * `status` argument, and inspecting the `has` field.
	     *
	     * Will not update item age unless
	     * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
	     */
	    has(k, hasOptions = {}) {
	        const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
	        const index = this.#keyMap.get(k);
	        if (index !== undefined) {
	            const v = this.#valList[index];
	            if (this.#isBackgroundFetch(v) &&
	                v.__staleWhileFetching === undefined) {
	                return false;
	            }
	            if (!this.#isStale(index)) {
	                if (updateAgeOnHas) {
	                    this.#updateItemAge(index);
	                }
	                if (status) {
	                    status.has = 'hit';
	                    this.#statusTTL(status, index);
	                }
	                return true;
	            }
	            else if (status) {
	                status.has = 'stale';
	                this.#statusTTL(status, index);
	            }
	        }
	        else if (status) {
	            status.has = 'miss';
	        }
	        return false;
	    }
	    /**
	     * Like {@link LRUCache#get} but doesn't update recency or delete stale
	     * items.
	     *
	     * Returns `undefined` if the item is stale, unless
	     * {@link LRUCache.OptionsBase.allowStale} is set.
	     */
	    peek(k, peekOptions = {}) {
	        const { allowStale = this.allowStale } = peekOptions;
	        const index = this.#keyMap.get(k);
	        if (index === undefined ||
	            (!allowStale && this.#isStale(index))) {
	            return;
	        }
	        const v = this.#valList[index];
	        // either stale and allowed, or forcing a refresh of non-stale value
	        return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
	    }
	    #backgroundFetch(k, index, options, context) {
	        const v = index === undefined ? undefined : this.#valList[index];
	        if (this.#isBackgroundFetch(v)) {
	            return v;
	        }
	        const ac = new AC();
	        const { signal } = options;
	        // when/if our AC signals, then stop listening to theirs.
	        signal?.addEventListener('abort', () => ac.abort(signal.reason), {
	            signal: ac.signal,
	        });
	        const fetchOpts = {
	            signal: ac.signal,
	            options,
	            context,
	        };
	        const cb = (v, updateCache = false) => {
	            const { aborted } = ac.signal;
	            const ignoreAbort = options.ignoreFetchAbort && v !== undefined;
	            if (options.status) {
	                if (aborted && !updateCache) {
	                    options.status.fetchAborted = true;
	                    options.status.fetchError = ac.signal.reason;
	                    if (ignoreAbort)
	                        options.status.fetchAbortIgnored = true;
	                }
	                else {
	                    options.status.fetchResolved = true;
	                }
	            }
	            if (aborted && !ignoreAbort && !updateCache) {
	                return fetchFail(ac.signal.reason);
	            }
	            // either we didn't abort, and are still here, or we did, and ignored
	            const bf = p;
	            if (this.#valList[index] === p) {
	                if (v === undefined) {
	                    if (bf.__staleWhileFetching) {
	                        this.#valList[index] = bf.__staleWhileFetching;
	                    }
	                    else {
	                        this.#delete(k, 'fetch');
	                    }
	                }
	                else {
	                    if (options.status)
	                        options.status.fetchUpdated = true;
	                    this.set(k, v, fetchOpts.options);
	                }
	            }
	            return v;
	        };
	        const eb = (er) => {
	            if (options.status) {
	                options.status.fetchRejected = true;
	                options.status.fetchError = er;
	            }
	            return fetchFail(er);
	        };
	        const fetchFail = (er) => {
	            const { aborted } = ac.signal;
	            const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
	            const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
	            const noDelete = allowStale || options.noDeleteOnFetchRejection;
	            const bf = p;
	            if (this.#valList[index] === p) {
	                // if we allow stale on fetch rejections, then we need to ensure that
	                // the stale value is not removed from the cache when the fetch fails.
	                const del = !noDelete || bf.__staleWhileFetching === undefined;
	                if (del) {
	                    this.#delete(k, 'fetch');
	                }
	                else if (!allowStaleAborted) {
	                    // still replace the *promise* with the stale value,
	                    // since we are done with the promise at this point.
	                    // leave it untouched if we're still waiting for an
	                    // aborted background fetch that hasn't yet returned.
	                    this.#valList[index] = bf.__staleWhileFetching;
	                }
	            }
	            if (allowStale) {
	                if (options.status && bf.__staleWhileFetching !== undefined) {
	                    options.status.returnedStale = true;
	                }
	                return bf.__staleWhileFetching;
	            }
	            else if (bf.__returned === bf) {
	                throw er;
	            }
	        };
	        const pcall = (res, rej) => {
	            const fmp = this.#fetchMethod?.(k, v, fetchOpts);
	            if (fmp && fmp instanceof Promise) {
	                fmp.then(v => res(v === undefined ? undefined : v), rej);
	            }
	            // ignored, we go until we finish, regardless.
	            // defer check until we are actually aborting,
	            // so fetchMethod can override.
	            ac.signal.addEventListener('abort', () => {
	                if (!options.ignoreFetchAbort ||
	                    options.allowStaleOnFetchAbort) {
	                    res(undefined);
	                    // when it eventually resolves, update the cache.
	                    if (options.allowStaleOnFetchAbort) {
	                        res = v => cb(v, true);
	                    }
	                }
	            });
	        };
	        if (options.status)
	            options.status.fetchDispatched = true;
	        const p = new Promise(pcall).then(cb, eb);
	        const bf = Object.assign(p, {
	            __abortController: ac,
	            __staleWhileFetching: v,
	            __returned: undefined,
	        });
	        if (index === undefined) {
	            // internal, don't expose status.
	            this.set(k, bf, { ...fetchOpts.options, status: undefined });
	            index = this.#keyMap.get(k);
	        }
	        else {
	            this.#valList[index] = bf;
	        }
	        return bf;
	    }
	    #isBackgroundFetch(p) {
	        if (!this.#hasFetchMethod)
	            return false;
	        const b = p;
	        return (!!b &&
	            b instanceof Promise &&
	            b.hasOwnProperty('__staleWhileFetching') &&
	            b.__abortController instanceof AC);
	    }
	    async fetch(k, fetchOptions = {}) {
	        const { 
	        // get options
	        allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, 
	        // set options
	        ttl = this.ttl, noDisposeOnSet = this.noDisposeOnSet, size = 0, sizeCalculation = this.sizeCalculation, noUpdateTTL = this.noUpdateTTL, 
	        // fetch exclusive options
	        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection, allowStaleOnFetchRejection = this.allowStaleOnFetchRejection, ignoreFetchAbort = this.ignoreFetchAbort, allowStaleOnFetchAbort = this.allowStaleOnFetchAbort, context, forceRefresh = false, status, signal, } = fetchOptions;
	        if (!this.#hasFetchMethod) {
	            if (status)
	                status.fetch = 'get';
	            return this.get(k, {
	                allowStale,
	                updateAgeOnGet,
	                noDeleteOnStaleGet,
	                status,
	            });
	        }
	        const options = {
	            allowStale,
	            updateAgeOnGet,
	            noDeleteOnStaleGet,
	            ttl,
	            noDisposeOnSet,
	            size,
	            sizeCalculation,
	            noUpdateTTL,
	            noDeleteOnFetchRejection,
	            allowStaleOnFetchRejection,
	            allowStaleOnFetchAbort,
	            ignoreFetchAbort,
	            status,
	            signal,
	        };
	        let index = this.#keyMap.get(k);
	        if (index === undefined) {
	            if (status)
	                status.fetch = 'miss';
	            const p = this.#backgroundFetch(k, index, options, context);
	            return (p.__returned = p);
	        }
	        else {
	            // in cache, maybe already fetching
	            const v = this.#valList[index];
	            if (this.#isBackgroundFetch(v)) {
	                const stale = allowStale && v.__staleWhileFetching !== undefined;
	                if (status) {
	                    status.fetch = 'inflight';
	                    if (stale)
	                        status.returnedStale = true;
	                }
	                return stale ? v.__staleWhileFetching : (v.__returned = v);
	            }
	            // if we force a refresh, that means do NOT serve the cached value,
	            // unless we are already in the process of refreshing the cache.
	            const isStale = this.#isStale(index);
	            if (!forceRefresh && !isStale) {
	                if (status)
	                    status.fetch = 'hit';
	                this.#moveToTail(index);
	                if (updateAgeOnGet) {
	                    this.#updateItemAge(index);
	                }
	                if (status)
	                    this.#statusTTL(status, index);
	                return v;
	            }
	            // ok, it is stale or a forced refresh, and not already fetching.
	            // refresh the cache.
	            const p = this.#backgroundFetch(k, index, options, context);
	            const hasStale = p.__staleWhileFetching !== undefined;
	            const staleVal = hasStale && allowStale;
	            if (status) {
	                status.fetch = isStale ? 'stale' : 'refresh';
	                if (staleVal && isStale)
	                    status.returnedStale = true;
	            }
	            return staleVal ? p.__staleWhileFetching : (p.__returned = p);
	        }
	    }
	    async forceFetch(k, fetchOptions = {}) {
	        const v = await this.fetch(k, fetchOptions);
	        if (v === undefined)
	            throw new Error('fetch() returned undefined');
	        return v;
	    }
	    memo(k, memoOptions = {}) {
	        const memoMethod = this.#memoMethod;
	        if (!memoMethod) {
	            throw new Error('no memoMethod provided to constructor');
	        }
	        const { context, forceRefresh, ...options } = memoOptions;
	        const v = this.get(k, options);
	        if (!forceRefresh && v !== undefined)
	            return v;
	        const vv = memoMethod(k, v, {
	            options,
	            context,
	        });
	        this.set(k, vv, options);
	        return vv;
	    }
	    /**
	     * Return a value from the cache. Will update the recency of the cache
	     * entry found.
	     *
	     * If the key is not found, get() will return `undefined`.
	     */
	    get(k, getOptions = {}) {
	        const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status, } = getOptions;
	        const index = this.#keyMap.get(k);
	        if (index !== undefined) {
	            const value = this.#valList[index];
	            const fetching = this.#isBackgroundFetch(value);
	            if (status)
	                this.#statusTTL(status, index);
	            if (this.#isStale(index)) {
	                if (status)
	                    status.get = 'stale';
	                // delete only if not an in-flight background fetch
	                if (!fetching) {
	                    if (!noDeleteOnStaleGet) {
	                        this.#delete(k, 'expire');
	                    }
	                    if (status && allowStale)
	                        status.returnedStale = true;
	                    return allowStale ? value : undefined;
	                }
	                else {
	                    if (status &&
	                        allowStale &&
	                        value.__staleWhileFetching !== undefined) {
	                        status.returnedStale = true;
	                    }
	                    return allowStale ? value.__staleWhileFetching : undefined;
	                }
	            }
	            else {
	                if (status)
	                    status.get = 'hit';
	                // if we're currently fetching it, we don't actually have it yet
	                // it's not stale, which means this isn't a staleWhileRefetching.
	                // If it's not stale, and fetching, AND has a __staleWhileFetching
	                // value, then that means the user fetched with {forceRefresh:true},
	                // so it's safe to return that value.
	                if (fetching) {
	                    return value.__staleWhileFetching;
	                }
	                this.#moveToTail(index);
	                if (updateAgeOnGet) {
	                    this.#updateItemAge(index);
	                }
	                return value;
	            }
	        }
	        else if (status) {
	            status.get = 'miss';
	        }
	    }
	    #connect(p, n) {
	        this.#prev[n] = p;
	        this.#next[p] = n;
	    }
	    #moveToTail(index) {
	        // if tail already, nothing to do
	        // if head, move head to next[index]
	        // else
	        //   move next[prev[index]] to next[index] (head has no prev)
	        //   move prev[next[index]] to prev[index]
	        // prev[index] = tail
	        // next[tail] = index
	        // tail = index
	        if (index !== this.#tail) {
	            if (index === this.#head) {
	                this.#head = this.#next[index];
	            }
	            else {
	                this.#connect(this.#prev[index], this.#next[index]);
	            }
	            this.#connect(this.#tail, index);
	            this.#tail = index;
	        }
	    }
	    /**
	     * Deletes a key out of the cache.
	     *
	     * Returns true if the key was deleted, false otherwise.
	     */
	    delete(k) {
	        return this.#delete(k, 'delete');
	    }
	    #delete(k, reason) {
	        let deleted = false;
	        if (this.#size !== 0) {
	            const index = this.#keyMap.get(k);
	            if (index !== undefined) {
	                deleted = true;
	                if (this.#size === 1) {
	                    this.#clear(reason);
	                }
	                else {
	                    this.#removeItemSize(index);
	                    const v = this.#valList[index];
	                    if (this.#isBackgroundFetch(v)) {
	                        v.__abortController.abort(new Error('deleted'));
	                    }
	                    else if (this.#hasDispose || this.#hasDisposeAfter) {
	                        if (this.#hasDispose) {
	                            this.#dispose?.(v, k, reason);
	                        }
	                        if (this.#hasDisposeAfter) {
	                            this.#disposed?.push([v, k, reason]);
	                        }
	                    }
	                    this.#keyMap.delete(k);
	                    this.#keyList[index] = undefined;
	                    this.#valList[index] = undefined;
	                    if (index === this.#tail) {
	                        this.#tail = this.#prev[index];
	                    }
	                    else if (index === this.#head) {
	                        this.#head = this.#next[index];
	                    }
	                    else {
	                        const pi = this.#prev[index];
	                        this.#next[pi] = this.#next[index];
	                        const ni = this.#next[index];
	                        this.#prev[ni] = this.#prev[index];
	                    }
	                    this.#size--;
	                    this.#free.push(index);
	                }
	            }
	        }
	        if (this.#hasDisposeAfter && this.#disposed?.length) {
	            const dt = this.#disposed;
	            let task;
	            while ((task = dt?.shift())) {
	                this.#disposeAfter?.(...task);
	            }
	        }
	        return deleted;
	    }
	    /**
	     * Clear the cache entirely, throwing away all values.
	     */
	    clear() {
	        return this.#clear('delete');
	    }
	    #clear(reason) {
	        for (const index of this.#rindexes({ allowStale: true })) {
	            const v = this.#valList[index];
	            if (this.#isBackgroundFetch(v)) {
	                v.__abortController.abort(new Error('deleted'));
	            }
	            else {
	                const k = this.#keyList[index];
	                if (this.#hasDispose) {
	                    this.#dispose?.(v, k, reason);
	                }
	                if (this.#hasDisposeAfter) {
	                    this.#disposed?.push([v, k, reason]);
	                }
	            }
	        }
	        this.#keyMap.clear();
	        this.#valList.fill(undefined);
	        this.#keyList.fill(undefined);
	        if (this.#ttls && this.#starts) {
	            this.#ttls.fill(0);
	            this.#starts.fill(0);
	        }
	        if (this.#sizes) {
	            this.#sizes.fill(0);
	        }
	        this.#head = 0;
	        this.#tail = 0;
	        this.#free.length = 0;
	        this.#calculatedSize = 0;
	        this.#size = 0;
	        if (this.#hasDisposeAfter && this.#disposed) {
	            const dt = this.#disposed;
	            let task;
	            while ((task = dt?.shift())) {
	                this.#disposeAfter?.(...task);
	            }
	        }
	    }
	}
	commonjs.LRUCache = LRUCache;
	
	return commonjs;
}

/* eslint-disable max-len */

var hosts_1;
var hasRequiredHosts;

function requireHosts () {
	if (hasRequiredHosts) return hosts_1;
	hasRequiredHosts = 1;

	const maybeJoin = (...args) => args.every(arg => arg) ? args.join('') : '';
	const maybeEncode = (arg) => arg ? encodeURIComponent(arg) : '';
	const formatHashFragment = (f) => f.toLowerCase()
	  .replace(/^\W+/g, '') // strip leading non-characters
	  .replace(/(?<!\W)\W+$/, '') // strip trailing non-characters
	  .replace(/\//g, '') // strip all slashes
	  .replace(/\W+/g, '-'); // replace remaining non-characters with '-'

	const defaults = {
	  sshtemplate: ({ domain, user, project, committish }) =>
	    `git@${domain}:${user}/${project}.git${maybeJoin('#', committish)}`,
	  sshurltemplate: ({ domain, user, project, committish }) =>
	    `git+ssh://git@${domain}/${user}/${project}.git${maybeJoin('#', committish)}`,
	  edittemplate: ({ domain, user, project, committish, editpath, path }) =>
	    `https://${domain}/${user}/${project}${maybeJoin('/', editpath, '/', maybeEncode(committish || 'HEAD'), '/', path)}`,
	  browsetemplate: ({ domain, user, project, committish, treepath }) =>
	    `https://${domain}/${user}/${project}${maybeJoin('/', treepath, '/', maybeEncode(committish))}`,
	  browsetreetemplate: ({ domain, user, project, committish, treepath, path, fragment, hashformat }) =>
	    `https://${domain}/${user}/${project}/${treepath}/${maybeEncode(committish || 'HEAD')}/${path}${maybeJoin('#', hashformat(fragment || ''))}`,
	  browseblobtemplate: ({ domain, user, project, committish, blobpath, path, fragment, hashformat }) =>
	    `https://${domain}/${user}/${project}/${blobpath}/${maybeEncode(committish || 'HEAD')}/${path}${maybeJoin('#', hashformat(fragment || ''))}`,
	  docstemplate: ({ domain, user, project, treepath, committish }) =>
	    `https://${domain}/${user}/${project}${maybeJoin('/', treepath, '/', maybeEncode(committish))}#readme`,
	  httpstemplate: ({ auth, domain, user, project, committish }) =>
	    `git+https://${maybeJoin(auth, '@')}${domain}/${user}/${project}.git${maybeJoin('#', committish)}`,
	  filetemplate: ({ domain, user, project, committish, path }) =>
	    `https://${domain}/${user}/${project}/raw/${maybeEncode(committish || 'HEAD')}/${path}`,
	  shortcuttemplate: ({ type, user, project, committish }) =>
	    `${type}:${user}/${project}${maybeJoin('#', committish)}`,
	  pathtemplate: ({ user, project, committish }) =>
	    `${user}/${project}${maybeJoin('#', committish)}`,
	  bugstemplate: ({ domain, user, project }) =>
	    `https://${domain}/${user}/${project}/issues`,
	  hashformat: formatHashFragment,
	};

	const hosts = {};
	hosts.github = {
	  // First two are insecure and generally shouldn't be used any more, but
	  // they are still supported.
	  protocols: ['git:', 'http:', 'git+ssh:', 'git+https:', 'ssh:', 'https:'],
	  domain: 'github.com',
	  treepath: 'tree',
	  blobpath: 'blob',
	  editpath: 'edit',
	  filetemplate: ({ auth, user, project, committish, path }) =>
	    `https://${maybeJoin(auth, '@')}raw.githubusercontent.com/${user}/${project}/${maybeEncode(committish || 'HEAD')}/${path}`,
	  gittemplate: ({ auth, domain, user, project, committish }) =>
	    `git://${maybeJoin(auth, '@')}${domain}/${user}/${project}.git${maybeJoin('#', committish)}`,
	  tarballtemplate: ({ domain, user, project, committish }) =>
	    `https://codeload.${domain}/${user}/${project}/tar.gz/${maybeEncode(committish || 'HEAD')}`,
	  extract: (url) => {
	    let [, user, project, type, committish] = url.pathname.split('/', 5);
	    if (type && type !== 'tree') {
	      return
	    }

	    if (!type) {
	      committish = url.hash.slice(1);
	    }

	    if (project && project.endsWith('.git')) {
	      project = project.slice(0, -4);
	    }

	    if (!user || !project) {
	      return
	    }

	    return { user, project, committish }
	  },
	};

	hosts.bitbucket = {
	  protocols: ['git+ssh:', 'git+https:', 'ssh:', 'https:'],
	  domain: 'bitbucket.org',
	  treepath: 'src',
	  blobpath: 'src',
	  editpath: '?mode=edit',
	  edittemplate: ({ domain, user, project, committish, treepath, path, editpath }) =>
	    `https://${domain}/${user}/${project}${maybeJoin('/', treepath, '/', maybeEncode(committish || 'HEAD'), '/', path, editpath)}`,
	  tarballtemplate: ({ domain, user, project, committish }) =>
	    `https://${domain}/${user}/${project}/get/${maybeEncode(committish || 'HEAD')}.tar.gz`,
	  extract: (url) => {
	    let [, user, project, aux] = url.pathname.split('/', 4);
	    if (['get'].includes(aux)) {
	      return
	    }

	    if (project && project.endsWith('.git')) {
	      project = project.slice(0, -4);
	    }

	    if (!user || !project) {
	      return
	    }

	    return { user, project, committish: url.hash.slice(1) }
	  },
	};

	hosts.gitlab = {
	  protocols: ['git+ssh:', 'git+https:', 'ssh:', 'https:'],
	  domain: 'gitlab.com',
	  treepath: 'tree',
	  blobpath: 'tree',
	  editpath: '-/edit',
	  httpstemplate: ({ auth, domain, user, project, committish }) =>
	    `git+https://${maybeJoin(auth, '@')}${domain}/${user}/${project}.git${maybeJoin('#', committish)}`,
	  tarballtemplate: ({ domain, user, project, committish }) =>
	    `https://${domain}/${user}/${project}/repository/archive.tar.gz?ref=${maybeEncode(committish || 'HEAD')}`,
	  extract: (url) => {
	    const path = url.pathname.slice(1);
	    if (path.includes('/-/') || path.includes('/archive.tar.gz')) {
	      return
	    }

	    const segments = path.split('/');
	    let project = segments.pop();
	    if (project.endsWith('.git')) {
	      project = project.slice(0, -4);
	    }

	    const user = segments.join('/');
	    if (!user || !project) {
	      return
	    }

	    return { user, project, committish: url.hash.slice(1) }
	  },
	};

	hosts.gist = {
	  protocols: ['git:', 'git+ssh:', 'git+https:', 'ssh:', 'https:'],
	  domain: 'gist.github.com',
	  editpath: 'edit',
	  sshtemplate: ({ domain, project, committish }) =>
	    `git@${domain}:${project}.git${maybeJoin('#', committish)}`,
	  sshurltemplate: ({ domain, project, committish }) =>
	    `git+ssh://git@${domain}/${project}.git${maybeJoin('#', committish)}`,
	  edittemplate: ({ domain, user, project, committish, editpath }) =>
	    `https://${domain}/${user}/${project}${maybeJoin('/', maybeEncode(committish))}/${editpath}`,
	  browsetemplate: ({ domain, project, committish }) =>
	    `https://${domain}/${project}${maybeJoin('/', maybeEncode(committish))}`,
	  browsetreetemplate: ({ domain, project, committish, path, hashformat }) =>
	    `https://${domain}/${project}${maybeJoin('/', maybeEncode(committish))}${maybeJoin('#', hashformat(path))}`,
	  browseblobtemplate: ({ domain, project, committish, path, hashformat }) =>
	    `https://${domain}/${project}${maybeJoin('/', maybeEncode(committish))}${maybeJoin('#', hashformat(path))}`,
	  docstemplate: ({ domain, project, committish }) =>
	    `https://${domain}/${project}${maybeJoin('/', maybeEncode(committish))}`,
	  httpstemplate: ({ domain, project, committish }) =>
	    `git+https://${domain}/${project}.git${maybeJoin('#', committish)}`,
	  filetemplate: ({ user, project, committish, path }) =>
	    `https://gist.githubusercontent.com/${user}/${project}/raw${maybeJoin('/', maybeEncode(committish))}/${path}`,
	  shortcuttemplate: ({ type, project, committish }) =>
	    `${type}:${project}${maybeJoin('#', committish)}`,
	  pathtemplate: ({ project, committish }) =>
	    `${project}${maybeJoin('#', committish)}`,
	  bugstemplate: ({ domain, project }) =>
	    `https://${domain}/${project}`,
	  gittemplate: ({ domain, project, committish }) =>
	    `git://${domain}/${project}.git${maybeJoin('#', committish)}`,
	  tarballtemplate: ({ project, committish }) =>
	    `https://codeload.github.com/gist/${project}/tar.gz/${maybeEncode(committish || 'HEAD')}`,
	  extract: (url) => {
	    let [, user, project, aux] = url.pathname.split('/', 4);
	    if (aux === 'raw') {
	      return
	    }

	    if (!project) {
	      if (!user) {
	        return
	      }

	      project = user;
	      user = null;
	    }

	    if (project.endsWith('.git')) {
	      project = project.slice(0, -4);
	    }

	    return { user, project, committish: url.hash.slice(1) }
	  },
	  hashformat: function (fragment) {
	    return fragment && 'file-' + formatHashFragment(fragment)
	  },
	};

	hosts.sourcehut = {
	  protocols: ['git+ssh:', 'https:'],
	  domain: 'git.sr.ht',
	  treepath: 'tree',
	  blobpath: 'tree',
	  filetemplate: ({ domain, user, project, committish, path }) =>
	    `https://${domain}/${user}/${project}/blob/${maybeEncode(committish) || 'HEAD'}/${path}`,
	  httpstemplate: ({ domain, user, project, committish }) =>
	    `https://${domain}/${user}/${project}.git${maybeJoin('#', committish)}`,
	  tarballtemplate: ({ domain, user, project, committish }) =>
	    `https://${domain}/${user}/${project}/archive/${maybeEncode(committish) || 'HEAD'}.tar.gz`,
	  bugstemplate: () => null,
	  extract: (url) => {
	    let [, user, project, aux] = url.pathname.split('/', 4);

	    // tarball url
	    if (['archive'].includes(aux)) {
	      return
	    }

	    if (project && project.endsWith('.git')) {
	      project = project.slice(0, -4);
	    }

	    if (!user || !project) {
	      return
	    }

	    return { user, project, committish: url.hash.slice(1) }
	  },
	};

	for (const [name, host] of Object.entries(hosts)) {
	  hosts[name] = Object.assign({}, defaults, host);
	}

	hosts_1 = hosts;
	return hosts_1;
}

var parseUrl;
var hasRequiredParseUrl;

function requireParseUrl () {
	if (hasRequiredParseUrl) return parseUrl;
	hasRequiredParseUrl = 1;
	const url = require$$0;

	const lastIndexOfBefore = (str, char, beforeChar) => {
	  const startPosition = str.indexOf(beforeChar);
	  return str.lastIndexOf(char, startPosition > -1 ? startPosition : Infinity)
	};

	const safeUrl = (u) => {
	  try {
	    return new url.URL(u)
	  } catch {
	    // this fn should never throw
	  }
	};

	// accepts input like git:github.com:user/repo and inserts the // after the first :
	const correctProtocol = (arg, protocols) => {
	  const firstColon = arg.indexOf(':');
	  const proto = arg.slice(0, firstColon + 1);
	  if (Object.prototype.hasOwnProperty.call(protocols, proto)) {
	    return arg
	  }

	  const firstAt = arg.indexOf('@');
	  if (firstAt > -1) {
	    if (firstAt > firstColon) {
	      return `git+ssh://${arg}`
	    } else {
	      return arg
	    }
	  }

	  const doubleSlash = arg.indexOf('//');
	  if (doubleSlash === firstColon + 1) {
	    return arg
	  }

	  return `${arg.slice(0, firstColon + 1)}//${arg.slice(firstColon + 1)}`
	};

	// attempt to correct an scp style url so that it will parse with `new URL()`
	const correctUrl = (giturl) => {
	  // ignore @ that come after the first hash since the denotes the start
	  // of a committish which can contain @ characters
	  const firstAt = lastIndexOfBefore(giturl, '@', '#');
	  // ignore colons that come after the hash since that could include colons such as:
	  // git@github.com:user/package-2#semver:^1.0.0
	  const lastColonBeforeHash = lastIndexOfBefore(giturl, ':', '#');

	  if (lastColonBeforeHash > firstAt) {
	    // the last : comes after the first @ (or there is no @)
	    // like it would in:
	    // proto://hostname.com:user/repo
	    // username@hostname.com:user/repo
	    // :password@hostname.com:user/repo
	    // username:password@hostname.com:user/repo
	    // proto://username@hostname.com:user/repo
	    // proto://:password@hostname.com:user/repo
	    // proto://username:password@hostname.com:user/repo
	    // then we replace the last : with a / to create a valid path
	    giturl = giturl.slice(0, lastColonBeforeHash) + '/' + giturl.slice(lastColonBeforeHash + 1);
	  }

	  if (lastIndexOfBefore(giturl, ':', '#') === -1 && giturl.indexOf('//') === -1) {
	    // we have no : at all
	    // as it would be in:
	    // username@hostname.com/user/repo
	    // then we prepend a protocol
	    giturl = `git+ssh://${giturl}`;
	  }

	  return giturl
	};

	parseUrl = (giturl, protocols) => {
	  const withProtocol = protocols ? correctProtocol(giturl, protocols) : giturl;
	  return safeUrl(withProtocol) || safeUrl(correctUrl(withProtocol))
	};
	return parseUrl;
}

var fromUrl;
var hasRequiredFromUrl;

function requireFromUrl () {
	if (hasRequiredFromUrl) return fromUrl;
	hasRequiredFromUrl = 1;

	const parseUrl = requireParseUrl();

	// look for github shorthand inputs, such as npm/cli
	const isGitHubShorthand = (arg) => {
	  // it cannot contain whitespace before the first #
	  // it cannot start with a / because that's probably an absolute file path
	  // but it must include a slash since repos are username/repository
	  // it cannot start with a . because that's probably a relative file path
	  // it cannot start with an @ because that's a scoped package if it passes the other tests
	  // it cannot contain a : before a # because that tells us that there's a protocol
	  // a second / may not exist before a #
	  const firstHash = arg.indexOf('#');
	  const firstSlash = arg.indexOf('/');
	  const secondSlash = arg.indexOf('/', firstSlash + 1);
	  const firstColon = arg.indexOf(':');
	  const firstSpace = /\s/.exec(arg);
	  const firstAt = arg.indexOf('@');

	  const spaceOnlyAfterHash = !firstSpace || (firstHash > -1 && firstSpace.index > firstHash);
	  const atOnlyAfterHash = firstAt === -1 || (firstHash > -1 && firstAt > firstHash);
	  const colonOnlyAfterHash = firstColon === -1 || (firstHash > -1 && firstColon > firstHash);
	  const secondSlashOnlyAfterHash = secondSlash === -1 || (firstHash > -1 && secondSlash > firstHash);
	  const hasSlash = firstSlash > 0;
	  // if a # is found, what we really want to know is that the character
	  // immediately before # is not a /
	  const doesNotEndWithSlash = firstHash > -1 ? arg[firstHash - 1] !== '/' : !arg.endsWith('/');
	  const doesNotStartWithDot = !arg.startsWith('.');

	  return spaceOnlyAfterHash && hasSlash && doesNotEndWithSlash &&
	    doesNotStartWithDot && atOnlyAfterHash && colonOnlyAfterHash &&
	    secondSlashOnlyAfterHash
	};

	fromUrl = (giturl, opts, { gitHosts, protocols }) => {
	  if (!giturl) {
	    return
	  }

	  const correctedUrl = isGitHubShorthand(giturl) ? `github:${giturl}` : giturl;
	  const parsed = parseUrl(correctedUrl, protocols);
	  if (!parsed) {
	    return
	  }

	  const gitHostShortcut = gitHosts.byShortcut[parsed.protocol];
	  const gitHostDomain = gitHosts.byDomain[parsed.hostname.startsWith('www.')
	    ? parsed.hostname.slice(4)
	    : parsed.hostname];
	  const gitHostName = gitHostShortcut || gitHostDomain;
	  if (!gitHostName) {
	    return
	  }

	  const gitHostInfo = gitHosts[gitHostShortcut || gitHostDomain];
	  let auth = null;
	  if (protocols[parsed.protocol]?.auth && (parsed.username || parsed.password)) {
	    auth = `${parsed.username}${parsed.password ? ':' + parsed.password : ''}`;
	  }

	  let committish = null;
	  let user = null;
	  let project = null;
	  let defaultRepresentation = null;

	  try {
	    if (gitHostShortcut) {
	      let pathname = parsed.pathname.startsWith('/') ? parsed.pathname.slice(1) : parsed.pathname;
	      const firstAt = pathname.indexOf('@');
	      // we ignore auth for shortcuts, so just trim it out
	      if (firstAt > -1) {
	        pathname = pathname.slice(firstAt + 1);
	      }

	      const lastSlash = pathname.lastIndexOf('/');
	      if (lastSlash > -1) {
	        user = decodeURIComponent(pathname.slice(0, lastSlash));
	        // we want nulls only, never empty strings
	        if (!user) {
	          user = null;
	        }
	        project = decodeURIComponent(pathname.slice(lastSlash + 1));
	      } else {
	        project = decodeURIComponent(pathname);
	      }

	      if (project.endsWith('.git')) {
	        project = project.slice(0, -4);
	      }

	      if (parsed.hash) {
	        committish = decodeURIComponent(parsed.hash.slice(1));
	      }

	      defaultRepresentation = 'shortcut';
	    } else {
	      if (!gitHostInfo.protocols.includes(parsed.protocol)) {
	        return
	      }

	      const segments = gitHostInfo.extract(parsed);
	      if (!segments) {
	        return
	      }

	      user = segments.user && decodeURIComponent(segments.user);
	      project = decodeURIComponent(segments.project);
	      committish = decodeURIComponent(segments.committish);
	      defaultRepresentation = protocols[parsed.protocol]?.name || parsed.protocol.slice(0, -1);
	    }
	  } catch (err) {
	    /* istanbul ignore else */
	    if (err instanceof URIError) {
	      return
	    } else {
	      throw err
	    }
	  }

	  return [gitHostName, user, auth, project, committish, defaultRepresentation, opts]
	};
	return fromUrl;
}

var lib;
var hasRequiredLib;

function requireLib () {
	if (hasRequiredLib) return lib;
	hasRequiredLib = 1;

	const { LRUCache } = /*@__PURE__*/ requireCommonjs();
	const hosts = requireHosts();
	const fromUrl = requireFromUrl();
	const parseUrl = requireParseUrl();

	const cache = new LRUCache({ max: 1000 });

	function unknownHostedUrl (url) {
	  try {
	    const {
	      protocol,
	      hostname,
	      pathname,
	    } = new URL(url);

	    if (!hostname) {
	      return null
	    }

	    const proto = /(?:git\+)http:$/.test(protocol) ? 'http:' : 'https:';
	    const path = pathname.replace(/\.git$/, '');
	    return `${proto}//${hostname}${path}`
	  } catch {
	    return null
	  }
	}

	class GitHost {
	  constructor (type, user, auth, project, committish, defaultRepresentation, opts = {}) {
	    Object.assign(this, GitHost.#gitHosts[type], {
	      type,
	      user,
	      auth,
	      project,
	      committish,
	      default: defaultRepresentation,
	      opts,
	    });
	  }

	  static #gitHosts = { byShortcut: {}, byDomain: {} }
	  static #protocols = {
	    'git+ssh:': { name: 'sshurl' },
	    'ssh:': { name: 'sshurl' },
	    'git+https:': { name: 'https', auth: true },
	    'git:': { auth: true },
	    'http:': { auth: true },
	    'https:': { auth: true },
	    'git+http:': { auth: true },
	  }

	  static addHost (name, host) {
	    GitHost.#gitHosts[name] = host;
	    GitHost.#gitHosts.byDomain[host.domain] = name;
	    GitHost.#gitHosts.byShortcut[`${name}:`] = name;
	    GitHost.#protocols[`${name}:`] = { name };
	  }

	  static fromUrl (giturl, opts) {
	    if (typeof giturl !== 'string') {
	      return
	    }

	    const key = giturl + JSON.stringify(opts || {});

	    if (!cache.has(key)) {
	      const hostArgs = fromUrl(giturl, opts, {
	        gitHosts: GitHost.#gitHosts,
	        protocols: GitHost.#protocols,
	      });
	      cache.set(key, hostArgs ? new GitHost(...hostArgs) : undefined);
	    }

	    return cache.get(key)
	  }

	  static fromManifest (manifest, opts = {}) {
	    if (!manifest || typeof manifest !== 'object') {
	      return
	    }

	    const r = manifest.repository;
	    // TODO: look into also checking the `bugs`/`homepage` URLs

	    const rurl = r && (
	      typeof r === 'string'
	        ? r
	        : typeof r === 'object' && typeof r.url === 'string'
	          ? r.url
	          : null
	    );

	    if (!rurl) {
	      throw new Error('no repository')
	    }

	    const info = (rurl && GitHost.fromUrl(rurl.replace(/^git\+/, ''), opts)) || null;
	    if (info) {
	      return info
	    }
	    const unk = unknownHostedUrl(rurl);
	    return GitHost.fromUrl(unk, opts) || unk
	  }

	  static parseUrl (url) {
	    return parseUrl(url)
	  }

	  #fill (template, opts) {
	    if (typeof template !== 'function') {
	      return null
	    }

	    const options = { ...this, ...this.opts, ...opts };

	    // the path should always be set so we don't end up with 'undefined' in urls
	    if (!options.path) {
	      options.path = '';
	    }

	    // template functions will insert the leading slash themselves
	    if (options.path.startsWith('/')) {
	      options.path = options.path.slice(1);
	    }

	    if (options.noCommittish) {
	      options.committish = null;
	    }

	    const result = template(options);
	    return options.noGitPlus && result.startsWith('git+') ? result.slice(4) : result
	  }

	  hash () {
	    return this.committish ? `#${this.committish}` : ''
	  }

	  ssh (opts) {
	    return this.#fill(this.sshtemplate, opts)
	  }

	  sshurl (opts) {
	    return this.#fill(this.sshurltemplate, opts)
	  }

	  browse (path, ...args) {
	    // not a string, treat path as opts
	    if (typeof path !== 'string') {
	      return this.#fill(this.browsetemplate, path)
	    }

	    if (typeof args[0] !== 'string') {
	      return this.#fill(this.browsetreetemplate, { ...args[0], path })
	    }

	    return this.#fill(this.browsetreetemplate, { ...args[1], fragment: args[0], path })
	  }

	  // If the path is known to be a file, then browseFile should be used. For some hosts
	  // the url is the same as browse, but for others like GitHub a file can use both `/tree/`
	  // and `/blob/` in the path. When using a default committish of `HEAD` then the `/tree/`
	  // path will redirect to a specific commit. Using the `/blob/` path avoids this and
	  // does not redirect to a different commit.
	  browseFile (path, ...args) {
	    if (typeof args[0] !== 'string') {
	      return this.#fill(this.browseblobtemplate, { ...args[0], path })
	    }

	    return this.#fill(this.browseblobtemplate, { ...args[1], fragment: args[0], path })
	  }

	  docs (opts) {
	    return this.#fill(this.docstemplate, opts)
	  }

	  bugs (opts) {
	    return this.#fill(this.bugstemplate, opts)
	  }

	  https (opts) {
	    return this.#fill(this.httpstemplate, opts)
	  }

	  git (opts) {
	    return this.#fill(this.gittemplate, opts)
	  }

	  shortcut (opts) {
	    return this.#fill(this.shortcuttemplate, opts)
	  }

	  path (opts) {
	    return this.#fill(this.pathtemplate, opts)
	  }

	  tarball (opts) {
	    return this.#fill(this.tarballtemplate, { ...opts, noCommittish: false })
	  }

	  file (path, opts) {
	    return this.#fill(this.filetemplate, { ...opts, path })
	  }

	  edit (path, opts) {
	    return this.#fill(this.edittemplate, { ...opts, path })
	  }

	  getDefaultRepresentation () {
	    return this.default
	  }

	  toString (opts) {
	    if (this.default && typeof this[this.default] === 'function') {
	      return this[this.default](opts)
	    }

	    return this.sshurl(opts)
	  }
	}

	for (const [name, host] of Object.entries(hosts)) {
	  GitHost.addHost(name, host);
	}

	lib = GitHost;
	return lib;
}

var hasRequiredNpa;

function requireNpa () {
	if (hasRequiredNpa) return npa.exports;
	hasRequiredNpa = 1;

	const isWindows = process.platform === 'win32';

	const { URL } = require$$0$1;
	// We need to use path/win32 so that we get consistent results in tests, but this also means we need to manually convert backslashes to forward slashes when generating file: urls with paths.
	const path = isWindows ? require$$1$1 : require$$2;
	const { homedir } = require$$1;
	const HostedGit = requireLib();
	const semver = requireSemver();
	const validatePackageName = requireLib$1();
	const { log } = requireLib$2();

	const hasSlashes = isWindows ? /\\|[/]/ : /[/]/;
	const isURL = /^(?:git[+])?[a-z]+:/i;
	const isGit = /^[^@]+@[^:.]+\.[^:]+:.+$/i;
	const isFileType = /[.](?:tgz|tar.gz|tar)$/i;
	const isPortNumber = /:[0-9]+(\/|$)/i;
	const isWindowsFile = /^(?:[.]|~[/]|[/\\]|[a-zA-Z]:)/;
	const isPosixFile = /^(?:[.]|~[/]|[/]|[a-zA-Z]:)/;
	const defaultRegistry = 'https://registry.npmjs.org';

	function npa$1 (arg, where) {
	  let name;
	  let spec;
	  if (typeof arg === 'object') {
	    if (arg instanceof Result && (!where || where === arg.where)) {
	      return arg
	    } else if (arg.name && arg.rawSpec) {
	      return npa$1.resolve(arg.name, arg.rawSpec, where || arg.where)
	    } else {
	      return npa$1(arg.raw, where || arg.where)
	    }
	  }
	  const nameEndsAt = arg.indexOf('@', 1); // Skip possible leading @
	  const namePart = nameEndsAt > 0 ? arg.slice(0, nameEndsAt) : arg;
	  if (isURL.test(arg)) {
	    spec = arg;
	  } else if (isGit.test(arg)) {
	    spec = `git+ssh://${arg}`;
	  // eslint-disable-next-line max-len
	  } else if (!namePart.startsWith('@') && (hasSlashes.test(namePart) || isFileType.test(namePart))) {
	    spec = arg;
	  } else if (nameEndsAt > 0) {
	    name = namePart;
	    spec = arg.slice(nameEndsAt + 1) || '*';
	  } else {
	    const valid = validatePackageName(arg);
	    if (valid.validForOldPackages) {
	      name = arg;
	      spec = '*';
	    } else {
	      spec = arg;
	    }
	  }
	  return resolve(name, spec, where, arg)
	}

	function isFileSpec (spec) {
	  if (!spec) {
	    return false
	  }
	  if (spec.toLowerCase().startsWith('file:')) {
	    return true
	  }
	  if (isWindows) {
	    return isWindowsFile.test(spec)
	  }
	  // We never hit this in windows tests, obviously
	  /* istanbul ignore next */
	  return isPosixFile.test(spec)
	}

	function isAliasSpec (spec) {
	  if (!spec) {
	    return false
	  }
	  return spec.toLowerCase().startsWith('npm:')
	}

	function resolve (name, spec, where, arg) {
	  const res = new Result({
	    raw: arg,
	    name: name,
	    rawSpec: spec,
	    fromArgument: arg != null,
	  });

	  if (name) {
	    res.name = name;
	  }

	  if (!where) {
	    where = process.cwd();
	  }

	  if (isFileSpec(spec)) {
	    return fromFile(res, where)
	  } else if (isAliasSpec(spec)) {
	    return fromAlias(res, where)
	  }

	  const hosted = HostedGit.fromUrl(spec, {
	    noGitPlus: true,
	    noCommittish: true,
	  });
	  if (hosted) {
	    return fromHostedGit(res, hosted)
	  } else if (spec && isURL.test(spec)) {
	    return fromURL(res)
	  } else if (spec && (hasSlashes.test(spec) || isFileType.test(spec))) {
	    return fromFile(res, where)
	  } else {
	    return fromRegistry(res)
	  }
	}

	function toPurl (arg, reg = defaultRegistry) {
	  const res = npa$1(arg);

	  if (res.type !== 'version') {
	    throw invalidPurlType(res.type, res.raw)
	  }

	  // URI-encode leading @ of scoped packages
	  let purl = 'pkg:npm/' + res.name.replace(/^@/, '%40') + '@' + res.rawSpec;
	  if (reg !== defaultRegistry) {
	    purl += '?repository_url=' + reg;
	  }

	  return purl
	}

	function invalidPackageName (name, valid, raw) {
	  // eslint-disable-next-line max-len
	  const err = new Error(`Invalid package name "${name}" of package "${raw}": ${valid.errors.join('; ')}.`);
	  err.code = 'EINVALIDPACKAGENAME';
	  return err
	}

	function invalidTagName (name, raw) {
	  // eslint-disable-next-line max-len
	  const err = new Error(`Invalid tag name "${name}" of package "${raw}": Tags may not have any characters that encodeURIComponent encodes.`);
	  err.code = 'EINVALIDTAGNAME';
	  return err
	}

	function invalidPurlType (type, raw) {
	  // eslint-disable-next-line max-len
	  const err = new Error(`Invalid type "${type}" of package "${raw}": Purl can only be generated for "version" types.`);
	  err.code = 'EINVALIDPURLTYPE';
	  return err
	}

	class Result {
	  constructor (opts) {
	    this.type = opts.type;
	    this.registry = opts.registry;
	    this.where = opts.where;
	    if (opts.raw == null) {
	      this.raw = opts.name ? `${opts.name}@${opts.rawSpec}` : opts.rawSpec;
	    } else {
	      this.raw = opts.raw;
	    }
	    this.name = undefined;
	    this.escapedName = undefined;
	    this.scope = undefined;
	    this.rawSpec = opts.rawSpec || '';
	    this.saveSpec = opts.saveSpec;
	    this.fetchSpec = opts.fetchSpec;
	    if (opts.name) {
	      this.setName(opts.name);
	    }
	    this.gitRange = opts.gitRange;
	    this.gitCommittish = opts.gitCommittish;
	    this.gitSubdir = opts.gitSubdir;
	    this.hosted = opts.hosted;
	  }

	  // TODO move this to a getter/setter in a semver major
	  setName (name) {
	    const valid = validatePackageName(name);
	    if (!valid.validForOldPackages) {
	      throw invalidPackageName(name, valid, this.raw)
	    }

	    this.name = name;
	    this.scope = name[0] === '@' ? name.slice(0, name.indexOf('/')) : undefined;
	    // scoped packages in couch must have slash url-encoded, e.g. @foo%2Fbar
	    this.escapedName = name.replace('/', '%2f');
	    return this
	  }

	  toString () {
	    const full = [];
	    if (this.name != null && this.name !== '') {
	      full.push(this.name);
	    }
	    const spec = this.saveSpec || this.fetchSpec || this.rawSpec;
	    if (spec != null && spec !== '') {
	      full.push(spec);
	    }
	    return full.length ? full.join('@') : this.raw
	  }

	  toJSON () {
	    const result = Object.assign({}, this);
	    delete result.hosted;
	    return result
	  }
	}

	// sets res.gitCommittish, res.gitRange, and res.gitSubdir
	function setGitAttrs (res, committish) {
	  if (!committish) {
	    res.gitCommittish = null;
	    return
	  }

	  // for each :: separated item:
	  for (const part of committish.split('::')) {
	    // if the item has no : the n it is a commit-ish
	    if (!part.includes(':')) {
	      if (res.gitRange) {
	        throw new Error('cannot override existing semver range with a committish')
	      }
	      if (res.gitCommittish) {
	        throw new Error('cannot override existing committish with a second committish')
	      }
	      res.gitCommittish = part;
	      continue
	    }
	    // split on name:value
	    const [name, value] = part.split(':');
	    // if name is semver do semver lookup of ref or tag
	    if (name === 'semver') {
	      if (res.gitCommittish) {
	        throw new Error('cannot override existing committish with a semver range')
	      }
	      if (res.gitRange) {
	        throw new Error('cannot override existing semver range with a second semver range')
	      }
	      res.gitRange = decodeURIComponent(value);
	      continue
	    }
	    if (name === 'path') {
	      if (res.gitSubdir) {
	        throw new Error('cannot override existing path with a second path')
	      }
	      res.gitSubdir = `/${value}`;
	      continue
	    }
	    log.warn('npm-package-arg', `ignoring unknown key "${name}"`);
	  }
	}

	// Taken from: EncodePathChars and lookup_table in src/node_url.cc
	// url.pathToFileURL only returns absolute references.  We can't use it to encode paths.
	// encodeURI mangles windows paths. We can't use it to encode paths.
	// Under the hood, url.pathToFileURL does a limited set of encoding, with an extra windows step, and then calls path.resolve.
	// The encoding node does without path.resolve is not available outside of the source, so we are recreating it here.
	const encodedPathChars = new Map([
	  ['\0', '%00'],
	  ['\t', '%09'],
	  ['\n', '%0A'],
	  ['\r', '%0D'],
	  [' ', '%20'],
	  ['"', '%22'],
	  ['#', '%23'],
	  ['%', '%25'],
	  ['?', '%3F'],
	  ['[', '%5B'],
	  ['\\', isWindows ? '/' : '%5C'],
	  [']', '%5D'],
	  ['^', '%5E'],
	  ['|', '%7C'],
	  ['~', '%7E'],
	]);

	function pathToFileURL (str) {
	  let result = '';
	  for (let i = 0; i < str.length; i++) {
	    result = `${result}${encodedPathChars.get(str[i]) ?? str[i]}`;
	  }
	  if (result.startsWith('file:')) {
	    return result
	  }
	  return `file:${result}`
	}

	function fromFile (res, where) {
	  res.type = isFileType.test(res.rawSpec) ? 'file' : 'directory';
	  res.where = where;

	  let rawSpec = pathToFileURL(res.rawSpec);

	  if (rawSpec.startsWith('file:/')) {
	    // XXX backwards compatibility lack of compliance with RFC 8089

	    // turn file://path into file:/path
	    if (/^file:\/\/[^/]/.test(rawSpec)) {
	      rawSpec = `file:/${rawSpec.slice(5)}`;
	    }

	    // turn file:/../path into file:../path
	    // for 1 or 3 leading slashes (2 is already ruled out from handling file:// explicitly above)
	    if (/^\/{1,3}\.\.?(\/|$)/.test(rawSpec.slice(5))) {
	      rawSpec = rawSpec.replace(/^file:\/{1,3}/, 'file:');
	    }
	  }

	  let resolvedUrl;
	  let specUrl;
	  try {
	    // always put the '/' on "where", or else file:foo from /path/to/bar goes to /path/to/foo, when we want it to be /path/to/bar/foo
	    resolvedUrl = new URL(rawSpec, `${pathToFileURL(path.resolve(where))}/`);
	    specUrl = new URL(rawSpec);
	  } catch (originalError) {
	    const er = new Error('Invalid file: URL, must comply with RFC 8089');
	    throw Object.assign(er, {
	      raw: res.rawSpec,
	      spec: res,
	      where,
	      originalError,
	    })
	  }

	  // turn /C:/blah into just C:/blah on windows
	  let specPath = decodeURIComponent(specUrl.pathname);
	  let resolvedPath = decodeURIComponent(resolvedUrl.pathname);
	  if (isWindows) {
	    specPath = specPath.replace(/^\/+([a-z]:\/)/i, '$1');
	    resolvedPath = resolvedPath.replace(/^\/+([a-z]:\/)/i, '$1');
	  }

	  // replace ~ with homedir, but keep the ~ in the saveSpec
	  // otherwise, make it relative to where param
	  if (/^\/~(\/|$)/.test(specPath)) {
	    res.saveSpec = `file:${specPath.substr(1)}`;
	    resolvedPath = path.resolve(homedir(), specPath.substr(3));
	  } else if (!path.isAbsolute(rawSpec.slice(5))) {
	    res.saveSpec = `file:${path.relative(where, resolvedPath)}`;
	  } else {
	    res.saveSpec = `file:${path.resolve(resolvedPath)}`;
	  }

	  res.fetchSpec = path.resolve(where, resolvedPath);
	  // re-normalize the slashes in saveSpec due to node:path/win32 behavior in windows
	  res.saveSpec = res.saveSpec.split('\\').join('/');
	  // Ignoring because this only happens in windows
	  /* istanbul ignore next */
	  if (res.saveSpec.startsWith('file://')) {
	    // normalization of \\win32\root paths can cause a double / which we don't want
	    res.saveSpec = `file:/${res.saveSpec.slice(7)}`;
	  }
	  return res
	}

	function fromHostedGit (res, hosted) {
	  res.type = 'git';
	  res.hosted = hosted;
	  res.saveSpec = hosted.toString({ noGitPlus: false, noCommittish: false });
	  res.fetchSpec = hosted.getDefaultRepresentation() === 'shortcut' ? null : hosted.toString();
	  setGitAttrs(res, hosted.committish);
	  return res
	}

	function unsupportedURLType (protocol, spec) {
	  const err = new Error(`Unsupported URL Type "${protocol}": ${spec}`);
	  err.code = 'EUNSUPPORTEDPROTOCOL';
	  return err
	}

	function fromURL (res) {
	  let rawSpec = res.rawSpec;
	  res.saveSpec = rawSpec;
	  if (rawSpec.startsWith('git+ssh:')) {
	    // git ssh specifiers are overloaded to also use scp-style git
	    // specifiers, so we have to parse those out and treat them special.
	    // They are NOT true URIs, so we can't hand them to URL.

	    // This regex looks for things that look like:
	    // git+ssh://git@my.custom.git.com:username/project.git#deadbeef
	    // ...and various combinations. The username in the beginning is *required*.
	    const matched = rawSpec.match(/^git\+ssh:\/\/([^:#]+:[^#]+(?:\.git)?)(?:#(.*))?$/i);
	    // Filter out all-number "usernames" which are really port numbers
	    // They can either be :1234 :1234/ or :1234/path but not :12abc
	    if (matched && !matched[1].match(isPortNumber)) {
	      res.type = 'git';
	      setGitAttrs(res, matched[2]);
	      res.fetchSpec = matched[1];
	      return res
	    }
	  } else if (rawSpec.startsWith('git+file://')) {
	    // URL can't handle windows paths
	    rawSpec = rawSpec.replace(/\\/g, '/');
	  }
	  const parsedUrl = new URL(rawSpec);
	  // check the protocol, and then see if it's git or not
	  switch (parsedUrl.protocol) {
	    case 'git:':
	    case 'git+http:':
	    case 'git+https:':
	    case 'git+rsync:':
	    case 'git+ftp:':
	    case 'git+file:':
	    case 'git+ssh:':
	      res.type = 'git';
	      setGitAttrs(res, parsedUrl.hash.slice(1));
	      if (parsedUrl.protocol === 'git+file:' && /^git\+file:\/\/[a-z]:/i.test(rawSpec)) {
	        // URL can't handle drive letters on windows file paths, the host can't contain a :
	        res.fetchSpec = `git+file://${parsedUrl.host.toLowerCase()}:${parsedUrl.pathname}`;
	      } else {
	        parsedUrl.hash = '';
	        res.fetchSpec = parsedUrl.toString();
	      }
	      if (res.fetchSpec.startsWith('git+')) {
	        res.fetchSpec = res.fetchSpec.slice(4);
	      }
	      break
	    case 'http:':
	    case 'https:':
	      res.type = 'remote';
	      res.fetchSpec = res.saveSpec;
	      break

	    default:
	      throw unsupportedURLType(parsedUrl.protocol, rawSpec)
	  }

	  return res
	}

	function fromAlias (res, where) {
	  const subSpec = npa$1(res.rawSpec.substr(4), where);
	  if (subSpec.type === 'alias') {
	    throw new Error('nested aliases not supported')
	  }

	  if (!subSpec.registry) {
	    throw new Error('aliases only work for registry deps')
	  }

	  if (!subSpec.name) {
	    throw new Error('aliases must have a name')
	  }

	  res.subSpec = subSpec;
	  res.registry = true;
	  res.type = 'alias';
	  res.saveSpec = null;
	  res.fetchSpec = null;
	  return res
	}

	function fromRegistry (res) {
	  res.registry = true;
	  const spec = res.rawSpec.trim();
	  // no save spec for registry components as we save based on the fetched
	  // version, not on the argument so this can't compute that.
	  res.saveSpec = null;
	  res.fetchSpec = spec;
	  const version = semver.valid(spec, true);
	  const range = semver.validRange(spec, true);
	  if (version) {
	    res.type = 'version';
	  } else if (range) {
	    res.type = 'range';
	  } else {
	    if (encodeURIComponent(spec) !== spec) {
	      throw invalidTagName(spec, res.raw)
	    }
	    res.type = 'tag';
	  }
	  return res
	}

	npa.exports = npa$1;
	npa.exports.resolve = resolve;
	npa.exports.toPurl = toPurl;
	npa.exports.Result = Result;
	return npa.exports;
}

export { requireCommonjs as a, requireNpa as r };
