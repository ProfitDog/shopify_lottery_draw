import { Agent } from 'package-manager-detector';
import { PnpmWorkspaceYaml } from 'pnpm-workspace-yaml';

declare const MODE_CHOICES: readonly ["default", "major", "minor", "patch", "latest", "newest", "next"];

type SortKey = 'time' | 'diff' | 'name';
type SortOrder = 'asc' | 'desc';
type SortOption = `${SortKey}-${SortOrder}`;

type RangeMode = typeof MODE_CHOICES[number];
type PackageMode = Exclude<RangeMode, 'default'> | 'ignore';
type DepType = 'dependencies' | 'devDependencies' | 'peerDependencies' | 'optionalDependencies' | 'packageManager' | 'pnpm.overrides' | 'resolutions' | 'overrides' | 'pnpm-workspace';
declare const DependenciesTypeShortMap: {
    packageManager: string;
    dependencies: string;
    devDependencies: string;
    peerDependencies: string;
    optionalDependencies: string;
    resolutions: string;
    overrides: string;
    'pnpm.overrides': string;
    'pnpm-workspace': string;
};
interface RawDep {
    name: string;
    currentVersion: string;
    source: DepType;
    update: boolean;
    parents?: string[];
}
type DiffType = 'major' | 'minor' | 'patch' | 'error' | null;
interface PackageData {
    tags: Record<string, string>;
    versions: string[];
    time?: Record<string, string>;
    nodeSemver?: Record<string, string>;
    error?: Error | string;
    provenance?: Record<string, boolean | 'trustedPublisher'>;
}
interface ResolvedDepChange extends RawDep {
    latestVersionAvailable?: string;
    targetVersion: string;
    targetVersionTime?: string;
    currentVersionTime?: string;
    targetProvenance?: boolean | 'trustedPublisher';
    currentProvenance?: boolean | 'trustedPublisher';
    provenanceDowngraded: boolean;
    diff: DiffType;
    pkgData: PackageData;
    resolveError?: Error | string | null;
    aliasName?: string;
    nodeCompatibleVersion?: {
        semver: string;
        compatible: boolean;
    };
}
type LogLevel = 'debug' | 'info' | 'warn' | 'error' | 'silent';
interface CommonOptions {
    cwd?: string;
    recursive?: boolean;
    ignorePaths?: string | string[];
    ignoreOtherWorkspaces?: boolean;
    include?: string | string[];
    exclude?: string | string[];
    loglevel?: LogLevel;
    failOnOutdated?: boolean;
    silent?: boolean;
    /**
     * Fields in package.json to be checked
     * By default all fields will be checked
     */
    depFields?: DepFieldOptions;
    /**
     * Bypass cache
     */
    force?: boolean;
    /**
     * Include peerDependencies in the update process
     */
    peer?: boolean;
    /**
     * Override bumping mode for specific dependencies
     */
    packageMode?: {
        [name: string]: PackageMode;
    };
    /**
     * Custom addons
     *
     * @default builtin addons
     */
    addons?: Addon[];
}
type DepFieldOptions = Partial<Record<DepType, boolean>>;
interface CheckOptions extends CommonOptions {
    mode?: RangeMode;
    write?: boolean;
    all?: boolean;
    sort?: SortOption;
    interactive?: boolean;
    install?: boolean;
    update?: boolean;
    global?: boolean;
    /**
     * Number of concurrent requests
     *
     * @default 10
     */
    concurrency?: number;
    /**
     * Group dependencies by source, e.g. dependencies, devDependencies, etc.
     *
     * @default true
     */
    group?: boolean;
    /**
     * include locked dependencies & devDependencies
     * @default false
     * @description exclude the locked deps/devDeps by default
     */
    includeLocked?: boolean;
    /**
     * Show time difference between the current and the updated version
     *
     * @default true
     * @description hide the time difference
     */
    timediff?: boolean;
    /**
     * Show package compatibility with current node version
     *
     * @default true
     */
    nodecompat?: boolean;
}
interface BasePackageMeta {
    /**
     * Package name
     */
    name: string;
    /**
     * Is private package
     */
    private: boolean;
    /**
     * Package version
     */
    version: string;
    /**
     * Absolute filepath
     */
    filepath: string;
    /**
     * Relative filepath to the root project
     */
    relative: string;
    /**
     * Dependencies
     */
    deps: RawDep[];
    /**
     * Resolved dependencies
     */
    resolved: ResolvedDepChange[];
}
interface PackageJsonMeta extends BasePackageMeta {
    /**
     * Package type
     */
    type: 'package.json';
    /**
     * Raw package.json Object
     */
    raw: any;
}
interface GlobalPackageMeta extends BasePackageMeta {
    agent: Agent;
    type: 'global';
    raw: null;
}
interface PnpmWorkspaceMeta extends BasePackageMeta {
    type: 'pnpm-workspace.yaml';
    raw: any;
    context: PnpmWorkspaceYaml;
}
type PackageMeta = PackageJsonMeta | GlobalPackageMeta | PnpmWorkspaceMeta;
type DependencyFilter = (dep: RawDep) => boolean | Promise<boolean>;
type DependencyResolvedCallback = (packageName: string | null, depName: string, progress: number, total: number) => void;
interface InteractiveContext {
    /**
     * Whether the dependency is selected with cursor in the interactive list.
     */
    isSelected: (dep: RawDep) => boolean;
    /**
     * Whether the dependency is marked as checked in the interactive list.
     */
    isChecked: (dep: RawDep) => boolean;
}
interface Addon {
    postprocess?: (pkg: PackageMeta, options: CheckOptions) => void | Promise<void>;
    beforeWrite?: (pkg: PackageMeta, options: CheckOptions) => void | Promise<void>;
}

interface CheckEventCallbacks {
    afterPackagesLoaded?: (pkgs: PackageMeta[]) => void;
    beforePackageStart?: (pkg: PackageMeta) => void;
    afterPackageEnd?: (pkg: PackageMeta) => void;
    beforePackageWrite?: (pkg: PackageMeta) => boolean | Promise<boolean>;
    afterPackagesEnd?: (pkgs: PackageMeta[]) => void;
    afterPackageWrite?: (pkg: PackageMeta) => void;
    onDependencyResolved?: DependencyResolvedCallback;
}
declare function CheckPackages(options: CheckOptions, callbacks?: CheckEventCallbacks): Promise<{
    packages: PackageMeta[];
}>;

declare function parseDependencies(pkg: any, type: DepType, shouldUpdate: (name: string) => boolean): RawDep[];
declare function dumpDependencies(deps: ResolvedDepChange[], type: DepType): Record<string, any>;

declare function writePackage(pkg: PackageMeta, options: CommonOptions): Promise<void>;
declare function loadPackage(relative: string, options: CommonOptions, shouldUpdate: (name: string) => boolean): Promise<PackageMeta[]>;
declare function loadPackages(options: CommonOptions): Promise<PackageMeta[]>;

declare function resolveDependency(raw: RawDep, options: CheckOptions, filter?: DependencyFilter): Promise<ResolvedDepChange>;
declare function resolveDependencies(deps: RawDep[], options: CheckOptions, filter?: DependencyFilter, progressCallback?: (name: string, counter: number, total: number) => void): Promise<ResolvedDepChange[]>;
declare function resolvePackage(pkg: PackageMeta, options: CheckOptions, filter?: DependencyFilter, progress?: DependencyResolvedCallback): Promise<PackageMeta>;

declare function defineConfig(config: Partial<CheckOptions>): Partial<CheckOptions>;

export { CheckPackages, DependenciesTypeShortMap, defineConfig, dumpDependencies, loadPackage, loadPackages, parseDependencies, resolveDependencies, resolveDependency, resolvePackage, writePackage };
export type { Addon, CheckOptions, CommonOptions, DepFieldOptions, DepType, DependencyFilter, DependencyResolvedCallback, DiffType, GlobalPackageMeta, InteractiveContext, LogLevel, PackageData, PackageJsonMeta, PackageMeta, PackageMode, PnpmWorkspaceMeta, RangeMode, RawDep, ResolvedDepChange };
