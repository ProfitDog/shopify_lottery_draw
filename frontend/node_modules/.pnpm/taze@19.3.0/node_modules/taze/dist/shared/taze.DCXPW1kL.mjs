import require$$0 from 'module';

var lib$1;
var hasRequiredLib$1;

function requireLib$1 () {
	if (hasRequiredLib$1) return lib$1;
	hasRequiredLib$1 = 1;
	const META = Symbol('proc-log.meta');
	lib$1 = {
	  META: META,
	  output: {
	    LEVELS: [
	      'standard',
	      'error',
	      'buffer',
	      'flush',
	    ],
	    KEYS: {
	      standard: 'standard',
	      error: 'error',
	      buffer: 'buffer',
	      flush: 'flush',
	    },
	    standard: function (...args) {
	      return process.emit('output', 'standard', ...args)
	    },
	    error: function (...args) {
	      return process.emit('output', 'error', ...args)
	    },
	    buffer: function (...args) {
	      return process.emit('output', 'buffer', ...args)
	    },
	    flush: function (...args) {
	      return process.emit('output', 'flush', ...args)
	    },
	  },
	  log: {
	    LEVELS: [
	      'notice',
	      'error',
	      'warn',
	      'info',
	      'verbose',
	      'http',
	      'silly',
	      'timing',
	      'pause',
	      'resume',
	    ],
	    KEYS: {
	      notice: 'notice',
	      error: 'error',
	      warn: 'warn',
	      info: 'info',
	      verbose: 'verbose',
	      http: 'http',
	      silly: 'silly',
	      timing: 'timing',
	      pause: 'pause',
	      resume: 'resume',
	    },
	    error: function (...args) {
	      return process.emit('log', 'error', ...args)
	    },
	    notice: function (...args) {
	      return process.emit('log', 'notice', ...args)
	    },
	    warn: function (...args) {
	      return process.emit('log', 'warn', ...args)
	    },
	    info: function (...args) {
	      return process.emit('log', 'info', ...args)
	    },
	    verbose: function (...args) {
	      return process.emit('log', 'verbose', ...args)
	    },
	    http: function (...args) {
	      return process.emit('log', 'http', ...args)
	    },
	    silly: function (...args) {
	      return process.emit('log', 'silly', ...args)
	    },
	    timing: function (...args) {
	      return process.emit('log', 'timing', ...args)
	    },
	    pause: function () {
	      return process.emit('log', 'pause')
	    },
	    resume: function () {
	      return process.emit('log', 'resume')
	    },
	  },
	  time: {
	    LEVELS: [
	      'start',
	      'end',
	    ],
	    KEYS: {
	      start: 'start',
	      end: 'end',
	    },
	    start: function (name, fn) {
	      process.emit('time', 'start', name);
	      function end () {
	        return process.emit('time', 'end', name)
	      }
	      if (typeof fn === 'function') {
	        const res = fn();
	        if (res && res.finally) {
	          return res.finally(end)
	        }
	        end();
	        return res
	      }
	      return end
	    },
	    end: function (name) {
	      return process.emit('time', 'end', name)
	    },
	  },
	  input: {
	    LEVELS: [
	      'start',
	      'end',
	      'read',
	    ],
	    KEYS: {
	      start: 'start',
	      end: 'end',
	      read: 'read',
	    },
	    start: function (fn) {
	      process.emit('input', 'start');
	      function end () {
	        return process.emit('input', 'end')
	      }
	      if (typeof fn === 'function') {
	        const res = fn();
	        if (res && res.finally) {
	          return res.finally(end)
	        }
	        end();
	        return res
	      }
	      return end
	    },
	    end: function () {
	      return process.emit('input', 'end')
	    },
	    read: function (...args) {
	      let resolve, reject;
	      const promise = new Promise((_resolve, _reject) => {
	        resolve = _resolve;
	        reject = _reject;
	      });
	      process.emit('input', 'read', resolve, reject, ...args);
	      return promise
	    },
	  },
	};
	return lib$1;
}

var lib;
var hasRequiredLib;

function requireLib () {
	if (hasRequiredLib) return lib;
	hasRequiredLib = 1;
	const { builtinModules: builtins } = require$$0;

	var scopedPackagePattern = new RegExp('^(?:@([^/]+?)[/])?([^/]+?)$');
	var exclusionList = [
	  'node_modules',
	  'favicon.ico',
	];

	function validate (name) {
	  var warnings = [];
	  var errors = [];

	  if (name === null) {
	    errors.push('name cannot be null');
	    return done(warnings, errors)
	  }

	  if (name === undefined) {
	    errors.push('name cannot be undefined');
	    return done(warnings, errors)
	  }

	  if (typeof name !== 'string') {
	    errors.push('name must be a string');
	    return done(warnings, errors)
	  }

	  if (!name.length) {
	    errors.push('name length must be greater than zero');
	  }

	  if (name.startsWith('.')) {
	    errors.push('name cannot start with a period');
	  }

	  if (name.match(/^_/)) {
	    errors.push('name cannot start with an underscore');
	  }

	  if (name.trim() !== name) {
	    errors.push('name cannot contain leading or trailing spaces');
	  }

	  // No funny business
	  exclusionList.forEach(function (excludedName) {
	    if (name.toLowerCase() === excludedName) {
	      errors.push(excludedName + ' is not a valid package name');
	    }
	  });

	  // Generate warnings for stuff that used to be allowed

	  // core module names like http, events, util, etc
	  if (builtins.includes(name.toLowerCase())) {
	    warnings.push(name + ' is a core module name');
	  }

	  if (name.length > 214) {
	    warnings.push('name can no longer contain more than 214 characters');
	  }

	  // mIxeD CaSe nAMEs
	  if (name.toLowerCase() !== name) {
	    warnings.push('name can no longer contain capital letters');
	  }

	  if (/[~'!()*]/.test(name.split('/').slice(-1)[0])) {
	    warnings.push('name can no longer contain special characters ("~\'!()*")');
	  }

	  if (encodeURIComponent(name) !== name) {
	    // Maybe it's a scoped package name, like @user/package
	    var nameMatch = name.match(scopedPackagePattern);
	    if (nameMatch) {
	      var user = nameMatch[1];
	      var pkg = nameMatch[2];

	      if (pkg.startsWith('.')) {
	        errors.push('name cannot start with a period');
	      }

	      if (encodeURIComponent(user) === user && encodeURIComponent(pkg) === pkg) {
	        return done(warnings, errors)
	      }
	    }

	    errors.push('name can only contain URL-friendly characters');
	  }

	  return done(warnings, errors)
	}

	var done = function (warnings, errors) {
	  var result = {
	    validForNewPackages: errors.length === 0 && warnings.length === 0,
	    validForOldPackages: errors.length === 0,
	    warnings: warnings,
	    errors: errors,
	  };
	  if (!result.warnings.length) {
	    delete result.warnings;
	  }
	  if (!result.errors.length) {
	    delete result.errors;
	  }
	  return result
	};

	lib = validate;
	return lib;
}

export { requireLib as a, requireLib$1 as r };
