import process$1 from 'node:process';
import { cac } from 'cac';
import restoreCursor from 'restore-cursor';
import { detect, run, parseNi, parseNup, getCommand } from '@antfu/ni';
import { g as getDefaultExportFromCjs, e as getDiff, s as semverExports, f as DiffColorMap, h as DiffMap, D as DependenciesTypeShortMap, i as semver, u as updateTargetVersion, j as createControlledPromise, k as getVersionOfRange, m as getPrefixedVersion, n as notNullish, C as CheckPackages, o as builtinAddons, w as writePackage, c as resolvePackage, q as createDependenciesFilter, d as dumpDependencies, _ as _debug, t as DEFAULT_CHECK_OPTIONS, v as toArray, L as LOG_LEVELS, M as MODE_CHOICES } from './shared/taze.CWW-GbSg.mjs';
import require$$0 from 'readline';
import require$$0$1 from 'events';
import readline from 'node:readline';
import { exec } from 'tinyexec';
import { createConfigLoader } from 'unconfig';
import 'node:fs';
import 'find-up-simple';
import 'pathe';
import 'tinyglobby';
import 'node:fs/promises';
import 'pnpm-workspace-yaml';
import 'node:os';
import 'tty';
import 'util';
import 'os';
import 'ofetch';

const pkgJson = {version:"19.3.0"};

var prompts$2 = {};

var kleur;
var hasRequiredKleur;

function requireKleur () {
	if (hasRequiredKleur) return kleur;
	hasRequiredKleur = 1;

	let FORCE_COLOR, NODE_DISABLE_COLORS, NO_COLOR, TERM, isTTY=true;
	if (typeof process !== 'undefined') {
		({ FORCE_COLOR, NODE_DISABLE_COLORS, NO_COLOR, TERM } = process.env || {});
		isTTY = process.stdout && process.stdout.isTTY;
	}

	const $ = {
		enabled: !NODE_DISABLE_COLORS && NO_COLOR == null && TERM !== 'dumb' && (
			FORCE_COLOR != null && FORCE_COLOR !== '0' || isTTY
		),

		// modifiers
		reset: init(0, 0),
		bold: init(1, 22),
		dim: init(2, 22),
		italic: init(3, 23),
		underline: init(4, 24),
		inverse: init(7, 27),
		hidden: init(8, 28),
		strikethrough: init(9, 29),

		// colors
		black: init(30, 39),
		red: init(31, 39),
		green: init(32, 39),
		yellow: init(33, 39),
		blue: init(34, 39),
		magenta: init(35, 39),
		cyan: init(36, 39),
		white: init(37, 39),
		gray: init(90, 39),
		grey: init(90, 39),

		// background colors
		bgBlack: init(40, 49),
		bgRed: init(41, 49),
		bgGreen: init(42, 49),
		bgYellow: init(43, 49),
		bgBlue: init(44, 49),
		bgMagenta: init(45, 49),
		bgCyan: init(46, 49),
		bgWhite: init(47, 49)
	};

	function run(arr, str) {
		let i=0, tmp, beg='', end='';
		for (; i < arr.length; i++) {
			tmp = arr[i];
			beg += tmp.open;
			end += tmp.close;
			if (!!~str.indexOf(tmp.close)) {
				str = str.replace(tmp.rgx, tmp.close + tmp.open);
			}
		}
		return beg + str + end;
	}

	function chain(has, keys) {
		let ctx = { has, keys };

		ctx.reset = $.reset.bind(ctx);
		ctx.bold = $.bold.bind(ctx);
		ctx.dim = $.dim.bind(ctx);
		ctx.italic = $.italic.bind(ctx);
		ctx.underline = $.underline.bind(ctx);
		ctx.inverse = $.inverse.bind(ctx);
		ctx.hidden = $.hidden.bind(ctx);
		ctx.strikethrough = $.strikethrough.bind(ctx);

		ctx.black = $.black.bind(ctx);
		ctx.red = $.red.bind(ctx);
		ctx.green = $.green.bind(ctx);
		ctx.yellow = $.yellow.bind(ctx);
		ctx.blue = $.blue.bind(ctx);
		ctx.magenta = $.magenta.bind(ctx);
		ctx.cyan = $.cyan.bind(ctx);
		ctx.white = $.white.bind(ctx);
		ctx.gray = $.gray.bind(ctx);
		ctx.grey = $.grey.bind(ctx);

		ctx.bgBlack = $.bgBlack.bind(ctx);
		ctx.bgRed = $.bgRed.bind(ctx);
		ctx.bgGreen = $.bgGreen.bind(ctx);
		ctx.bgYellow = $.bgYellow.bind(ctx);
		ctx.bgBlue = $.bgBlue.bind(ctx);
		ctx.bgMagenta = $.bgMagenta.bind(ctx);
		ctx.bgCyan = $.bgCyan.bind(ctx);
		ctx.bgWhite = $.bgWhite.bind(ctx);

		return ctx;
	}

	function init(open, close) {
		let blk = {
			open: `\x1b[${open}m`,
			close: `\x1b[${close}m`,
			rgx: new RegExp(`\\x1b\\[${close}m`, 'g')
		};
		return function (txt) {
			if (this !== void 0 && this.has !== void 0) {
				!!~this.has.indexOf(open) || (this.has.push(open),this.keys.push(blk));
				return txt === void 0 ? this : $.enabled ? run(this.keys, txt+'') : txt+'';
			}
			return txt === void 0 ? chain([open], [blk]) : $.enabled ? run([blk], txt+'') : txt+'';
		};
	}

	kleur = $;
	return kleur;
}

var action;
var hasRequiredAction;

function requireAction () {
	if (hasRequiredAction) return action;
	hasRequiredAction = 1;

	action = (key, isSelect) => {
	  if (key.meta && key.name !== 'escape') return;

	  if (key.ctrl) {
	    if (key.name === 'a') return 'first';
	    if (key.name === 'c') return 'abort';
	    if (key.name === 'd') return 'abort';
	    if (key.name === 'e') return 'last';
	    if (key.name === 'g') return 'reset';
	    if (key.name === 'n') return 'down';
	    if (key.name === 'p') return 'up';
	    // avoid any non-ascii characters
	    return
	  }

	  if (isSelect) {
	    if (key.name === 'j') return 'down';
	    if (key.name === 'k') return 'up';
	  }

	  if (key.name === 'return') return 'submit';
	  if (key.name === 'enter') return 'submit'; // ctrl + J
	  if (key.name === 'backspace') return 'delete';
	  if (key.name === 'delete') return 'deleteForward';
	  if (key.name === 'abort') return 'abort';
	  if (key.name === 'escape') return 'exit';
	  // TODO: shift tab for prev
	  if (key.name === 'tab') return 'next';
	  if (key.name === 'pagedown') return 'nextPage';
	  if (key.name === 'pageup') return 'prevPage';
	  // TODO create home() in prompt types (e.g. TextPrompt)
	  if (key.name === 'home') return 'home';
	  // TODO create end() in prompt types (e.g. TextPrompt)
	  if (key.name === 'end') return 'end';

	  if (key.name === 'up') return 'up';
	  if (key.name === 'down') return 'down';
	  if (key.name === 'right') return 'right';
	  if (key.name === 'left') return 'left';

	  return false;
	};
	return action;
}

var strip;
var hasRequiredStrip;

function requireStrip () {
	if (hasRequiredStrip) return strip;
	hasRequiredStrip = 1;

	strip = str => {
	  const pattern = [
	    '[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)',
	    '(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PRZcf-ntqry=><~]))'
	  ].join('|');

	  const RGX = new RegExp(pattern, 'g');
	  return typeof str === 'string' ? str.replace(RGX, '') : str;
	};
	return strip;
}

var src;
var hasRequiredSrc;

function requireSrc () {
	if (hasRequiredSrc) return src;
	hasRequiredSrc = 1;

	const ESC = '\x1B';
	const CSI = `${ESC}[`;
	const beep = '\u0007';

	const cursor = {
	  to(x, y) {
	    if (!y) return `${CSI}${x + 1}G`;
	    return `${CSI}${y + 1};${x + 1}H`;
	  },
	  move(x, y) {
	    let ret = '';

	    if (x < 0) ret += `${CSI}${-x}D`;
	    else if (x > 0) ret += `${CSI}${x}C`;

	    if (y < 0) ret += `${CSI}${-y}A`;
	    else if (y > 0) ret += `${CSI}${y}B`;

	    return ret;
	  },
	  up: (count = 1) => `${CSI}${count}A`,
	  down: (count = 1) => `${CSI}${count}B`,
	  forward: (count = 1) => `${CSI}${count}C`,
	  backward: (count = 1) => `${CSI}${count}D`,
	  nextLine: (count = 1) => `${CSI}E`.repeat(count),
	  prevLine: (count = 1) => `${CSI}F`.repeat(count),
	  left: `${CSI}G`,
	  hide: `${CSI}?25l`,
	  show: `${CSI}?25h`,
	  save: `${ESC}7`,
	  restore: `${ESC}8`
	};

	const scroll = {
	  up: (count = 1) => `${CSI}S`.repeat(count),
	  down: (count = 1) => `${CSI}T`.repeat(count)
	};

	const erase = {
	  screen: `${CSI}2J`,
	  up: (count = 1) => `${CSI}1J`.repeat(count),
	  down: (count = 1) => `${CSI}J`.repeat(count),
	  line: `${CSI}2K`,
	  lineEnd: `${CSI}K`,
	  lineStart: `${CSI}1K`,
	  lines(count) {
	    let clear = '';
	    for (let i = 0; i < count; i++)
	      clear += this.line + (i < count - 1 ? cursor.up() : '');
	    if (count)
	      clear += cursor.left;
	    return clear;
	  }
	};

	src = { cursor, scroll, erase, beep };
	return src;
}

var clear;
var hasRequiredClear;

function requireClear () {
	if (hasRequiredClear) return clear;
	hasRequiredClear = 1;

	const strip = requireStrip();
	const { erase, cursor } = requireSrc();

	const width = str => [...strip(str)].length;

	/**
	 * @param {string} prompt
	 * @param {number} perLine
	 */
	clear = function(prompt, perLine) {
	  if (!perLine) return erase.line + cursor.to(0);

	  let rows = 0;
	  const lines = prompt.split(/\r?\n/);
	  for (let line of lines) {
	    rows += 1 + Math.floor(Math.max(width(line) - 1, 0) / perLine);
	  }

	  return erase.lines(rows);
	};
	return clear;
}

var figures_1;
var hasRequiredFigures;

function requireFigures () {
	if (hasRequiredFigures) return figures_1;
	hasRequiredFigures = 1;

	 const main = {
	  arrowUp: '↑',
	  arrowDown: '↓',
	  arrowLeft: '←',
	  arrowRight: '→',
	  radioOn: '◉',
	  radioOff: '◯',
	  tick: '✔',	
	  cross: '✖',	
	  ellipsis: '…',	
	  pointerSmall: '›',	
	  line: '─',	
	  pointer: '❯'	
	};	
	const win = {
	  arrowUp: main.arrowUp,
	  arrowDown: main.arrowDown,
	  arrowLeft: main.arrowLeft,
	  arrowRight: main.arrowRight,
	  radioOn: '(*)',
	  radioOff: '( )',	
	  tick: '√',	
	  cross: '×',	
	  ellipsis: '...',	
	  pointerSmall: '»',	
	  line: '─',	
	  pointer: '>'	
	};	
	const figures = process.platform === 'win32' ? win : main;	

	 figures_1 = figures;
	return figures_1;
}

var style;
var hasRequiredStyle;

function requireStyle () {
	if (hasRequiredStyle) return style;
	hasRequiredStyle = 1;

	const c = requireKleur();
	const figures = requireFigures();

	// rendering user input.
	const styles = Object.freeze({
	  password: { scale: 1, render: input => '*'.repeat(input.length) },
	  emoji: { scale: 2, render: input => '😃'.repeat(input.length) },
	  invisible: { scale: 0, render: input => '' },
	  default: { scale: 1, render: input => `${input}` }
	});
	const render = type => styles[type] || styles.default;

	// icon to signalize a prompt.
	const symbols = Object.freeze({
	  aborted: c.red(figures.cross),
	  done: c.green(figures.tick),
	  exited: c.yellow(figures.cross),
	  default: c.cyan('?')
	});

	const symbol = (done, aborted, exited) =>
	  aborted ? symbols.aborted : exited ? symbols.exited : done ? symbols.done : symbols.default;

	// between the question and the user's input.
	const delimiter = completing =>
	  c.gray(completing ? figures.ellipsis : figures.pointerSmall);

	const item = (expandable, expanded) =>
	  c.gray(expandable ? (expanded ? figures.pointerSmall : '+') : figures.line);

	style = {
	  styles,
	  render,
	  symbols,
	  symbol,
	  delimiter,
	  item
	};
	return style;
}

var lines;
var hasRequiredLines;

function requireLines () {
	if (hasRequiredLines) return lines;
	hasRequiredLines = 1;

	const strip = requireStrip();

	/**
	 * @param {string} msg
	 * @param {number} perLine
	 */
	lines = function (msg, perLine) {
	  let lines = String(strip(msg) || '').split(/\r?\n/);

	  if (!perLine) return lines.length;
	  return lines.map(l => Math.ceil(l.length / perLine))
	      .reduce((a, b) => a + b);
	};
	return lines;
}

var wrap;
var hasRequiredWrap;

function requireWrap () {
	if (hasRequiredWrap) return wrap;
	hasRequiredWrap = 1;

	/**
	 * @param {string} msg The message to wrap
	 * @param {object} opts
	 * @param {number|string} [opts.margin] Left margin
	 * @param {number} opts.width Maximum characters per line including the margin
	 */
	wrap = (msg, opts = {}) => {
	  const tab = Number.isSafeInteger(parseInt(opts.margin))
	    ? new Array(parseInt(opts.margin)).fill(' ').join('')
	    : (opts.margin || '');

	  const width = opts.width;

	  return (msg || '').split(/\r?\n/g)
	    .map(line => line
	      .split(/\s+/g)
	      .reduce((arr, w) => {
	        if (w.length + tab.length >= width || arr[arr.length - 1].length + w.length + 1 < width)
	          arr[arr.length - 1] += ` ${w}`;
	        else arr.push(`${tab}${w}`);
	        return arr;
	      }, [ tab ])
	      .join('\n'))
	    .join('\n');
	};
	return wrap;
}

var entriesToDisplay;
var hasRequiredEntriesToDisplay;

function requireEntriesToDisplay () {
	if (hasRequiredEntriesToDisplay) return entriesToDisplay;
	hasRequiredEntriesToDisplay = 1;

	/**
	 * Determine what entries should be displayed on the screen, based on the
	 * currently selected index and the maximum visible. Used in list-based
	 * prompts like `select` and `multiselect`.
	 *
	 * @param {number} cursor the currently selected entry
	 * @param {number} total the total entries available to display
	 * @param {number} [maxVisible] the number of entries that can be displayed
	 */
	entriesToDisplay = (cursor, total, maxVisible)  => {
	  maxVisible = maxVisible || total;

	  let startIndex = Math.min(total- maxVisible, cursor - Math.floor(maxVisible / 2));
	  if (startIndex < 0) startIndex = 0;

	  let endIndex = Math.min(startIndex + maxVisible, total);

	  return { startIndex, endIndex };
	};
	return entriesToDisplay;
}

var util;
var hasRequiredUtil;

function requireUtil () {
	if (hasRequiredUtil) return util;
	hasRequiredUtil = 1;

	util = {
	  action: requireAction(),
	  clear: requireClear(),
	  style: requireStyle(),
	  strip: requireStrip(),
	  figures: requireFigures(),
	  lines: requireLines(),
	  wrap: requireWrap(),
	  entriesToDisplay: requireEntriesToDisplay()
	};
	return util;
}

var prompt;
var hasRequiredPrompt;

function requirePrompt () {
	if (hasRequiredPrompt) return prompt;
	hasRequiredPrompt = 1;

	const readline = require$$0;
	const { action } = requireUtil();
	const EventEmitter = require$$0$1;
	const { beep, cursor } = requireSrc();
	const color = requireKleur();

	/**
	 * Base prompt skeleton
	 * @param {Stream} [opts.stdin] The Readable stream to listen to
	 * @param {Stream} [opts.stdout] The Writable stream to write readline data to
	 */
	class Prompt extends EventEmitter {
	  constructor(opts={}) {
	    super();

	    this.firstRender = true;
	    this.in = opts.stdin || process.stdin;
	    this.out = opts.stdout || process.stdout;
	    this.onRender = (opts.onRender || (() => void 0)).bind(this);
	    const rl = readline.createInterface({ input:this.in, escapeCodeTimeout:50 });
	    readline.emitKeypressEvents(this.in, rl);

	    if (this.in.isTTY) this.in.setRawMode(true);
	    const isSelect = [ 'SelectPrompt', 'MultiselectPrompt' ].indexOf(this.constructor.name) > -1;
	    const keypress = (str, key) => {
	      let a = action(key, isSelect);
	      if (a === false) {
	        this._ && this._(str, key);
	      } else if (typeof this[a] === 'function') {
	        this[a](key);
	      } else {
	        this.bell();
	      }
	    };

	    this.close = () => {
	      this.out.write(cursor.show);
	      this.in.removeListener('keypress', keypress);
	      if (this.in.isTTY) this.in.setRawMode(false);
	      rl.close();
	      this.emit(this.aborted ? 'abort' : this.exited ? 'exit' : 'submit', this.value);
	      this.closed = true;
	    };

	    this.in.on('keypress', keypress);
	  }

	  fire() {
	    this.emit('state', {
	      value: this.value,
	      aborted: !!this.aborted,
	      exited: !!this.exited
	    });
	  }

	  bell() {
	    this.out.write(beep);
	  }

	  render() {
	    this.onRender(color);
	    if (this.firstRender) this.firstRender = false;
	  }
	}

	prompt = Prompt;
	return prompt;
}

var text;
var hasRequiredText;

function requireText () {
	if (hasRequiredText) return text;
	hasRequiredText = 1;
	const color = requireKleur();
	const Prompt = requirePrompt();
	const { erase, cursor } = requireSrc();
	const { style, clear, lines, figures } = requireUtil();

	/**
	 * TextPrompt Base Element
	 * @param {Object} opts Options
	 * @param {String} opts.message Message
	 * @param {String} [opts.style='default'] Render style
	 * @param {String} [opts.initial] Default value
	 * @param {Function} [opts.validate] Validate function
	 * @param {Stream} [opts.stdin] The Readable stream to listen to
	 * @param {Stream} [opts.stdout] The Writable stream to write readline data to
	 * @param {String} [opts.error] The invalid error label
	 */
	class TextPrompt extends Prompt {
	  constructor(opts={}) {
	    super(opts);
	    this.transform = style.render(opts.style);
	    this.scale = this.transform.scale;
	    this.msg = opts.message;
	    this.initial = opts.initial || ``;
	    this.validator = opts.validate || (() => true);
	    this.value = ``;
	    this.errorMsg = opts.error || `Please Enter A Valid Value`;
	    this.cursor = Number(!!this.initial);
	    this.cursorOffset = 0;
	    this.clear = clear(``, this.out.columns);
	    this.render();
	  }

	  set value(v) {
	    if (!v && this.initial) {
	      this.placeholder = true;
	      this.rendered = color.gray(this.transform.render(this.initial));
	    } else {
	      this.placeholder = false;
	      this.rendered = this.transform.render(v);
	    }
	    this._value = v;
	    this.fire();
	  }

	  get value() {
	    return this._value;
	  }

	  reset() {
	    this.value = ``;
	    this.cursor = Number(!!this.initial);
	    this.cursorOffset = 0;
	    this.fire();
	    this.render();
	  }

	  exit() {
	    this.abort();
	  }

	  abort() {
	    this.value = this.value || this.initial;
	    this.done = this.aborted = true;
	    this.error = false;
	    this.red = false;
	    this.fire();
	    this.render();
	    this.out.write('\n');
	    this.close();
	  }

	  async validate() {
	    let valid = await this.validator(this.value);
	    if (typeof valid === `string`) {
	      this.errorMsg = valid;
	      valid = false;
	    }
	    this.error = !valid;
	  }

	  async submit() {
	    this.value = this.value || this.initial;
	    this.cursorOffset = 0;
	    this.cursor = this.rendered.length;
	    await this.validate();
	    if (this.error) {
	      this.red = true;
	      this.fire();
	      this.render();
	      return;
	    }
	    this.done = true;
	    this.aborted = false;
	    this.fire();
	    this.render();
	    this.out.write('\n');
	    this.close();
	  }

	  next() {
	    if (!this.placeholder) return this.bell();
	    this.value = this.initial;
	    this.cursor = this.rendered.length;
	    this.fire();
	    this.render();
	  }

	  moveCursor(n) {
	    if (this.placeholder) return;
	    this.cursor = this.cursor+n;
	    this.cursorOffset += n;
	  }

	  _(c, key) {
	    let s1 = this.value.slice(0, this.cursor);
	    let s2 = this.value.slice(this.cursor);
	    this.value = `${s1}${c}${s2}`;
	    this.red = false;
	    this.cursor = this.placeholder ? 0 : s1.length+1;
	    this.render();
	  }

	  delete() {
	    if (this.isCursorAtStart()) return this.bell();
	    let s1 = this.value.slice(0, this.cursor-1);
	    let s2 = this.value.slice(this.cursor);
	    this.value = `${s1}${s2}`;
	    this.red = false;
	    if (this.isCursorAtStart()) {
	      this.cursorOffset = 0;
	    } else {
	      this.cursorOffset++;
	      this.moveCursor(-1);
	    }
	    this.render();
	  }

	  deleteForward() {
	    if(this.cursor*this.scale >= this.rendered.length || this.placeholder) return this.bell();
	    let s1 = this.value.slice(0, this.cursor);
	    let s2 = this.value.slice(this.cursor+1);
	    this.value = `${s1}${s2}`;
	    this.red = false;
	    if (this.isCursorAtEnd()) {
	      this.cursorOffset = 0;
	    } else {
	      this.cursorOffset++;
	    }
	    this.render();
	  }

	  first() {
	    this.cursor = 0;
	    this.render();
	  }

	  last() {
	    this.cursor = this.value.length;
	    this.render();
	  }

	  left() {
	    if (this.cursor <= 0 || this.placeholder) return this.bell();
	    this.moveCursor(-1);
	    this.render();
	  }

	  right() {
	    if (this.cursor*this.scale >= this.rendered.length || this.placeholder) return this.bell();
	    this.moveCursor(1);
	    this.render();
	  }

	  isCursorAtStart() {
	    return this.cursor === 0 || (this.placeholder && this.cursor === 1);
	  }

	  isCursorAtEnd() {
	    return this.cursor === this.rendered.length || (this.placeholder && this.cursor === this.rendered.length + 1)
	  }

	  render() {
	    if (this.closed) return;
	    if (!this.firstRender) {
	      if (this.outputError)
	        this.out.write(cursor.down(lines(this.outputError, this.out.columns) - 1) + clear(this.outputError, this.out.columns));
	      this.out.write(clear(this.outputText, this.out.columns));
	    }
	    super.render();
	    this.outputError = '';

	    this.outputText = [
	      style.symbol(this.done, this.aborted),
	      color.bold(this.msg),
	      style.delimiter(this.done),
	      this.red ? color.red(this.rendered) : this.rendered
	    ].join(` `);

	    if (this.error) {
	      this.outputError += this.errorMsg.split(`\n`)
	          .reduce((a, l, i) => a + `\n${i ? ' ' : figures.pointerSmall} ${color.red().italic(l)}`, ``);
	    }

	    this.out.write(erase.line + cursor.to(0) + this.outputText + cursor.save + this.outputError + cursor.restore + cursor.move(this.cursorOffset, 0));
	  }
	}

	text = TextPrompt;
	return text;
}

var select;
var hasRequiredSelect;

function requireSelect () {
	if (hasRequiredSelect) return select;
	hasRequiredSelect = 1;

	const color = requireKleur();
	const Prompt = requirePrompt();
	const { style, clear, figures, wrap, entriesToDisplay } = requireUtil();
	const { cursor } = requireSrc();

	/**
	 * SelectPrompt Base Element
	 * @param {Object} opts Options
	 * @param {String} opts.message Message
	 * @param {Array} opts.choices Array of choice objects
	 * @param {String} [opts.hint] Hint to display
	 * @param {Number} [opts.initial] Index of default value
	 * @param {Stream} [opts.stdin] The Readable stream to listen to
	 * @param {Stream} [opts.stdout] The Writable stream to write readline data to
	 * @param {Number} [opts.optionsPerPage=10] Max options to display at once
	 */
	class SelectPrompt extends Prompt {
	  constructor(opts={}) {
	    super(opts);
	    this.msg = opts.message;
	    this.hint = opts.hint || '- Use arrow-keys. Return to submit.';
	    this.warn = opts.warn || '- This option is disabled';
	    this.cursor = opts.initial || 0;
	    this.choices = opts.choices.map((ch, idx) => {
	      if (typeof ch === 'string')
	        ch = {title: ch, value: idx};
	      return {
	        title: ch && (ch.title || ch.value || ch),
	        value: ch && (ch.value === undefined ? idx : ch.value),
	        description: ch && ch.description,
	        selected: ch && ch.selected,
	        disabled: ch && ch.disabled
	      };
	    });
	    this.optionsPerPage = opts.optionsPerPage || 10;
	    this.value = (this.choices[this.cursor] || {}).value;
	    this.clear = clear('', this.out.columns);
	    this.render();
	  }

	  moveCursor(n) {
	    this.cursor = n;
	    this.value = this.choices[n].value;
	    this.fire();
	  }

	  reset() {
	    this.moveCursor(0);
	    this.fire();
	    this.render();
	  }

	  exit() {
	    this.abort();
	  }

	  abort() {
	    this.done = this.aborted = true;
	    this.fire();
	    this.render();
	    this.out.write('\n');
	    this.close();
	  }

	  submit() {
	    if (!this.selection.disabled) {
	      this.done = true;
	      this.aborted = false;
	      this.fire();
	      this.render();
	      this.out.write('\n');
	      this.close();
	    } else
	      this.bell();
	  }

	  first() {
	    this.moveCursor(0);
	    this.render();
	  }

	  last() {
	    this.moveCursor(this.choices.length - 1);
	    this.render();
	  }

	  up() {
	    if (this.cursor === 0) {
	      this.moveCursor(this.choices.length - 1);
	    } else {
	      this.moveCursor(this.cursor - 1);
	    }
	    this.render();
	  }

	  down() {
	    if (this.cursor === this.choices.length - 1) {
	      this.moveCursor(0);
	    } else {
	      this.moveCursor(this.cursor + 1);
	    }
	    this.render();
	  }

	  next() {
	    this.moveCursor((this.cursor + 1) % this.choices.length);
	    this.render();
	  }

	  _(c, key) {
	    if (c === ' ') return this.submit();
	  }

	  get selection() {
	    return this.choices[this.cursor];
	  }

	  render() {
	    if (this.closed) return;
	    if (this.firstRender) this.out.write(cursor.hide);
	    else this.out.write(clear(this.outputText, this.out.columns));
	    super.render();

	    let { startIndex, endIndex } = entriesToDisplay(this.cursor, this.choices.length, this.optionsPerPage);

	    // Print prompt
	    this.outputText = [
	      style.symbol(this.done, this.aborted),
	      color.bold(this.msg),
	      style.delimiter(false),
	      this.done ? this.selection.title : this.selection.disabled
	          ? color.yellow(this.warn) : color.gray(this.hint)
	    ].join(' ');

	    // Print choices
	    if (!this.done) {
	      this.outputText += '\n';
	      for (let i = startIndex; i < endIndex; i++) {
	        let title, prefix, desc = '', v = this.choices[i];

	        // Determine whether to display "more choices" indicators
	        if (i === startIndex && startIndex > 0) {
	          prefix = figures.arrowUp;
	        } else if (i === endIndex - 1 && endIndex < this.choices.length) {
	          prefix = figures.arrowDown;
	        } else {
	          prefix = ' ';
	        }

	        if (v.disabled) {
	          title = this.cursor === i ? color.gray().underline(v.title) : color.strikethrough().gray(v.title);
	          prefix = (this.cursor === i ? color.bold().gray(figures.pointer) + ' ' : '  ') + prefix;
	        } else {
	          title = this.cursor === i ? color.cyan().underline(v.title) : v.title;
	          prefix = (this.cursor === i ? color.cyan(figures.pointer) + ' ' : '  ') + prefix;
	          if (v.description && this.cursor === i) {
	            desc = ` - ${v.description}`;
	            if (prefix.length + title.length + desc.length >= this.out.columns
	                || v.description.split(/\r?\n/).length > 1) {
	              desc = '\n' + wrap(v.description, { margin: 3, width: this.out.columns });
	            }
	          }
	        }

	        this.outputText += `${prefix} ${title}${color.gray(desc)}\n`;
	      }
	    }

	    this.out.write(this.outputText);
	  }
	}

	select = SelectPrompt;
	return select;
}

var toggle;
var hasRequiredToggle;

function requireToggle () {
	if (hasRequiredToggle) return toggle;
	hasRequiredToggle = 1;
	const color = requireKleur();
	const Prompt = requirePrompt();
	const { style, clear } = requireUtil();
	const { cursor, erase } = requireSrc();

	/**
	 * TogglePrompt Base Element
	 * @param {Object} opts Options
	 * @param {String} opts.message Message
	 * @param {Boolean} [opts.initial=false] Default value
	 * @param {String} [opts.active='no'] Active label
	 * @param {String} [opts.inactive='off'] Inactive label
	 * @param {Stream} [opts.stdin] The Readable stream to listen to
	 * @param {Stream} [opts.stdout] The Writable stream to write readline data to
	 */
	class TogglePrompt extends Prompt {
	  constructor(opts={}) {
	    super(opts);
	    this.msg = opts.message;
	    this.value = !!opts.initial;
	    this.active = opts.active || 'on';
	    this.inactive = opts.inactive || 'off';
	    this.initialValue = this.value;
	    this.render();
	  }

	  reset() {
	    this.value = this.initialValue;
	    this.fire();
	    this.render();
	  }

	  exit() {
	    this.abort();
	  }

	  abort() {
	    this.done = this.aborted = true;
	    this.fire();
	    this.render();
	    this.out.write('\n');
	    this.close();
	  }

	  submit() {
	    this.done = true;
	    this.aborted = false;
	    this.fire();
	    this.render();
	    this.out.write('\n');
	    this.close();
	  }

	  deactivate() {
	    if (this.value === false) return this.bell();
	    this.value = false;
	    this.render();
	  }

	  activate() {
	    if (this.value === true) return this.bell();
	    this.value = true;
	    this.render();
	  }

	  delete() {
	    this.deactivate();
	  }
	  left() {
	    this.deactivate();
	  }
	  right() {
	    this.activate();
	  }
	  down() {
	    this.deactivate();
	  }
	  up() {
	    this.activate();
	  }

	  next() {
	    this.value = !this.value;
	    this.fire();
	    this.render();
	  }

	  _(c, key) {
	    if (c === ' ') {
	      this.value = !this.value;
	    } else if (c === '1') {
	      this.value = true;
	    } else if (c === '0') {
	      this.value = false;
	    } else return this.bell();
	    this.render();
	  }

	  render() {
	    if (this.closed) return;
	    if (this.firstRender) this.out.write(cursor.hide);
	    else this.out.write(clear(this.outputText, this.out.columns));
	    super.render();

	    this.outputText = [
	      style.symbol(this.done, this.aborted),
	      color.bold(this.msg),
	      style.delimiter(this.done),
	      this.value ? this.inactive : color.cyan().underline(this.inactive),
	      color.gray('/'),
	      this.value ? color.cyan().underline(this.active) : this.active
	    ].join(' ');

	    this.out.write(erase.line + cursor.to(0) + this.outputText);
	  }
	}

	toggle = TogglePrompt;
	return toggle;
}

var datepart;
var hasRequiredDatepart;

function requireDatepart () {
	if (hasRequiredDatepart) return datepart;
	hasRequiredDatepart = 1;

	class DatePart {
	  constructor({token, date, parts, locales}) {
	    this.token = token;
	    this.date = date || new Date();
	    this.parts = parts || [this];
	    this.locales = locales || {};
	  }

	  up() {}

	  down() {}

	  next() {
	    const currentIdx = this.parts.indexOf(this);
	    return this.parts.find((part, idx) => idx > currentIdx && part instanceof DatePart);
	  }

	  setTo(val) {}

	  prev() {
	    let parts = [].concat(this.parts).reverse();
	    const currentIdx = parts.indexOf(this);
	    return parts.find((part, idx) => idx > currentIdx && part instanceof DatePart);
	  }

	  toString() {
	    return String(this.date);
	  }
	}

	datepart = DatePart;
	return datepart;
}

var meridiem;
var hasRequiredMeridiem;

function requireMeridiem () {
	if (hasRequiredMeridiem) return meridiem;
	hasRequiredMeridiem = 1;

	const DatePart = requireDatepart();

	class Meridiem extends DatePart {
	  constructor(opts={}) {
	    super(opts);
	  }

	  up() {
	    this.date.setHours((this.date.getHours() + 12) % 24);
	  }

	  down() {
	    this.up();
	  }

	  toString() {
	    let meridiem = this.date.getHours() > 12 ? 'pm' : 'am';
	    return /\A/.test(this.token) ? meridiem.toUpperCase() : meridiem;
	  }
	}

	meridiem = Meridiem;
	return meridiem;
}

var day;
var hasRequiredDay;

function requireDay () {
	if (hasRequiredDay) return day;
	hasRequiredDay = 1;

	const DatePart = requireDatepart();

	const pos = n => {
	  n = n % 10;
	  return n === 1 ? 'st'
	       : n === 2 ? 'nd'
	       : n === 3 ? 'rd'
	       : 'th';
	};

	class Day extends DatePart {
	  constructor(opts={}) {
	    super(opts);
	  }

	  up() {
	    this.date.setDate(this.date.getDate() + 1);
	  }

	  down() {
	    this.date.setDate(this.date.getDate() - 1);
	  }

	  setTo(val) {
	    this.date.setDate(parseInt(val.substr(-2)));
	  }

	  toString() {
	    let date = this.date.getDate();
	    let day = this.date.getDay();
	    return this.token === 'DD' ? String(date).padStart(2, '0')
	         : this.token === 'Do' ? date + pos(date)
	         : this.token === 'd' ? day + 1
	         : this.token === 'ddd' ? this.locales.weekdaysShort[day]
	         : this.token === 'dddd' ? this.locales.weekdays[day]
	         : date;
	  }
	}

	day = Day;
	return day;
}

var hours;
var hasRequiredHours;

function requireHours () {
	if (hasRequiredHours) return hours;
	hasRequiredHours = 1;

	const DatePart = requireDatepart();

	class Hours extends DatePart {
	  constructor(opts={}) {
	    super(opts);
	  }

	  up() {
	    this.date.setHours(this.date.getHours() + 1);
	  }

	  down() {
	    this.date.setHours(this.date.getHours() - 1);
	  }

	  setTo(val) {
	    this.date.setHours(parseInt(val.substr(-2)));
	  }

	  toString() {
	    let hours = this.date.getHours();
	    if (/h/.test(this.token))
	      hours = (hours % 12) || 12;
	    return this.token.length > 1 ? String(hours).padStart(2, '0') : hours;
	  }
	}

	hours = Hours;
	return hours;
}

var milliseconds;
var hasRequiredMilliseconds;

function requireMilliseconds () {
	if (hasRequiredMilliseconds) return milliseconds;
	hasRequiredMilliseconds = 1;

	const DatePart = requireDatepart();

	class Milliseconds extends DatePart {
	  constructor(opts={}) {
	    super(opts);
	  }

	  up() {
	    this.date.setMilliseconds(this.date.getMilliseconds() + 1);
	  }

	  down() {
	    this.date.setMilliseconds(this.date.getMilliseconds() - 1);
	  }

	  setTo(val) {
	    this.date.setMilliseconds(parseInt(val.substr(-(this.token.length))));
	  }

	  toString() {
	    return String(this.date.getMilliseconds()).padStart(4, '0')
	                                              .substr(0, this.token.length);
	  }
	}

	milliseconds = Milliseconds;
	return milliseconds;
}

var minutes;
var hasRequiredMinutes;

function requireMinutes () {
	if (hasRequiredMinutes) return minutes;
	hasRequiredMinutes = 1;

	const DatePart = requireDatepart();

	class Minutes extends DatePart {
	  constructor(opts={}) {
	    super(opts);
	  }

	  up() {
	    this.date.setMinutes(this.date.getMinutes() + 1);
	  }

	  down() {
	    this.date.setMinutes(this.date.getMinutes() - 1);
	  }

	  setTo(val) {
	    this.date.setMinutes(parseInt(val.substr(-2)));
	  }

	  toString() {
	    let m = this.date.getMinutes();
	    return this.token.length > 1 ? String(m).padStart(2, '0') : m;
	  }
	}

	minutes = Minutes;
	return minutes;
}

var month;
var hasRequiredMonth;

function requireMonth () {
	if (hasRequiredMonth) return month;
	hasRequiredMonth = 1;

	const DatePart = requireDatepart();

	class Month extends DatePart {
	  constructor(opts={}) {
	    super(opts);
	  }

	  up() {
	    this.date.setMonth(this.date.getMonth() + 1);
	  }

	  down() {
	    this.date.setMonth(this.date.getMonth() - 1);
	  }

	  setTo(val) {
	    val = parseInt(val.substr(-2)) - 1;
	    this.date.setMonth(val < 0 ? 0 : val);
	  }

	  toString() {
	    let month = this.date.getMonth();
	    let tl = this.token.length;
	    return tl === 2 ? String(month + 1).padStart(2, '0')
	           : tl === 3 ? this.locales.monthsShort[month]
	             : tl === 4 ? this.locales.months[month]
	               : String(month + 1);
	  }
	}

	month = Month;
	return month;
}

var seconds;
var hasRequiredSeconds;

function requireSeconds () {
	if (hasRequiredSeconds) return seconds;
	hasRequiredSeconds = 1;

	const DatePart = requireDatepart();

	class Seconds extends DatePart {
	  constructor(opts={}) {
	    super(opts);
	  }

	  up() {
	    this.date.setSeconds(this.date.getSeconds() + 1);
	  }

	  down() {
	    this.date.setSeconds(this.date.getSeconds() - 1);
	  }

	  setTo(val) {
	    this.date.setSeconds(parseInt(val.substr(-2)));
	  }

	  toString() {
	    let s = this.date.getSeconds();
	    return this.token.length > 1 ? String(s).padStart(2, '0') : s;
	  }
	}

	seconds = Seconds;
	return seconds;
}

var year;
var hasRequiredYear;

function requireYear () {
	if (hasRequiredYear) return year;
	hasRequiredYear = 1;

	const DatePart = requireDatepart();

	class Year extends DatePart {
	  constructor(opts={}) {
	    super(opts);
	  }

	  up() {
	    this.date.setFullYear(this.date.getFullYear() + 1);
	  }

	  down() {
	    this.date.setFullYear(this.date.getFullYear() - 1);
	  }

	  setTo(val) {
	    this.date.setFullYear(val.substr(-4));
	  }

	  toString() {
	    let year = String(this.date.getFullYear()).padStart(4, '0');
	    return this.token.length === 2 ? year.substr(-2) : year;
	  }
	}

	year = Year;
	return year;
}

var dateparts;
var hasRequiredDateparts;

function requireDateparts () {
	if (hasRequiredDateparts) return dateparts;
	hasRequiredDateparts = 1;

	dateparts = {
	  DatePart: requireDatepart(),
	  Meridiem: requireMeridiem(),
	  Day: requireDay(),
	  Hours: requireHours(),
	  Milliseconds: requireMilliseconds(),
	  Minutes: requireMinutes(),
	  Month: requireMonth(),
	  Seconds: requireSeconds(),
	  Year: requireYear(),
	};
	return dateparts;
}

var date;
var hasRequiredDate;

function requireDate () {
	if (hasRequiredDate) return date;
	hasRequiredDate = 1;

	const color = requireKleur();
	const Prompt = requirePrompt();
	const { style, clear, figures } = requireUtil();
	const { erase, cursor } = requireSrc();
	const { DatePart, Meridiem, Day, Hours, Milliseconds, Minutes, Month, Seconds, Year } = requireDateparts();

	const regex = /\\(.)|"((?:\\["\\]|[^"])+)"|(D[Do]?|d{3,4}|d)|(M{1,4})|(YY(?:YY)?)|([aA])|([Hh]{1,2})|(m{1,2})|(s{1,2})|(S{1,4})|./g;
	const regexGroups = {
	  1: ({token}) => token.replace(/\\(.)/g, '$1'),
	  2: (opts) => new Day(opts), // Day // TODO
	  3: (opts) => new Month(opts), // Month
	  4: (opts) => new Year(opts), // Year
	  5: (opts) => new Meridiem(opts), // AM/PM // TODO (special)
	  6: (opts) => new Hours(opts), // Hours
	  7: (opts) => new Minutes(opts), // Minutes
	  8: (opts) => new Seconds(opts), // Seconds
	  9: (opts) => new Milliseconds(opts), // Fractional seconds
	};

	const dfltLocales = {
	  months: 'January,February,March,April,May,June,July,August,September,October,November,December'.split(','),
	  monthsShort: 'Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec'.split(','),
	  weekdays: 'Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday'.split(','),
	  weekdaysShort: 'Sun,Mon,Tue,Wed,Thu,Fri,Sat'.split(',')
	};


	/**
	 * DatePrompt Base Element
	 * @param {Object} opts Options
	 * @param {String} opts.message Message
	 * @param {Number} [opts.initial] Index of default value
	 * @param {String} [opts.mask] The format mask
	 * @param {object} [opts.locales] The date locales
	 * @param {String} [opts.error] The error message shown on invalid value
	 * @param {Function} [opts.validate] Function to validate the submitted value
	 * @param {Stream} [opts.stdin] The Readable stream to listen to
	 * @param {Stream} [opts.stdout] The Writable stream to write readline data to
	 */
	class DatePrompt extends Prompt {
	  constructor(opts={}) {
	    super(opts);
	    this.msg = opts.message;
	    this.cursor = 0;
	    this.typed = '';
	    this.locales = Object.assign(dfltLocales, opts.locales);
	    this._date = opts.initial || new Date();
	    this.errorMsg = opts.error || 'Please Enter A Valid Value';
	    this.validator = opts.validate || (() => true);
	    this.mask = opts.mask || 'YYYY-MM-DD HH:mm:ss';
	    this.clear = clear('', this.out.columns);
	    this.render();
	  }

	  get value() {
	    return this.date
	  }

	  get date() {
	    return this._date;
	  }

	  set date(date) {
	    if (date) this._date.setTime(date.getTime());
	  }

	  set mask(mask) {
	    let result;
	    this.parts = [];
	    while(result = regex.exec(mask)) {
	      let match = result.shift();
	      let idx = result.findIndex(gr => gr != null);
	      this.parts.push(idx in regexGroups
	        ? regexGroups[idx]({ token: result[idx] || match, date: this.date, parts: this.parts, locales: this.locales })
	        : result[idx] || match);
	    }

	    let parts = this.parts.reduce((arr, i) => {
	      if (typeof i === 'string' && typeof arr[arr.length - 1] === 'string')
	        arr[arr.length - 1] += i;
	      else arr.push(i);
	      return arr;
	    }, []);

	    this.parts.splice(0);
	    this.parts.push(...parts);
	    this.reset();
	  }

	  moveCursor(n) {
	    this.typed = '';
	    this.cursor = n;
	    this.fire();
	  }

	  reset() {
	    this.moveCursor(this.parts.findIndex(p => p instanceof DatePart));
	    this.fire();
	    this.render();
	  }

	  exit() {
	    this.abort();
	  }

	  abort() {
	    this.done = this.aborted = true;
	    this.error = false;
	    this.fire();
	    this.render();
	    this.out.write('\n');
	    this.close();
	  }

	  async validate() {
	    let valid = await this.validator(this.value);
	    if (typeof valid === 'string') {
	      this.errorMsg = valid;
	      valid = false;
	    }
	    this.error = !valid;
	  }

	  async submit() {
	    await this.validate();
	    if (this.error) {
	      this.color = 'red';
	      this.fire();
	      this.render();
	      return;
	    }
	    this.done = true;
	    this.aborted = false;
	    this.fire();
	    this.render();
	    this.out.write('\n');
	    this.close();
	  }

	  up() {
	    this.typed = '';
	    this.parts[this.cursor].up();
	    this.render();
	  }

	  down() {
	    this.typed = '';
	    this.parts[this.cursor].down();
	    this.render();
	  }

	  left() {
	    let prev = this.parts[this.cursor].prev();
	    if (prev == null) return this.bell();
	    this.moveCursor(this.parts.indexOf(prev));
	    this.render();
	  }

	  right() {
	    let next = this.parts[this.cursor].next();
	    if (next == null) return this.bell();
	    this.moveCursor(this.parts.indexOf(next));
	    this.render();
	  }

	  next() {
	    let next = this.parts[this.cursor].next();
	    this.moveCursor(next
	      ? this.parts.indexOf(next)
	      : this.parts.findIndex((part) => part instanceof DatePart));
	    this.render();
	  }

	  _(c) {
	    if (/\d/.test(c)) {
	      this.typed += c;
	      this.parts[this.cursor].setTo(this.typed);
	      this.render();
	    }
	  }

	  render() {
	    if (this.closed) return;
	    if (this.firstRender) this.out.write(cursor.hide);
	    else this.out.write(clear(this.outputText, this.out.columns));
	    super.render();

	    // Print prompt
	    this.outputText = [
	      style.symbol(this.done, this.aborted),
	      color.bold(this.msg),
	      style.delimiter(false),
	      this.parts.reduce((arr, p, idx) => arr.concat(idx === this.cursor && !this.done ? color.cyan().underline(p.toString()) : p), [])
	          .join('')
	    ].join(' ');

	    // Print error
	    if (this.error) {
	      this.outputText += this.errorMsg.split('\n').reduce(
	          (a, l, i) => a + `\n${i ? ` ` : figures.pointerSmall} ${color.red().italic(l)}`, ``);
	    }

	    this.out.write(erase.line + cursor.to(0) + this.outputText);
	  }
	}

	date = DatePrompt;
	return date;
}

var number;
var hasRequiredNumber;

function requireNumber () {
	if (hasRequiredNumber) return number;
	hasRequiredNumber = 1;
	const color = requireKleur();
	const Prompt = requirePrompt();
	const { cursor, erase } = requireSrc();
	const { style, figures, clear, lines } = requireUtil();

	const isNumber = /[0-9]/;
	const isDef = any => any !== undefined;
	const round = (number, precision) => {
	  let factor = Math.pow(10, precision);
	  return Math.round(number * factor) / factor;
	};

	/**
	 * NumberPrompt Base Element
	 * @param {Object} opts Options
	 * @param {String} opts.message Message
	 * @param {String} [opts.style='default'] Render style
	 * @param {Number} [opts.initial] Default value
	 * @param {Number} [opts.max=+Infinity] Max value
	 * @param {Number} [opts.min=-Infinity] Min value
	 * @param {Boolean} [opts.float=false] Parse input as floats
	 * @param {Number} [opts.round=2] Round floats to x decimals
	 * @param {Number} [opts.increment=1] Number to increment by when using arrow-keys
	 * @param {Function} [opts.validate] Validate function
	 * @param {Stream} [opts.stdin] The Readable stream to listen to
	 * @param {Stream} [opts.stdout] The Writable stream to write readline data to
	 * @param {String} [opts.error] The invalid error label
	 */
	class NumberPrompt extends Prompt {
	  constructor(opts={}) {
	    super(opts);
	    this.transform = style.render(opts.style);
	    this.msg = opts.message;
	    this.initial = isDef(opts.initial) ? opts.initial : '';
	    this.float = !!opts.float;
	    this.round = opts.round || 2;
	    this.inc = opts.increment || 1;
	    this.min = isDef(opts.min) ? opts.min : -Infinity;
	    this.max = isDef(opts.max) ? opts.max : Infinity;
	    this.errorMsg = opts.error || `Please Enter A Valid Value`;
	    this.validator = opts.validate || (() => true);
	    this.color = `cyan`;
	    this.value = ``;
	    this.typed = ``;
	    this.lastHit = 0;
	    this.render();
	  }

	  set value(v) {
	    if (!v && v !== 0) {
	      this.placeholder = true;
	      this.rendered = color.gray(this.transform.render(`${this.initial}`));
	      this._value = ``;
	    } else {
	      this.placeholder = false;
	      this.rendered = this.transform.render(`${round(v, this.round)}`);
	      this._value = round(v, this.round);
	    }
	    this.fire();
	  }

	  get value() {
	    return this._value;
	  }

	  parse(x) {
	    return this.float ? parseFloat(x) : parseInt(x);
	  }

	  valid(c) {
	    return c === `-` || c === `.` && this.float || isNumber.test(c)
	  }

	  reset() {
	    this.typed = ``;
	    this.value = ``;
	    this.fire();
	    this.render();
	  }

	  exit() {
	    this.abort();
	  }

	  abort() {
	    let x = this.value;
	    this.value = x !== `` ? x : this.initial;
	    this.done = this.aborted = true;
	    this.error = false;
	    this.fire();
	    this.render();
	    this.out.write(`\n`);
	    this.close();
	  }

	  async validate() {
	    let valid = await this.validator(this.value);
	    if (typeof valid === `string`) {
	      this.errorMsg = valid;
	      valid = false;
	    }
	    this.error = !valid;
	  }

	  async submit() {
	    await this.validate();
	    if (this.error) {
	      this.color = `red`;
	      this.fire();
	      this.render();
	      return;
	    }
	    let x = this.value;
	    this.value = x !== `` ? x : this.initial;
	    this.done = true;
	    this.aborted = false;
	    this.error = false;
	    this.fire();
	    this.render();
	    this.out.write(`\n`);
	    this.close();
	  }

	  up() {
	    this.typed = ``;
	    if(this.value === '') {
	      this.value = this.min - this.inc;
	    }
	    if (this.value >= this.max) return this.bell();
	    this.value += this.inc;
	    this.color = `cyan`;
	    this.fire();
	    this.render();
	  }

	  down() {
	    this.typed = ``;
	    if(this.value === '') {
	      this.value = this.min + this.inc;
	    }
	    if (this.value <= this.min) return this.bell();
	    this.value -= this.inc;
	    this.color = `cyan`;
	    this.fire();
	    this.render();
	  }

	  delete() {
	    let val = this.value.toString();
	    if (val.length === 0) return this.bell();
	    this.value = this.parse((val = val.slice(0, -1))) || ``;
	    if (this.value !== '' && this.value < this.min) {
	      this.value = this.min;
	    }
	    this.color = `cyan`;
	    this.fire();
	    this.render();
	  }

	  next() {
	    this.value = this.initial;
	    this.fire();
	    this.render();
	  }

	  _(c, key) {
	    if (!this.valid(c)) return this.bell();

	    const now = Date.now();
	    if (now - this.lastHit > 1000) this.typed = ``; // 1s elapsed
	    this.typed += c;
	    this.lastHit = now;
	    this.color = `cyan`;

	    if (c === `.`) return this.fire();

	    this.value = Math.min(this.parse(this.typed), this.max);
	    if (this.value > this.max) this.value = this.max;
	    if (this.value < this.min) this.value = this.min;
	    this.fire();
	    this.render();
	  }

	  render() {
	    if (this.closed) return;
	    if (!this.firstRender) {
	      if (this.outputError)
	        this.out.write(cursor.down(lines(this.outputError, this.out.columns) - 1) + clear(this.outputError, this.out.columns));
	      this.out.write(clear(this.outputText, this.out.columns));
	    }
	    super.render();
	    this.outputError = '';

	    // Print prompt
	    this.outputText = [
	      style.symbol(this.done, this.aborted),
	      color.bold(this.msg),
	      style.delimiter(this.done),
	      !this.done || (!this.done && !this.placeholder)
	          ? color[this.color]().underline(this.rendered) : this.rendered
	    ].join(` `);

	    // Print error
	    if (this.error) {
	      this.outputError += this.errorMsg.split(`\n`)
	          .reduce((a, l, i) => a + `\n${i ? ` ` : figures.pointerSmall} ${color.red().italic(l)}`, ``);
	    }

	    this.out.write(erase.line + cursor.to(0) + this.outputText + cursor.save + this.outputError + cursor.restore);
	  }
	}

	number = NumberPrompt;
	return number;
}

var multiselect;
var hasRequiredMultiselect;

function requireMultiselect () {
	if (hasRequiredMultiselect) return multiselect;
	hasRequiredMultiselect = 1;

	const color = requireKleur();
	const { cursor } = requireSrc();
	const Prompt = requirePrompt();
	const { clear, figures, style, wrap, entriesToDisplay } = requireUtil();

	/**
	 * MultiselectPrompt Base Element
	 * @param {Object} opts Options
	 * @param {String} opts.message Message
	 * @param {Array} opts.choices Array of choice objects
	 * @param {String} [opts.hint] Hint to display
	 * @param {String} [opts.warn] Hint shown for disabled choices
	 * @param {Number} [opts.max] Max choices
	 * @param {Number} [opts.cursor=0] Cursor start position
	 * @param {Number} [opts.optionsPerPage=10] Max options to display at once
	 * @param {Stream} [opts.stdin] The Readable stream to listen to
	 * @param {Stream} [opts.stdout] The Writable stream to write readline data to
	 */
	class MultiselectPrompt extends Prompt {
	  constructor(opts={}) {
	    super(opts);
	    this.msg = opts.message;
	    this.cursor = opts.cursor || 0;
	    this.scrollIndex = opts.cursor || 0;
	    this.hint = opts.hint || '';
	    this.warn = opts.warn || '- This option is disabled -';
	    this.minSelected = opts.min;
	    this.showMinError = false;
	    this.maxChoices = opts.max;
	    this.instructions = opts.instructions;
	    this.optionsPerPage = opts.optionsPerPage || 10;
	    this.value = opts.choices.map((ch, idx) => {
	      if (typeof ch === 'string')
	        ch = {title: ch, value: idx};
	      return {
	        title: ch && (ch.title || ch.value || ch),
	        description: ch && ch.description,
	        value: ch && (ch.value === undefined ? idx : ch.value),
	        selected: ch && ch.selected,
	        disabled: ch && ch.disabled
	      };
	    });
	    this.clear = clear('', this.out.columns);
	    if (!opts.overrideRender) {
	      this.render();
	    }
	  }

	  reset() {
	    this.value.map(v => !v.selected);
	    this.cursor = 0;
	    this.fire();
	    this.render();
	  }

	  selected() {
	    return this.value.filter(v => v.selected);
	  }

	  exit() {
	    this.abort();
	  }

	  abort() {
	    this.done = this.aborted = true;
	    this.fire();
	    this.render();
	    this.out.write('\n');
	    this.close();
	  }

	  submit() {
	    const selected = this.value
	      .filter(e => e.selected);
	    if (this.minSelected && selected.length < this.minSelected) {
	      this.showMinError = true;
	      this.render();
	    } else {
	      this.done = true;
	      this.aborted = false;
	      this.fire();
	      this.render();
	      this.out.write('\n');
	      this.close();
	    }
	  }

	  first() {
	    this.cursor = 0;
	    this.render();
	  }

	  last() {
	    this.cursor = this.value.length - 1;
	    this.render();
	  }
	  next() {
	    this.cursor = (this.cursor + 1) % this.value.length;
	    this.render();
	  }

	  up() {
	    if (this.cursor === 0) {
	      this.cursor = this.value.length - 1;
	    } else {
	      this.cursor--;
	    }
	    this.render();
	  }

	  down() {
	    if (this.cursor === this.value.length - 1) {
	      this.cursor = 0;
	    } else {
	      this.cursor++;
	    }
	    this.render();
	  }

	  left() {
	    this.value[this.cursor].selected = false;
	    this.render();
	  }

	  right() {
	    if (this.value.filter(e => e.selected).length >= this.maxChoices) return this.bell();
	    this.value[this.cursor].selected = true;
	    this.render();
	  }

	  handleSpaceToggle() {
	    const v = this.value[this.cursor];

	    if (v.selected) {
	      v.selected = false;
	      this.render();
	    } else if (v.disabled || this.value.filter(e => e.selected).length >= this.maxChoices) {
	      return this.bell();
	    } else {
	      v.selected = true;
	      this.render();
	    }
	  }

	  toggleAll() {
	    if (this.maxChoices !== undefined || this.value[this.cursor].disabled) {
	      return this.bell();
	    }

	    const newSelected = !this.value[this.cursor].selected;
	    this.value.filter(v => !v.disabled).forEach(v => v.selected = newSelected);
	    this.render();
	  }

	  _(c, key) {
	    if (c === ' ') {
	      this.handleSpaceToggle();
	    } else if (c === 'a') {
	      this.toggleAll();
	    } else {
	      return this.bell();
	    }
	  }

	  renderInstructions() {
	    if (this.instructions === undefined || this.instructions) {
	      if (typeof this.instructions === 'string') {
	        return this.instructions;
	      }
	      return '\nInstructions:\n'
	        + `    ${figures.arrowUp}/${figures.arrowDown}: Highlight option\n`
	        + `    ${figures.arrowLeft}/${figures.arrowRight}/[space]: Toggle selection\n`
	        + (this.maxChoices === undefined ? `    a: Toggle all\n` : '')
	        + `    enter/return: Complete answer`;
	    }
	    return '';
	  }

	  renderOption(cursor, v, i, arrowIndicator) {
	    const prefix = (v.selected ? color.green(figures.radioOn) : figures.radioOff) + ' ' + arrowIndicator + ' ';
	    let title, desc;

	    if (v.disabled) {
	      title = cursor === i ? color.gray().underline(v.title) : color.strikethrough().gray(v.title);
	    } else {
	      title = cursor === i ? color.cyan().underline(v.title) : v.title;
	      if (cursor === i && v.description) {
	        desc = ` - ${v.description}`;
	        if (prefix.length + title.length + desc.length >= this.out.columns
	          || v.description.split(/\r?\n/).length > 1) {
	          desc = '\n' + wrap(v.description, { margin: prefix.length, width: this.out.columns });
	        }
	      }
	    }

	    return prefix + title + color.gray(desc || '');
	  }

	  // shared with autocompleteMultiselect
	  paginateOptions(options) {
	    if (options.length === 0) {
	      return color.red('No matches for this query.');
	    }

	    let { startIndex, endIndex } = entriesToDisplay(this.cursor, options.length, this.optionsPerPage);
	    let prefix, styledOptions = [];

	    for (let i = startIndex; i < endIndex; i++) {
	      if (i === startIndex && startIndex > 0) {
	        prefix = figures.arrowUp;
	      } else if (i === endIndex - 1 && endIndex < options.length) {
	        prefix = figures.arrowDown;
	      } else {
	        prefix = ' ';
	      }
	      styledOptions.push(this.renderOption(this.cursor, options[i], i, prefix));
	    }

	    return '\n' + styledOptions.join('\n');
	  }

	  // shared with autocomleteMultiselect
	  renderOptions(options) {
	    if (!this.done) {
	      return this.paginateOptions(options);
	    }
	    return '';
	  }

	  renderDoneOrInstructions() {
	    if (this.done) {
	      return this.value
	        .filter(e => e.selected)
	        .map(v => v.title)
	        .join(', ');
	    }

	    const output = [color.gray(this.hint), this.renderInstructions()];

	    if (this.value[this.cursor].disabled) {
	      output.push(color.yellow(this.warn));
	    }
	    return output.join(' ');
	  }

	  render() {
	    if (this.closed) return;
	    if (this.firstRender) this.out.write(cursor.hide);
	    super.render();

	    // print prompt
	    let prompt = [
	      style.symbol(this.done, this.aborted),
	      color.bold(this.msg),
	      style.delimiter(false),
	      this.renderDoneOrInstructions()
	    ].join(' ');
	    if (this.showMinError) {
	      prompt += color.red(`You must select a minimum of ${this.minSelected} choices.`);
	      this.showMinError = false;
	    }
	    prompt += this.renderOptions(this.value);

	    this.out.write(this.clear + prompt);
	    this.clear = clear(prompt, this.out.columns);
	  }
	}

	multiselect = MultiselectPrompt;
	return multiselect;
}

var autocomplete;
var hasRequiredAutocomplete;

function requireAutocomplete () {
	if (hasRequiredAutocomplete) return autocomplete;
	hasRequiredAutocomplete = 1;

	const color = requireKleur();
	const Prompt = requirePrompt();
	const { erase, cursor } = requireSrc();
	const { style, clear, figures, wrap, entriesToDisplay } = requireUtil();

	const getVal = (arr, i) => arr[i] && (arr[i].value || arr[i].title || arr[i]);
	const getTitle = (arr, i) => arr[i] && (arr[i].title || arr[i].value || arr[i]);
	const getIndex = (arr, valOrTitle) => {
	  const index = arr.findIndex(el => el.value === valOrTitle || el.title === valOrTitle);
	  return index > -1 ? index : undefined;
	};

	/**
	 * TextPrompt Base Element
	 * @param {Object} opts Options
	 * @param {String} opts.message Message
	 * @param {Array} opts.choices Array of auto-complete choices objects
	 * @param {Function} [opts.suggest] Filter function. Defaults to sort by title
	 * @param {Number} [opts.limit=10] Max number of results to show
	 * @param {Number} [opts.cursor=0] Cursor start position
	 * @param {String} [opts.style='default'] Render style
	 * @param {String} [opts.fallback] Fallback message - initial to default value
	 * @param {String} [opts.initial] Index of the default value
	 * @param {Boolean} [opts.clearFirst] The first ESCAPE keypress will clear the input
	 * @param {Stream} [opts.stdin] The Readable stream to listen to
	 * @param {Stream} [opts.stdout] The Writable stream to write readline data to
	 * @param {String} [opts.noMatches] The no matches found label
	 */
	class AutocompletePrompt extends Prompt {
	  constructor(opts={}) {
	    super(opts);
	    this.msg = opts.message;
	    this.suggest = opts.suggest;
	    this.choices = opts.choices;
	    this.initial = typeof opts.initial === 'number'
	      ? opts.initial
	      : getIndex(opts.choices, opts.initial);
	    this.select = this.initial || opts.cursor || 0;
	    this.i18n = { noMatches: opts.noMatches || 'no matches found' };
	    this.fallback = opts.fallback || this.initial;
	    this.clearFirst = opts.clearFirst || false;
	    this.suggestions = [];
	    this.input = '';
	    this.limit = opts.limit || 10;
	    this.cursor = 0;
	    this.transform = style.render(opts.style);
	    this.scale = this.transform.scale;
	    this.render = this.render.bind(this);
	    this.complete = this.complete.bind(this);
	    this.clear = clear('', this.out.columns);
	    this.complete(this.render);
	    this.render();
	  }

	  set fallback(fb) {
	    this._fb = Number.isSafeInteger(parseInt(fb)) ? parseInt(fb) : fb;
	  }

	  get fallback() {
	    let choice;
	    if (typeof this._fb === 'number')
	      choice = this.choices[this._fb];
	    else if (typeof this._fb === 'string')
	      choice = { title: this._fb };
	    return choice || this._fb || { title: this.i18n.noMatches };
	  }

	  moveSelect(i) {
	    this.select = i;
	    if (this.suggestions.length > 0)
	      this.value = getVal(this.suggestions, i);
	    else this.value = this.fallback.value;
	    this.fire();
	  }

	  async complete(cb) {
	    const p = (this.completing = this.suggest(this.input, this.choices));
	    const suggestions = await p;

	    if (this.completing !== p) return;
	    this.suggestions = suggestions
	      .map((s, i, arr) => ({ title: getTitle(arr, i), value: getVal(arr, i), description: s.description }));
	    this.completing = false;
	    const l = Math.max(suggestions.length - 1, 0);
	    this.moveSelect(Math.min(l, this.select));

	    cb && cb();
	  }

	  reset() {
	    this.input = '';
	    this.complete(() => {
	      this.moveSelect(this.initial !== void 0 ? this.initial : 0);
	      this.render();
	    });
	    this.render();
	  }

	  exit() {
	    if (this.clearFirst && this.input.length > 0) {
	      this.reset();
	    } else {
	      this.done = this.exited = true; 
	      this.aborted = false;
	      this.fire();
	      this.render();
	      this.out.write('\n');
	      this.close();
	    }
	  }

	  abort() {
	    this.done = this.aborted = true;
	    this.exited = false;
	    this.fire();
	    this.render();
	    this.out.write('\n');
	    this.close();
	  }

	  submit() {
	    this.done = true;
	    this.aborted = this.exited = false;
	    this.fire();
	    this.render();
	    this.out.write('\n');
	    this.close();
	  }

	  _(c, key) {
	    let s1 = this.input.slice(0, this.cursor);
	    let s2 = this.input.slice(this.cursor);
	    this.input = `${s1}${c}${s2}`;
	    this.cursor = s1.length+1;
	    this.complete(this.render);
	    this.render();
	  }

	  delete() {
	    if (this.cursor === 0) return this.bell();
	    let s1 = this.input.slice(0, this.cursor-1);
	    let s2 = this.input.slice(this.cursor);
	    this.input = `${s1}${s2}`;
	    this.complete(this.render);
	    this.cursor = this.cursor-1;
	    this.render();
	  }

	  deleteForward() {
	    if(this.cursor*this.scale >= this.rendered.length) return this.bell();
	    let s1 = this.input.slice(0, this.cursor);
	    let s2 = this.input.slice(this.cursor+1);
	    this.input = `${s1}${s2}`;
	    this.complete(this.render);
	    this.render();
	  }

	  first() {
	    this.moveSelect(0);
	    this.render();
	  }

	  last() {
	    this.moveSelect(this.suggestions.length - 1);
	    this.render();
	  }

	  up() {
	    if (this.select === 0) {
	      this.moveSelect(this.suggestions.length - 1);
	    } else {
	      this.moveSelect(this.select - 1);
	    }
	    this.render();
	  }

	  down() {
	    if (this.select === this.suggestions.length - 1) {
	      this.moveSelect(0);
	    } else {
	      this.moveSelect(this.select + 1);
	    }
	    this.render();
	  }

	  next() {
	    if (this.select === this.suggestions.length - 1) {
	      this.moveSelect(0);
	    } else this.moveSelect(this.select + 1);
	    this.render();
	  }

	  nextPage() {
	    this.moveSelect(Math.min(this.select + this.limit, this.suggestions.length - 1));
	    this.render();
	  }

	  prevPage() {
	    this.moveSelect(Math.max(this.select - this.limit, 0));
	    this.render();
	  }

	  left() {
	    if (this.cursor <= 0) return this.bell();
	    this.cursor = this.cursor-1;
	    this.render();
	  }

	  right() {
	    if (this.cursor*this.scale >= this.rendered.length) return this.bell();
	    this.cursor = this.cursor+1;
	    this.render();
	  }

	  renderOption(v, hovered, isStart, isEnd) {
	    let desc;
	    let prefix = isStart ? figures.arrowUp : isEnd ? figures.arrowDown : ' ';
	    let title = hovered ? color.cyan().underline(v.title) : v.title;
	    prefix = (hovered ? color.cyan(figures.pointer) + ' ' : '  ') + prefix;
	    if (v.description) {
	      desc = ` - ${v.description}`;
	      if (prefix.length + title.length + desc.length >= this.out.columns
	        || v.description.split(/\r?\n/).length > 1) {
	        desc = '\n' + wrap(v.description, { margin: 3, width: this.out.columns });
	      }
	    }
	    return prefix + ' ' + title + color.gray(desc || '');
	  }

	  render() {
	    if (this.closed) return;
	    if (this.firstRender) this.out.write(cursor.hide);
	    else this.out.write(clear(this.outputText, this.out.columns));
	    super.render();

	    let { startIndex, endIndex } = entriesToDisplay(this.select, this.choices.length, this.limit);

	    this.outputText = [
	      style.symbol(this.done, this.aborted, this.exited),
	      color.bold(this.msg),
	      style.delimiter(this.completing),
	      this.done && this.suggestions[this.select]
	        ? this.suggestions[this.select].title
	        : this.rendered = this.transform.render(this.input)
	    ].join(' ');

	    if (!this.done) {
	      const suggestions = this.suggestions
	        .slice(startIndex, endIndex)
	        .map((item, i) =>  this.renderOption(item,
	          this.select === i + startIndex,
	          i === 0 && startIndex > 0,
	          i + startIndex === endIndex - 1 && endIndex < this.choices.length))
	        .join('\n');
	      this.outputText += `\n` + (suggestions || color.gray(this.fallback.title));
	    }

	    this.out.write(erase.line + cursor.to(0) + this.outputText);
	  }
	}

	autocomplete = AutocompletePrompt;
	return autocomplete;
}

var autocompleteMultiselect;
var hasRequiredAutocompleteMultiselect;

function requireAutocompleteMultiselect () {
	if (hasRequiredAutocompleteMultiselect) return autocompleteMultiselect;
	hasRequiredAutocompleteMultiselect = 1;

	const color = requireKleur();
	const { cursor } = requireSrc();
	const MultiselectPrompt = requireMultiselect();
	const { clear, style, figures } = requireUtil();
	/**
	 * MultiselectPrompt Base Element
	 * @param {Object} opts Options
	 * @param {String} opts.message Message
	 * @param {Array} opts.choices Array of choice objects
	 * @param {String} [opts.hint] Hint to display
	 * @param {String} [opts.warn] Hint shown for disabled choices
	 * @param {Number} [opts.max] Max choices
	 * @param {Number} [opts.cursor=0] Cursor start position
	 * @param {Stream} [opts.stdin] The Readable stream to listen to
	 * @param {Stream} [opts.stdout] The Writable stream to write readline data to
	 */
	class AutocompleteMultiselectPrompt extends MultiselectPrompt {
	  constructor(opts={}) {
	    opts.overrideRender = true;
	    super(opts);
	    this.inputValue = '';
	    this.clear = clear('', this.out.columns);
	    this.filteredOptions = this.value;
	    this.render();
	  }

	  last() {
	    this.cursor = this.filteredOptions.length - 1;
	    this.render();
	  }
	  next() {
	    this.cursor = (this.cursor + 1) % this.filteredOptions.length;
	    this.render();
	  }

	  up() {
	    if (this.cursor === 0) {
	      this.cursor = this.filteredOptions.length - 1;
	    } else {
	      this.cursor--;
	    }
	    this.render();
	  }

	  down() {
	    if (this.cursor === this.filteredOptions.length - 1) {
	      this.cursor = 0;
	    } else {
	      this.cursor++;
	    }
	    this.render();
	  }

	  left() {
	    this.filteredOptions[this.cursor].selected = false;
	    this.render();
	  }

	  right() {
	    if (this.value.filter(e => e.selected).length >= this.maxChoices) return this.bell();
	    this.filteredOptions[this.cursor].selected = true;
	    this.render();
	  }

	  delete() {
	    if (this.inputValue.length) {
	      this.inputValue = this.inputValue.substr(0, this.inputValue.length - 1);
	      this.updateFilteredOptions();
	    }
	  }

	  updateFilteredOptions() {
	    const currentHighlight = this.filteredOptions[this.cursor];
	    this.filteredOptions = this.value
	      .filter(v => {
	        if (this.inputValue) {
	          if (typeof v.title === 'string') {
	            if (v.title.toLowerCase().includes(this.inputValue.toLowerCase())) {
	              return true;
	            }
	          }
	          if (typeof v.value === 'string') {
	            if (v.value.toLowerCase().includes(this.inputValue.toLowerCase())) {
	              return true;
	            }
	          }
	          return false;
	        }
	        return true;
	      });
	    const newHighlightIndex = this.filteredOptions.findIndex(v => v === currentHighlight);
	    this.cursor = newHighlightIndex < 0 ? 0 : newHighlightIndex;
	    this.render();
	  }

	  handleSpaceToggle() {
	    const v = this.filteredOptions[this.cursor];

	    if (v.selected) {
	      v.selected = false;
	      this.render();
	    } else if (v.disabled || this.value.filter(e => e.selected).length >= this.maxChoices) {
	      return this.bell();
	    } else {
	      v.selected = true;
	      this.render();
	    }
	  }

	  handleInputChange(c) {
	    this.inputValue = this.inputValue + c;
	    this.updateFilteredOptions();
	  }

	  _(c, key) {
	    if (c === ' ') {
	      this.handleSpaceToggle();
	    } else {
	      this.handleInputChange(c);
	    }
	  }

	  renderInstructions() {
	    if (this.instructions === undefined || this.instructions) {
	      if (typeof this.instructions === 'string') {
	        return this.instructions;
	      }
	      return `
Instructions:
    ${figures.arrowUp}/${figures.arrowDown}: Highlight option
    ${figures.arrowLeft}/${figures.arrowRight}/[space]: Toggle selection
    [a,b,c]/delete: Filter choices
    enter/return: Complete answer
`;
	    }
	    return '';
	  }

	  renderCurrentInput() {
	    return `
Filtered results for: ${this.inputValue ? this.inputValue : color.gray('Enter something to filter')}\n`;
	  }

	  renderOption(cursor, v, i, arrowIndicator) {
	    const prefix = (v.selected ? color.green(figures.radioOn) : figures.radioOff) + ' ' + arrowIndicator + ' ';
	    let title;
	    if (v.disabled) title = cursor === i ? color.gray().underline(v.title) : color.strikethrough().gray(v.title);
	    else title = cursor === i ? color.cyan().underline(v.title) : v.title;
	    return prefix + title;
	  }

	  renderDoneOrInstructions() {
	    if (this.done) {
	      return this.value
	        .filter(e => e.selected)
	        .map(v => v.title)
	        .join(', ');
	    }

	    const output = [color.gray(this.hint), this.renderInstructions(), this.renderCurrentInput()];

	    if (this.filteredOptions.length && this.filteredOptions[this.cursor].disabled) {
	      output.push(color.yellow(this.warn));
	    }
	    return output.join(' ');
	  }

	  render() {
	    if (this.closed) return;
	    if (this.firstRender) this.out.write(cursor.hide);
	    super.render();

	    // print prompt

	    let prompt = [
	      style.symbol(this.done, this.aborted),
	      color.bold(this.msg),
	      style.delimiter(false),
	      this.renderDoneOrInstructions()
	    ].join(' ');

	    if (this.showMinError) {
	      prompt += color.red(`You must select a minimum of ${this.minSelected} choices.`);
	      this.showMinError = false;
	    }
	    prompt += this.renderOptions(this.filteredOptions);

	    this.out.write(this.clear + prompt);
	    this.clear = clear(prompt, this.out.columns);
	  }
	}

	autocompleteMultiselect = AutocompleteMultiselectPrompt;
	return autocompleteMultiselect;
}

var confirm;
var hasRequiredConfirm;

function requireConfirm () {
	if (hasRequiredConfirm) return confirm;
	hasRequiredConfirm = 1;
	const color = requireKleur();
	const Prompt = requirePrompt();
	const { style, clear } = requireUtil();
	const { erase, cursor } = requireSrc();

	/**
	 * ConfirmPrompt Base Element
	 * @param {Object} opts Options
	 * @param {String} opts.message Message
	 * @param {Boolean} [opts.initial] Default value (true/false)
	 * @param {Stream} [opts.stdin] The Readable stream to listen to
	 * @param {Stream} [opts.stdout] The Writable stream to write readline data to
	 * @param {String} [opts.yes] The "Yes" label
	 * @param {String} [opts.yesOption] The "Yes" option when choosing between yes/no
	 * @param {String} [opts.no] The "No" label
	 * @param {String} [opts.noOption] The "No" option when choosing between yes/no
	 */
	class ConfirmPrompt extends Prompt {
	  constructor(opts={}) {
	    super(opts);
	    this.msg = opts.message;
	    this.value = opts.initial;
	    this.initialValue = !!opts.initial;
	    this.yesMsg = opts.yes || 'yes';
	    this.yesOption = opts.yesOption || '(Y/n)';
	    this.noMsg = opts.no || 'no';
	    this.noOption = opts.noOption || '(y/N)';
	    this.render();
	  }

	  reset() {
	    this.value = this.initialValue;
	    this.fire();
	    this.render();
	  }

	  exit() {
	    this.abort();
	  }

	  abort() {
	    this.done = this.aborted = true;
	    this.fire();
	    this.render();
	    this.out.write('\n');
	    this.close();
	  }

	  submit() {
	    this.value = this.value || false;
	    this.done = true;
	    this.aborted = false;
	    this.fire();
	    this.render();
	    this.out.write('\n');
	    this.close();
	  }

	  _(c, key) {
	    if (c.toLowerCase() === 'y') {
	      this.value = true;
	      return this.submit();
	    }
	    if (c.toLowerCase() === 'n') {
	      this.value = false;
	      return this.submit();
	    }
	    return this.bell();
	  }

	  render() {
	    if (this.closed) return;
	    if (this.firstRender) this.out.write(cursor.hide);
	    else this.out.write(clear(this.outputText, this.out.columns));
	    super.render();

	    this.outputText = [
	      style.symbol(this.done, this.aborted),
	      color.bold(this.msg),
	      style.delimiter(this.done),
	      this.done ? (this.value ? this.yesMsg : this.noMsg)
	          : color.gray(this.initialValue ? this.yesOption : this.noOption)
	    ].join(' ');

	    this.out.write(erase.line + cursor.to(0) + this.outputText);
	  }
	}

	confirm = ConfirmPrompt;
	return confirm;
}

var elements;
var hasRequiredElements;

function requireElements () {
	if (hasRequiredElements) return elements;
	hasRequiredElements = 1;

	elements = {
	  TextPrompt: requireText(),
	  SelectPrompt: requireSelect(),
	  TogglePrompt: requireToggle(),
	  DatePrompt: requireDate(),
	  NumberPrompt: requireNumber(),
	  MultiselectPrompt: requireMultiselect(),
	  AutocompletePrompt: requireAutocomplete(),
	  AutocompleteMultiselectPrompt: requireAutocompleteMultiselect(),
	  ConfirmPrompt: requireConfirm()
	};
	return elements;
}

var hasRequiredPrompts$1;

function requirePrompts$1 () {
	if (hasRequiredPrompts$1) return prompts$2;
	hasRequiredPrompts$1 = 1;
	(function (exports) {
		const $ = exports;
		const el = requireElements();
		const noop = v => v;

		function toPrompt(type, args, opts={}) {
		  return new Promise((res, rej) => {
		    const p = new el[type](args);
		    const onAbort = opts.onAbort || noop;
		    const onSubmit = opts.onSubmit || noop;
		    const onExit = opts.onExit || noop;
		    p.on('state', args.onState || noop);
		    p.on('submit', x => res(onSubmit(x)));
		    p.on('exit', x => res(onExit(x)));
		    p.on('abort', x => rej(onAbort(x)));
		  });
		}

		/**
		 * Text prompt
		 * @param {string} args.message Prompt message to display
		 * @param {string} [args.initial] Default string value
		 * @param {string} [args.style="default"] Render style ('default', 'password', 'invisible')
		 * @param {function} [args.onState] On state change callback
		 * @param {function} [args.validate] Function to validate user input
		 * @param {Stream} [args.stdin] The Readable stream to listen to
		 * @param {Stream} [args.stdout] The Writable stream to write readline data to
		 * @returns {Promise} Promise with user input
		 */
		$.text = args => toPrompt('TextPrompt', args);

		/**
		 * Password prompt with masked input
		 * @param {string} args.message Prompt message to display
		 * @param {string} [args.initial] Default string value
		 * @param {function} [args.onState] On state change callback
		 * @param {function} [args.validate] Function to validate user input
		 * @param {Stream} [args.stdin] The Readable stream to listen to
		 * @param {Stream} [args.stdout] The Writable stream to write readline data to
		 * @returns {Promise} Promise with user input
		 */
		$.password = args => {
		  args.style = 'password';
		  return $.text(args);
		};

		/**
		 * Prompt where input is invisible, like sudo
		 * @param {string} args.message Prompt message to display
		 * @param {string} [args.initial] Default string value
		 * @param {function} [args.onState] On state change callback
		 * @param {function} [args.validate] Function to validate user input
		 * @param {Stream} [args.stdin] The Readable stream to listen to
		 * @param {Stream} [args.stdout] The Writable stream to write readline data to
		 * @returns {Promise} Promise with user input
		 */
		$.invisible = args => {
		  args.style = 'invisible';
		  return $.text(args);
		};

		/**
		 * Number prompt
		 * @param {string} args.message Prompt message to display
		 * @param {number} args.initial Default number value
		 * @param {function} [args.onState] On state change callback
		 * @param {number} [args.max] Max value
		 * @param {number} [args.min] Min value
		 * @param {string} [args.style="default"] Render style ('default', 'password', 'invisible')
		 * @param {Boolean} [opts.float=false] Parse input as floats
		 * @param {Number} [opts.round=2] Round floats to x decimals
		 * @param {Number} [opts.increment=1] Number to increment by when using arrow-keys
		 * @param {function} [args.validate] Function to validate user input
		 * @param {Stream} [args.stdin] The Readable stream to listen to
		 * @param {Stream} [args.stdout] The Writable stream to write readline data to
		 * @returns {Promise} Promise with user input
		 */
		$.number = args => toPrompt('NumberPrompt', args);

		/**
		 * Date prompt
		 * @param {string} args.message Prompt message to display
		 * @param {number} args.initial Default number value
		 * @param {function} [args.onState] On state change callback
		 * @param {number} [args.max] Max value
		 * @param {number} [args.min] Min value
		 * @param {string} [args.style="default"] Render style ('default', 'password', 'invisible')
		 * @param {Boolean} [opts.float=false] Parse input as floats
		 * @param {Number} [opts.round=2] Round floats to x decimals
		 * @param {Number} [opts.increment=1] Number to increment by when using arrow-keys
		 * @param {function} [args.validate] Function to validate user input
		 * @param {Stream} [args.stdin] The Readable stream to listen to
		 * @param {Stream} [args.stdout] The Writable stream to write readline data to
		 * @returns {Promise} Promise with user input
		 */
		$.date = args => toPrompt('DatePrompt', args);

		/**
		 * Classic yes/no prompt
		 * @param {string} args.message Prompt message to display
		 * @param {boolean} [args.initial=false] Default value
		 * @param {function} [args.onState] On state change callback
		 * @param {Stream} [args.stdin] The Readable stream to listen to
		 * @param {Stream} [args.stdout] The Writable stream to write readline data to
		 * @returns {Promise} Promise with user input
		 */
		$.confirm = args => toPrompt('ConfirmPrompt', args);

		/**
		 * List prompt, split intput string by `seperator`
		 * @param {string} args.message Prompt message to display
		 * @param {string} [args.initial] Default string value
		 * @param {string} [args.style="default"] Render style ('default', 'password', 'invisible')
		 * @param {string} [args.separator] String separator
		 * @param {function} [args.onState] On state change callback
		 * @param {Stream} [args.stdin] The Readable stream to listen to
		 * @param {Stream} [args.stdout] The Writable stream to write readline data to
		 * @returns {Promise} Promise with user input, in form of an `Array`
		 */
		$.list = args => {
		  const sep = args.separator || ',';
		  return toPrompt('TextPrompt', args, {
		    onSubmit: str => str.split(sep).map(s => s.trim())
		  });
		};

		/**
		 * Toggle/switch prompt
		 * @param {string} args.message Prompt message to display
		 * @param {boolean} [args.initial=false] Default value
		 * @param {string} [args.active="on"] Text for `active` state
		 * @param {string} [args.inactive="off"] Text for `inactive` state
		 * @param {function} [args.onState] On state change callback
		 * @param {Stream} [args.stdin] The Readable stream to listen to
		 * @param {Stream} [args.stdout] The Writable stream to write readline data to
		 * @returns {Promise} Promise with user input
		 */
		$.toggle = args => toPrompt('TogglePrompt', args);

		/**
		 * Interactive select prompt
		 * @param {string} args.message Prompt message to display
		 * @param {Array} args.choices Array of choices objects `[{ title, value }, ...]`
		 * @param {number} [args.initial] Index of default value
		 * @param {String} [args.hint] Hint to display
		 * @param {function} [args.onState] On state change callback
		 * @param {Stream} [args.stdin] The Readable stream to listen to
		 * @param {Stream} [args.stdout] The Writable stream to write readline data to
		 * @returns {Promise} Promise with user input
		 */
		$.select = args => toPrompt('SelectPrompt', args);

		/**
		 * Interactive multi-select / autocompleteMultiselect prompt
		 * @param {string} args.message Prompt message to display
		 * @param {Array} args.choices Array of choices objects `[{ title, value, [selected] }, ...]`
		 * @param {number} [args.max] Max select
		 * @param {string} [args.hint] Hint to display user
		 * @param {Number} [args.cursor=0] Cursor start position
		 * @param {function} [args.onState] On state change callback
		 * @param {Stream} [args.stdin] The Readable stream to listen to
		 * @param {Stream} [args.stdout] The Writable stream to write readline data to
		 * @returns {Promise} Promise with user input
		 */
		$.multiselect = args => {
		  args.choices = [].concat(args.choices || []);
		  const toSelected = items => items.filter(item => item.selected).map(item => item.value);
		  return toPrompt('MultiselectPrompt', args, {
		    onAbort: toSelected,
		    onSubmit: toSelected
		  });
		};

		$.autocompleteMultiselect = args => {
		  args.choices = [].concat(args.choices || []);
		  const toSelected = items => items.filter(item => item.selected).map(item => item.value);
		  return toPrompt('AutocompleteMultiselectPrompt', args, {
		    onAbort: toSelected,
		    onSubmit: toSelected
		  });
		};

		const byTitle = (input, choices) => Promise.resolve(
		  choices.filter(item => item.title.slice(0, input.length).toLowerCase() === input.toLowerCase())
		);

		/**
		 * Interactive auto-complete prompt
		 * @param {string} args.message Prompt message to display
		 * @param {Array} args.choices Array of auto-complete choices objects `[{ title, value }, ...]`
		 * @param {Function} [args.suggest] Function to filter results based on user input. Defaults to sort by `title`
		 * @param {number} [args.limit=10] Max number of results to show
		 * @param {string} [args.style="default"] Render style ('default', 'password', 'invisible')
		 * @param {String} [args.initial] Index of the default value
		 * @param {boolean} [opts.clearFirst] The first ESCAPE keypress will clear the input
		 * @param {String} [args.fallback] Fallback message - defaults to initial value
		 * @param {function} [args.onState] On state change callback
		 * @param {Stream} [args.stdin] The Readable stream to listen to
		 * @param {Stream} [args.stdout] The Writable stream to write readline data to
		 * @returns {Promise} Promise with user input
		 */
		$.autocomplete = args => {
		  args.suggest = args.suggest || byTitle;
		  args.choices = [].concat(args.choices || []);
		  return toPrompt('AutocompletePrompt', args);
		}; 
	} (prompts$2));
	return prompts$2;
}

var lib;
var hasRequiredLib;

function requireLib () {
	if (hasRequiredLib) return lib;
	hasRequiredLib = 1;

	const prompts = requirePrompts$1();

	const passOn = ['suggest', 'format', 'onState', 'validate', 'onRender', 'type'];
	const noop = () => {};

	/**
	 * Prompt for a series of questions
	 * @param {Array|Object} questions Single question object or Array of question objects
	 * @param {Function} [onSubmit] Callback function called on prompt submit
	 * @param {Function} [onCancel] Callback function called on cancel/abort
	 * @returns {Object} Object with values from user input
	 */
	async function prompt(questions=[], { onSubmit=noop, onCancel=noop }={}) {
	  const answers = {};
	  const override = prompt._override || {};
	  questions = [].concat(questions);
	  let answer, question, quit, name, type, lastPrompt;

	  const getFormattedAnswer = async (question, answer, skipValidation = false) => {
	    if (!skipValidation && question.validate && question.validate(answer) !== true) {
	      return;
	    }
	    return question.format ? await question.format(answer, answers) : answer
	  };

	  for (question of questions) {
	    ({ name, type } = question);

	    // evaluate type first and skip if type is a falsy value
	    if (typeof type === 'function') {
	      type = await type(answer, { ...answers }, question);
	      question['type'] = type;
	    }
	    if (!type) continue;

	    // if property is a function, invoke it unless it's a special function
	    for (let key in question) {
	      if (passOn.includes(key)) continue;
	      let value = question[key];
	      question[key] = typeof value === 'function' ? await value(answer, { ...answers }, lastPrompt) : value;
	    }

	    lastPrompt = question;

	    if (typeof question.message !== 'string') {
	      throw new Error('prompt message is required');
	    }

	    // update vars in case they changed
	    ({ name, type } = question);

	    if (prompts[type] === void 0) {
	      throw new Error(`prompt type (${type}) is not defined`);
	    }

	    if (override[question.name] !== undefined) {
	      answer = await getFormattedAnswer(question, override[question.name]);
	      if (answer !== undefined) {
	        answers[name] = answer;
	        continue;
	      }
	    }

	    try {
	      // Get the injected answer if there is one or prompt the user
	      answer = prompt._injected ? getInjectedAnswer(prompt._injected, question.initial) : await prompts[type](question);
	      answers[name] = answer = await getFormattedAnswer(question, answer, true);
	      quit = await onSubmit(question, answer, answers);
	    } catch (err) {
	      quit = !(await onCancel(question, answers));
	    }

	    if (quit) return answers;
	  }

	  return answers;
	}

	function getInjectedAnswer(injected, deafultValue) {
	  const answer = injected.shift();
	    if (answer instanceof Error) {
	      throw answer;
	    }

	    return (answer === undefined) ? deafultValue : answer;
	}

	function inject(answers) {
	  prompt._injected = (prompt._injected || []).concat(answers);
	}

	function override(answers) {
	  prompt._override = Object.assign({}, answers);
	}

	lib = Object.assign(prompt, { prompt, prompts, inject, override });
	return lib;
}

var prompts$1;
var hasRequiredPrompts;

function requirePrompts () {
	if (hasRequiredPrompts) return prompts$1;
	hasRequiredPrompts = 1;
	prompts$1 = requireLib();
	return prompts$1;
}

var promptsExports = requirePrompts();
const prompts = /*@__PURE__*/getDefaultExportFromCjs(promptsExports);

var ansis = {exports: {}};

var hasRequiredAnsis;

function requireAnsis () {
	if (hasRequiredAnsis) return ansis.exports;
	hasRequiredAnsis = 1;
	let e,t,r,{defineProperty:n,setPrototypeOf:l,create:o,keys:s}=Object,i="",{round:c,max:a}=Math,p=e=>{let t=/([a-f\d]{3,6})/i.exec(e)?.[1],r=t?.length,n=parseInt(6^r?3^r?"0":t[0]+t[0]+t[1]+t[1]+t[2]+t[2]:t,16);return [n>>16&255,n>>8&255,255&n]},u=(e,t,r)=>e^t||t^r?16+36*c(e/51)+6*c(t/51)+c(r/51):8>e?16:e>248?231:c(24*(e-8)/247)+232,d=e=>{let t,r,n,l,o;return 8>e?30+e:16>e?e-8+90:(232>e?(o=(e-=16)%36,t=(e/36|0)/5,r=(o/6|0)/5,n=o%6/5):t=r=n=(10*(e-232)+8)/255,l=2*a(t,r,n),l?30+(c(n)<<2|c(r)<<1|c(t))+(2^l?0:60):30)},g=(()=>{let r=e=>o.some((t=>e.test(t))),n=globalThis,l=n.process??{},o=l.argv??[],i=l.env??{},c=-1;try{e=","+s(i).join(",");}catch(e){i={},c=0;}let a="FORCE_COLOR",p={false:0,0:0,1:1,2:2,3:3}[i[a]]??-1,u=a in i&&p||r(/^--color=?(true|always)?$/);return u&&(c=p),~c||(c=((r,n,l)=>(t=r.TERM,{"24bit":3,truecolor:3,ansi256:2,ansi:1}[r.COLORTERM]||(r.CI?/,GITHUB/.test(e)?3:1:n&&"dumb"!==t?l?3:/-256/.test(t)?2:1:0)))(i,!!i.PM2_HOME||i.NEXT_RUNTIME?.includes("edge")||!!l.stdout?.isTTY,"win32"===l.platform)),!p||i.NO_COLOR||r(/^--(no-color|color=(false|never))$/)?0:n.window?.chrome||u&&!c?3:c})(),f={open:i,close:i},h=39,b=49,O={},m=({p:e},{open:t,close:n})=>{let o=(e,...r)=>{if(!e){if(t&&t===n)return t;if((e??i)===i)return i}let l,s=e.raw?String.raw({raw:e},...r):i+e,c=o.p,a=c.o,p=c.c;if(s.includes(""))for(;c;c=c.p){let{open:e,close:t}=c,r=t.length,n=i,o=0;if(r)for(;~(l=s.indexOf(t,o));o=l+r)n+=s.slice(o,l)+e;s=n+s.slice(o);}return a+(s.includes("\n")?s.replace(/(\r?\n)/g,p+"$1"+a):s)+p},s=t,c=n;return e&&(s=e.o+t,c=n+e.c),l(o,r),o.p={open:t,close:n,o:s,c,p:e},o.open=s,o.close=c,o};const w=function(e=g){let t={Ansis:w,level:e,isSupported:()=>s,strip:e=>e.replace(/[][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g,i),extend(e){for(let t in e){let r=e[t],l=(typeof r)[0],o="s"===l?x(...p(r)):r;O[t]="f"===l?{get(){return (...e)=>m(this,r(...e))}}:{get(){let e=m(this,o);return n(this,t,{value:e}),e}};}return r=o({},O),l(t,r),t}},s=e>0,c=(e,t)=>s?{open:`[${e}m`,close:`[${t}m`}:f,a=e=>t=>e(...p(t)),y=(e,t)=>(r,n,l)=>c(`${e}8;2;${r};${n};${l}`,t),R=(e,t)=>(r,n,l)=>c(((e,t,r)=>d(u(e,t,r)))(r,n,l)+e,t),$=e=>(t,r,n)=>e(u(t,r,n)),x=y(3,h),T=y(4,b),v=e=>c("38;5;"+e,h),C=e=>c("48;5;"+e,b);2===e?(x=$(v),T=$(C)):1===e&&(x=R(0,h),T=R(10,b),v=e=>c(d(e),h),C=e=>c(d(e)+10,b));let E,M={fg:v,bg:C,rgb:x,bgRgb:T,hex:a(x),bgHex:a(T),visible:f,reset:c(0,0),bold:c(1,22),dim:c(2,22),italic:c(3,23),underline:c(4,24),inverse:c(7,27),hidden:c(8,28),strikethrough:c(9,29)},I="Bright";return "black,red,green,yellow,blue,magenta,cyan,white,gray".split(",").map(((e,t)=>{E="bg"+e[0].toUpperCase()+e.slice(1),8>t?(M[e+I]=c(90+t,h),M[E+I]=c(100+t,b)):t=60,M[e]=c(30+t,h),M[E]=c(40+t,b);})),t.extend(M)},y=new w;ansis.exports=y,y.default=y;
	return ansis.exports;
}

var ansisExports = /*@__PURE__*/ requireAnsis();
const a = /*@__PURE__*/getDefaultExportFromCjs(ansisExports);

const{Ansis,fg,bg,rgb,bgRgb,hex,bgHex,reset,inverse,hidden,visible,bold,dim,italic,underline,strikethrough,black,red,green,yellow,blue,magenta,cyan,white,gray,redBright,greenBright,yellowBright,blueBright,magentaBright,cyanBright,whiteBright,bgBlack,bgRed,bgGreen,bgYellow,bgBlue,bgMagenta,bgCyan,bgWhite,bgGray,bgRedBright,bgGreenBright,bgYellowBright,bgBlueBright,bgMagentaBright,bgCyanBright,bgWhiteBright}=a;

var eta;
var hasRequiredEta;

function requireEta () {
	if (hasRequiredEta) return eta;
	hasRequiredEta = 1;
	// ETA calculation
	class ETA{

	    constructor(length, initTime, initValue){
	        // size of eta buffer
	        this.etaBufferLength = length || 100;

	        // eta buffer with initial values
	        this.valueBuffer = [initValue];
	        this.timeBuffer = [initTime];

	        // eta time value
	        this.eta = '0';
	    }

	    // add new values to calculation buffer
	    update(time, value, total){
	        this.valueBuffer.push(value);
	        this.timeBuffer.push(time);

	        // trigger recalculation
	        this.calculate(total-value);
	    }

	    // fetch estimated time
	    getTime(){
	        return this.eta;
	    }

	    // eta calculation - request number of remaining events
	    calculate(remaining){
	        // get number of samples in eta buffer
	        const currentBufferSize = this.valueBuffer.length;
	        const buffer = Math.min(this.etaBufferLength, currentBufferSize);

	        const v_diff = this.valueBuffer[currentBufferSize - 1] - this.valueBuffer[currentBufferSize - buffer];
	        const t_diff = this.timeBuffer[currentBufferSize - 1] - this.timeBuffer[currentBufferSize - buffer];

	        // get progress per ms
	        const vt_rate = v_diff/t_diff;

	        // strip past elements
	        this.valueBuffer = this.valueBuffer.slice(-this.etaBufferLength);
	        this.timeBuffer  = this.timeBuffer.slice(-this.etaBufferLength);

	        // eq: vt_rate *x = total
	        const eta = Math.ceil(remaining/vt_rate/1000);

	        // check values
	        if (isNaN(eta)){
	            this.eta = 'NULL';

	        // +/- Infinity --- NaN already handled
	        }else if (!isFinite(eta)){
	            this.eta = 'INF';

	        // > 10M s ? - set upper display limit ~115days (1e7/60/60/24)
	        }else if (eta > 1e7){
	            this.eta = 'INF';

	        // negative ?
	        }else if (eta < 0){
	            this.eta = 0;

	        }else {
	            // assign
	            this.eta = eta;
	        }
	    }
	}

	eta = ETA;
	return eta;
}

var terminal;
var hasRequiredTerminal;

function requireTerminal () {
	if (hasRequiredTerminal) return terminal;
	hasRequiredTerminal = 1;
	const _readline = require$$0;

	// low-level terminal interactions
	class Terminal{

	    constructor(outputStream){
	        this.stream = outputStream;

	        // default: line wrapping enabled
	        this.linewrap = true;

	        // current, relative y position
	        this.dy = 0;
	    }

	    // save cursor position + settings
	    cursorSave(){
	        if (!this.stream.isTTY){
	            return;
	        }

	        // save position
	        this.stream.write('\x1B7');
	    }

	    // restore last cursor position + settings
	    cursorRestore(){
	        if (!this.stream.isTTY){
	            return;
	        }

	        // restore cursor
	        this.stream.write('\x1B8');
	    }

	    // show/hide cursor
	    cursor(enabled){
	        if (!this.stream.isTTY){
	            return;
	        }

	        if (enabled){
	            this.stream.write('\x1B[?25h');
	        }else {
	            this.stream.write('\x1B[?25l');
	        }
	    }

	    // change cursor positionn
	    cursorTo(x=null, y=null){
	        if (!this.stream.isTTY){
	            return;
	        }

	        // move cursor absolute
	        _readline.cursorTo(this.stream, x, y);
	    }

	    // change relative cursor position
	    cursorRelative(dx=null, dy=null){
	        if (!this.stream.isTTY){
	            return;
	        }

	        // store current position
	        this.dy = this.dy + dy;
	        
	        // move cursor relative
	        _readline.moveCursor(this.stream, dx, dy);
	    }

	    // relative reset
	    cursorRelativeReset(){
	        if (!this.stream.isTTY){
	            return;
	        }

	        // move cursor to initial line
	        _readline.moveCursor(this.stream, 0, -this.dy);

	        // first char
	        _readline.cursorTo(this.stream, 0, null);

	        // reset counter
	        this.dy = 0;
	    }

	    // clear to the right from cursor
	    clearRight(){
	        if (!this.stream.isTTY){
	            return;
	        }

	        _readline.clearLine(this.stream, 1);
	    }

	    // clear the full line
	    clearLine(){
	        if (!this.stream.isTTY){
	            return;
	        }

	        _readline.clearLine(this.stream, 0);
	    }

	    // clear everyting beyond the current line
	    clearBottom(){
	        if (!this.stream.isTTY){
	            return;
	        }

	        _readline.clearScreenDown(this.stream);
	    }

	    // add new line; increment counter
	    newline(){
	        this.stream.write('\n');
	        this.dy++;
	    }

	    // write content to output stream
	    // @TODO use string-width to strip length
	    write(s, rawWrite=false){
	        // line wrapping enabled ? trim output
	        // this is just a fallback mechanism in case user enabled line-wrapping via options or set it to auto
	        if (this.linewrap === true && rawWrite === false){
	            this.stream.write(s.substr(0, this.getWidth()));

	        // standard behaviour with disabled linewrapping
	        }else {
	            this.stream.write(s);
	        }
	    }

	    // control line wrapping
	    lineWrapping(enabled){
	        if (!this.stream.isTTY){
	            return;
	        }

	        // store state
	        this.linewrap = enabled;
	        if (enabled){
	            this.stream.write('\x1B[?7h');
	        }else {
	            this.stream.write('\x1B[?7l');
	        }
	    }

	    // tty environment ?
	    isTTY(){
	        return (this.stream.isTTY === true);
	    }

	    // get terminal width
	    getWidth(){
	        // set max width to 80 in tty-mode and 200 in notty-mode
	        return this.stream.columns || (this.stream.isTTY ? 80 : 200);
	    }
	}

	terminal = Terminal;
	return terminal;
}

var stringWidth = {exports: {}};

var ansiRegex$1;
var hasRequiredAnsiRegex;

function requireAnsiRegex () {
	if (hasRequiredAnsiRegex) return ansiRegex$1;
	hasRequiredAnsiRegex = 1;

	ansiRegex$1 = ({onlyFirst = false} = {}) => {
		const pattern = [
			'[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)',
			'(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))'
		].join('|');

		return new RegExp(pattern, onlyFirst ? undefined : 'g');
	};
	return ansiRegex$1;
}

var stripAnsi$1;
var hasRequiredStripAnsi;

function requireStripAnsi () {
	if (hasRequiredStripAnsi) return stripAnsi$1;
	hasRequiredStripAnsi = 1;
	const ansiRegex = requireAnsiRegex();

	stripAnsi$1 = string => typeof string === 'string' ? string.replace(ansiRegex(), '') : string;
	return stripAnsi$1;
}

var isFullwidthCodePoint = {exports: {}};

/* eslint-disable yoda */

var hasRequiredIsFullwidthCodePoint;

function requireIsFullwidthCodePoint () {
	if (hasRequiredIsFullwidthCodePoint) return isFullwidthCodePoint.exports;
	hasRequiredIsFullwidthCodePoint = 1;

	const isFullwidthCodePoint$1 = codePoint => {
		if (Number.isNaN(codePoint)) {
			return false;
		}

		// Code points are derived from:
		// http://www.unix.org/Public/UNIDATA/EastAsianWidth.txt
		if (
			codePoint >= 0x1100 && (
				codePoint <= 0x115F || // Hangul Jamo
				codePoint === 0x2329 || // LEFT-POINTING ANGLE BRACKET
				codePoint === 0x232A || // RIGHT-POINTING ANGLE BRACKET
				// CJK Radicals Supplement .. Enclosed CJK Letters and Months
				(0x2E80 <= codePoint && codePoint <= 0x3247 && codePoint !== 0x303F) ||
				// Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A
				(0x3250 <= codePoint && codePoint <= 0x4DBF) ||
				// CJK Unified Ideographs .. Yi Radicals
				(0x4E00 <= codePoint && codePoint <= 0xA4C6) ||
				// Hangul Jamo Extended-A
				(0xA960 <= codePoint && codePoint <= 0xA97C) ||
				// Hangul Syllables
				(0xAC00 <= codePoint && codePoint <= 0xD7A3) ||
				// CJK Compatibility Ideographs
				(0xF900 <= codePoint && codePoint <= 0xFAFF) ||
				// Vertical Forms
				(0xFE10 <= codePoint && codePoint <= 0xFE19) ||
				// CJK Compatibility Forms .. Small Form Variants
				(0xFE30 <= codePoint && codePoint <= 0xFE6B) ||
				// Halfwidth and Fullwidth Forms
				(0xFF01 <= codePoint && codePoint <= 0xFF60) ||
				(0xFFE0 <= codePoint && codePoint <= 0xFFE6) ||
				// Kana Supplement
				(0x1B000 <= codePoint && codePoint <= 0x1B001) ||
				// Enclosed Ideographic Supplement
				(0x1F200 <= codePoint && codePoint <= 0x1F251) ||
				// CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane
				(0x20000 <= codePoint && codePoint <= 0x3FFFD)
			)
		) {
			return true;
		}

		return false;
	};

	isFullwidthCodePoint.exports = isFullwidthCodePoint$1;
	isFullwidthCodePoint.exports.default = isFullwidthCodePoint$1;
	return isFullwidthCodePoint.exports;
}

var emojiRegex;
var hasRequiredEmojiRegex;

function requireEmojiRegex () {
	if (hasRequiredEmojiRegex) return emojiRegex;
	hasRequiredEmojiRegex = 1;

	emojiRegex = function () {
	  // https://mths.be/emoji
	  return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
	};
	return emojiRegex;
}

var hasRequiredStringWidth;

function requireStringWidth () {
	if (hasRequiredStringWidth) return stringWidth.exports;
	hasRequiredStringWidth = 1;
	const stripAnsi = requireStripAnsi();
	const isFullwidthCodePoint = requireIsFullwidthCodePoint();
	const emojiRegex = requireEmojiRegex();

	const stringWidth$1 = string => {
		if (typeof string !== 'string' || string.length === 0) {
			return 0;
		}

		string = stripAnsi(string);

		if (string.length === 0) {
			return 0;
		}

		string = string.replace(emojiRegex(), '  ');

		let width = 0;

		for (let i = 0; i < string.length; i++) {
			const code = string.codePointAt(i);

			// Ignore control characters
			if (code <= 0x1F || (code >= 0x7F && code <= 0x9F)) {
				continue;
			}

			// Ignore combining characters
			if (code >= 0x300 && code <= 0x36F) {
				continue;
			}

			// Surrogates
			if (code > 0xFFFF) {
				i++;
			}

			width += isFullwidthCodePoint(code) ? 2 : 1;
		}

		return width;
	};

	stringWidth.exports = stringWidth$1;
	// TODO: remove this in the next major version
	stringWidth.exports.default = stringWidth$1;
	return stringWidth.exports;
}

var formatValue;
var hasRequiredFormatValue;

function requireFormatValue () {
	if (hasRequiredFormatValue) return formatValue;
	hasRequiredFormatValue = 1;
	// default value format (apply autopadding)

	// format valueset
	formatValue = function formatValue(v, options, type){
	    // no autopadding ? passthrough
	    if (options.autopadding !== true){
	        return v;
	    }

	    // padding
	    function autopadding(value, length){
	        return (options.autopaddingChar + value).slice(-3);
	    }

	    switch (type){
	        case 'percentage':
	            return autopadding(v);

	        default:
	            return v;
	    }
	};
	return formatValue;
}

var formatBar;
var hasRequiredFormatBar;

function requireFormatBar () {
	if (hasRequiredFormatBar) return formatBar;
	hasRequiredFormatBar = 1;
	// format bar
	formatBar = function formatBar(progress, options){
	    // calculate barsize
	    const completeSize = Math.round(progress*options.barsize);
	    const incompleteSize = options.barsize-completeSize;

	   // generate bar string by stripping the pre-rendered strings
	   return   options.barCompleteString.substr(0, completeSize) +
	            options.barGlue +
	            options.barIncompleteString.substr(0, incompleteSize);
	};
	return formatBar;
}

var formatTime;
var hasRequiredFormatTime;

function requireFormatTime () {
	if (hasRequiredFormatTime) return formatTime;
	hasRequiredFormatTime = 1;
	// default time format

	// format a number of seconds into hours and minutes as appropriate
	formatTime = function formatTime(t, options, roundToMultipleOf){
	    function round(input) {
	        if (roundToMultipleOf) {
	            return roundToMultipleOf * Math.round(input / roundToMultipleOf);
	        } else {
	            return input
	        }
	    }

	    // leading zero padding
	    function autopadding(v){
	        return (options.autopaddingChar + v).slice(-2);
	    }

	    // > 1h ?
	    if (t > 3600) {
	        return autopadding(Math.floor(t / 3600)) + 'h' + autopadding(round((t % 3600) / 60)) + 'm';

	    // > 60s ?
	    } else if (t > 60) {
	        return autopadding(Math.floor(t / 60)) + 'm' + autopadding(round((t % 60))) + 's';

	    // > 10s ?
	    } else if (t > 10) {
	        return autopadding(round(t)) + 's';

	    // default: don't apply round to multiple
	    }else {
	        return autopadding(t) + 's';
	    }
	};
	return formatTime;
}

var formatter;
var hasRequiredFormatter;

function requireFormatter () {
	if (hasRequiredFormatter) return formatter;
	hasRequiredFormatter = 1;
	const _stringWidth = requireStringWidth();
	const _defaultFormatValue = requireFormatValue();
	const _defaultFormatBar = requireFormatBar();
	const _defaultFormatTime = requireFormatTime();

	// generic formatter
	formatter = function defaultFormatter(options, params, payload){

	    // copy format string
	    let s = options.format;

	    // custom time format set ?
	    const formatTime = options.formatTime || _defaultFormatTime;
	    
	    // custom value format set ?
	    const formatValue = options.formatValue || _defaultFormatValue;

	    // custom bar format set ?
	    const formatBar = options.formatBar || _defaultFormatBar;

	    // calculate progress in percent
	    const percentage =  Math.floor(params.progress*100) + '';

	    // bar stopped and stopTime set ?
	    const stopTime = params.stopTime || Date.now();

	    // calculate elapsed time
	    const elapsedTime = Math.round((stopTime - params.startTime)/1000);

	    // merges data from payload and calculated
	    const context = Object.assign({}, payload, {
	        bar:                    formatBar(params.progress, options),

	        percentage:             formatValue(percentage, options, 'percentage'),
	        total:                  formatValue(params.total, options, 'total'),
	        value:                  formatValue(params.value, options, 'value'),

	        eta:                    formatValue(params.eta, options, 'eta'),
	        eta_formatted:          formatTime(params.eta, options, 5),
	        
	        duration:               formatValue(elapsedTime, options, 'duration'),
	        duration_formatted:     formatTime(elapsedTime, options, 1)
	    });

	    // assign placeholder tokens
	    s = s.replace(/\{(\w+)\}/g, function(match, key){
	        // key exists within payload/context
	        if (typeof context[key] !== 'undefined') {
	            return context[key];
	        }

	        // no changes to unknown values
	        return match;
	    });

	    // calculate available whitespace (2 characters margin of error)
	    const fullMargin = Math.max(0, params.maxWidth - _stringWidth(s) -2);
	    const halfMargin = Math.floor(fullMargin / 2);

	    // distribute available whitespace according to position
	    switch (options.align) {

	        // fill start-of-line with whitespaces
	        case 'right':
	            s = (fullMargin > 0) ? ' '.repeat(fullMargin) + s : s;
	            break;

	        // distribute whitespaces to left+right
	        case 'center':
	            s = (halfMargin > 0) ? ' '.repeat(halfMargin) + s : s;
	            break;
	    }

	    return s;
	};
	return formatter;
}

var options;
var hasRequiredOptions;

function requireOptions () {
	if (hasRequiredOptions) return options;
	hasRequiredOptions = 1;
	// utility to merge defaults
	function mergeOption(v, defaultValue){
	    if (typeof v === 'undefined' || v === null){
	        return defaultValue;
	    }else {
	        return v;
	    }
	}

	options = {
	    // set global options
	    parse: function parse(rawOptions, preset){

	        // options storage
	        const options = {};

	        // merge preset
	        const opt = Object.assign({}, preset, rawOptions);

	        // the max update rate in fps (redraw will only triggered on value change)
	        options.throttleTime = 1000 / (mergeOption(opt.fps, 10));

	        // the output stream to write on
	        options.stream = mergeOption(opt.stream, process.stderr);

	        // external terminal provided ?
	        options.terminal = mergeOption(opt.terminal, null);

	        // clear on finish ?
	        options.clearOnComplete = mergeOption(opt.clearOnComplete, false);

	        // stop on finish ?
	        options.stopOnComplete = mergeOption(opt.stopOnComplete, false);

	        // size of the progressbar in chars
	        options.barsize = mergeOption(opt.barsize, 40);

	        // position of the progress bar - 'left' (default), 'right' or 'center'
	        options.align = mergeOption(opt.align, 'left');

	        // hide the cursor ?
	        options.hideCursor = mergeOption(opt.hideCursor, false);

	        // disable linewrapping ?
	        options.linewrap = mergeOption(opt.linewrap, false);

	        // glue sequence (control chars) between bar elements ?
	        options.barGlue = mergeOption(opt.barGlue, '');

	        // bar chars
	        options.barCompleteChar = mergeOption(opt.barCompleteChar, '=');
	        options.barIncompleteChar = mergeOption(opt.barIncompleteChar, '-');

	        // the bar format
	        options.format = mergeOption(opt.format, 'progress [{bar}] {percentage}% | ETA: {eta}s | {value}/{total}');

	        // external time-format provided ?
	        options.formatTime = mergeOption(opt.formatTime, null);

	        // external value-format provided ?
	        options.formatValue = mergeOption(opt.formatValue, null);

	        // external bar-format provided ?
	        options.formatBar = mergeOption(opt.formatBar, null);

	        // the number of results to average ETA over
	        options.etaBufferLength = mergeOption(opt.etaBuffer, 10);

	        // automatic eta updates based on fps
	        options.etaAsynchronousUpdate = mergeOption(opt.etaAsynchronousUpdate, false);

	        // progress calculation relative to start value ? default start at 0
	        options.progressCalculationRelative = mergeOption(opt.progressCalculationRelative, false);

	        // allow synchronous updates ?
	        options.synchronousUpdate = mergeOption(opt.synchronousUpdate, true);

	        // notty mode
	        options.noTTYOutput = mergeOption(opt.noTTYOutput, false);

	        // schedule - 2s
	        options.notTTYSchedule = mergeOption(opt.notTTYSchedule, 2000);
	        
	        // emptyOnZero - false
	        options.emptyOnZero = mergeOption(opt.emptyOnZero, false);

	        // force bar redraw even if progress did not change
	        options.forceRedraw = mergeOption(opt.forceRedraw, false);

	        // automated padding to fixed width ?
	        options.autopadding = mergeOption(opt.autopadding, false);

	        // stop bar on SIGINT/SIGTERM to restore cursor settings ?
	        options.gracefulExit = mergeOption(opt.gracefulExit, false);

	        return options;
	    },

	    // derived options: instance specific, has to be created for every bar element
	    assignDerivedOptions: function assignDerivedOptions(options){
	        // pre-render bar strings (performance)
	        options.barCompleteString = options.barCompleteChar.repeat(options.barsize + 1);
	        options.barIncompleteString = options.barIncompleteChar.repeat(options.barsize + 1);

	        // autopadding character - empty in case autopadding is disabled
	        options.autopaddingChar = options.autopadding ? mergeOption(options.autopaddingChar, '   ') : '';

	        return options;
	    }
	};
	return options;
}

var genericBar;
var hasRequiredGenericBar;

function requireGenericBar () {
	if (hasRequiredGenericBar) return genericBar;
	hasRequiredGenericBar = 1;
	const _ETA = requireEta();
	const _Terminal = requireTerminal();
	const _formatter = requireFormatter();
	const _options = requireOptions();
	const _EventEmitter = require$$0$1;

	// Progress-Bar constructor
	genericBar = class GenericBar extends _EventEmitter{

	    constructor(options){
	        super();

	        // store options and assign derived ones (instance specific)
	        this.options = _options.assignDerivedOptions(options);

	        // store terminal instance
	        this.terminal = (this.options.terminal) ? this.options.terminal : new _Terminal(this.options.stream);

	        // the current bar value
	        this.value = 0;

	        // bar start value (used for progress calculation)
	        this.startValue = 0;

	        // the end value of the bar
	        this.total = 100;

	        // last drawn string - only render on change!
	        this.lastDrawnString = null;

	        // start time (used for eta calculation)
	        this.startTime = null;

	        // stop time (used for duration calculation)
	        this.stopTime = null;

	        // last update time
	        this.lastRedraw = Date.now();

	        // default eta calculator (will be re-create on start)
	        this.eta = new _ETA(this.options.etaBufferLength, 0, 0);

	        // payload data
	        this.payload = {};

	        // progress bar active ?
	        this.isActive = false;

	        // use default formatter or custom one ?
	        this.formatter = (typeof this.options.format === 'function') ? this.options.format : _formatter;
	    }

	    // internal render function
	    render(forceRendering=false){

	        // formatter params
	        const params = {
	            progress: this.getProgress(),
	            eta: this.eta.getTime(),
	            startTime: this.startTime,
	            stopTime: this.stopTime,
	            total: this.total,
	            value: this.value,
	            maxWidth: this.terminal.getWidth()
	        };

	        // automatic eta update ? (long running processes)
	        if (this.options.etaAsynchronousUpdate){
	            this.updateETA();
	        }

	        // format string
	        const s = this.formatter(this.options, params, this.payload);

	        const forceRedraw = forceRendering || this.options.forceRedraw
	            // force redraw in notty-mode!
	            || (this.options.noTTYOutput && !this.terminal.isTTY());

	        // string changed ? only trigger redraw on change!
	        if (forceRedraw || this.lastDrawnString != s){
	            // trigger event
	            this.emit('redraw-pre');

	            // set cursor to start of line
	            this.terminal.cursorTo(0, null);

	            // write output
	            this.terminal.write(s);

	            // clear to the right from cursor
	            this.terminal.clearRight();

	            // store string
	            this.lastDrawnString = s;

	            // set last redraw time
	            this.lastRedraw = Date.now();

	            // trigger event
	            this.emit('redraw-post');
	        }
	    }

	    // start the progress bar
	    start(total, startValue, payload){
	        // set initial values
	        this.value = startValue || 0;
	        this.total = (typeof total !== 'undefined' && total >= 0) ? total : 100;

	        // set start value for progress calculation
	        this.startValue = (startValue || 0);

	        // store payload (optional)
	        this.payload = payload || {};

	        // store start time for duration+eta calculation
	        this.startTime = Date.now();

	        // reset stop time for 're-start' scenario (used for duration calculation)
	        this.stopTime = null;

	        // reset string line buffer (redraw detection)
	        this.lastDrawnString = '';

	        // initialize eta buffer
	        this.eta = new _ETA(this.options.etaBufferLength, this.startTime, this.value);

	        // set flag
	        this.isActive = true;

	        // start event
	        this.emit('start', total, startValue);
	    }

	    // stop the bar
	    stop(){
	        // set flag
	        this.isActive = false;
	        
	        // store stop timestamp to get total duration
	        this.stopTime = Date.now();

	        // stop event
	        this.emit('stop', this.total, this.value);
	    }

	    // update the bar value
	    // update(value, payload)
	    // update(payload)
	    update(arg0, arg1 = {}){
	        // value set ?
	        // update(value, [payload]);
	        if (typeof arg0 === 'number') {
	            // update value
	            this.value = arg0;

	            // add new value; recalculate eta
	            this.eta.update(Date.now(), arg0, this.total);
	        }

	        // extract payload
	        // update(value, payload)
	        // update(payload)
	        const payloadData = ((typeof arg0 === 'object') ? arg0 : arg1) || {};

	        // update event (before stop() is called)
	        this.emit('update', this.total, this.value);

	        // merge payload
	        for (const key in payloadData){
	            this.payload[key] = payloadData[key];
	        }

	        // limit reached ? autostop set ?
	        if (this.value >= this.getTotal() && this.options.stopOnComplete) {
	            this.stop();
	        }
	    }

	    // calculate the actual progress value
	    getProgress(){
	        // calculate the normalized current progress
	        let progress = (this.value/this.total);

	        // use relative progress calculation ? range between startValue and total is then used as 100%
	        // startValue (offset) is ignored for calculations
	        if (this.options.progressCalculationRelative){
	            progress = (this.value-this.startValue)/(this.total-this.startValue);
	        }

	        // handle NaN Errors caused by total=0. Set to complete in this case
	        if (isNaN(progress)){
	            progress = (this.options && this.options.emptyOnZero) ? 0.0 : 1.0;
	        }

	        // limiter
	        progress = Math.min(Math.max(progress, 0.0), 1.0);

	        return progress;
	    }

	    // update the bar value
	    // increment(delta, payload)
	    // increment(payload)
	    increment(arg0 = 1, arg1 = {}){
	        // increment([payload]) => step=1
	        // handle the use case when `step` is omitted but payload is passed
	        if (typeof arg0 === 'object') {
	            this.update(this.value + 1, arg0);
	        
	        // increment([step=1], [payload={}])
	        }else {
	            this.update(this.value + arg0, arg1);
	        }
	    }

	    // get the total (limit) value
	    getTotal(){
	        return this.total;
	    }

	    // set the total (limit) value
	    setTotal(total){
	        if (typeof total !== 'undefined' && total >= 0){
	            this.total = total;
	        }
	    }

	    // force eta calculation update (long running processes)
	    updateETA(){
	        // add new value; recalculate eta
	        this.eta.update(Date.now(), this.value, this.total);
	    }
	};
	return genericBar;
}

var singleBar;
var hasRequiredSingleBar;

function requireSingleBar () {
	if (hasRequiredSingleBar) return singleBar;
	hasRequiredSingleBar = 1;
	const _GenericBar = requireGenericBar();
	const _options = requireOptions();

	// Progress-Bar constructor
	singleBar = class SingleBar extends _GenericBar{

	    constructor(options, preset){
	        super(_options.parse(options, preset));

	        // the update timer
	        this.timer = null;

	        // disable synchronous updates in notty mode
	        if (this.options.noTTYOutput && this.terminal.isTTY() === false){
	            this.options.synchronousUpdate = false;
	        }

	        // update interval
	        this.schedulingRate = (this.terminal.isTTY() ? this.options.throttleTime : this.options.notTTYSchedule);

	        // callback used for gracefulExit
	        this.sigintCallback = null;
	    }

	    // internal render function
	    render(){
	        // stop timer
	        if (this.timer){
	            clearTimeout(this.timer);
	            this.timer = null;
	        }

	        // run internal rendering
	        super.render();

	        // add new line in notty mode!
	        if (this.options.noTTYOutput && this.terminal.isTTY() === false){
	            this.terminal.newline();
	        }

	        // next update
	        this.timer = setTimeout(this.render.bind(this), this.schedulingRate);
	    }

	    update(current, payload){
	        // timer inactive ?
	        if (!this.timer) {
	            return;
	        }

	        super.update(current, payload);

	        // trigger synchronous update ?
	        // check for throttle time 
	        if (this.options.synchronousUpdate && (this.lastRedraw + this.options.throttleTime*2) < Date.now()){
	            // force update
	            this.render();
	        }
	    }

	    // start the progress bar
	    start(total, startValue, payload){
	        // progress updates are only visible in TTY mode!
	        if (this.options.noTTYOutput === false && this.terminal.isTTY() === false){
	            return;
	        }

	        // add handler to restore cursor settings (stop the bar) on SIGINT/SIGTERM ?
	        if (this.sigintCallback === null && this.options.gracefulExit){
	            this.sigintCallback = this.stop.bind(this);
	            process.once('SIGINT', this.sigintCallback);
	            process.once('SIGTERM', this.sigintCallback);
	        }

	        // save current cursor settings
	        this.terminal.cursorSave();

	        // hide the cursor ?
	        if (this.options.hideCursor === true){
	            this.terminal.cursor(false);
	        }

	        // disable line wrapping ?
	        if (this.options.linewrap === false){
	            this.terminal.lineWrapping(false);
	        }

	        // initialize bar
	        super.start(total, startValue, payload);

	        // redraw on start!
	        this.render();
	    }

	    // stop the bar
	    stop(){
	        // timer inactive ?
	        if (!this.timer) {
	            return;
	        }
	        
	        // remove sigint listener
	        if (this.sigintCallback){
	            process.removeListener('SIGINT', this.sigintCallback);
	            process.removeListener('SIGTERM', this.sigintCallback);
	            this.sigintCallback = null;
	        }

	        // trigger final rendering
	        this.render();

	        // restore state
	        super.stop();

	        // stop timer
	        clearTimeout(this.timer);
	        this.timer = null;

	        // cursor hidden ?
	        if (this.options.hideCursor === true){
	            this.terminal.cursor(true);
	        }

	        // re-enable line wrapping ?
	        if (this.options.linewrap === false){
	            this.terminal.lineWrapping(true);
	        }

	        // restore cursor on complete (position + settings)
	        this.terminal.cursorRestore();

	        // clear line on complete ?
	        if (this.options.clearOnComplete){
	            this.terminal.cursorTo(0, null);
	            this.terminal.clearLine();
	        }else {
	            // new line on complete
	            this.terminal.newline();
	        }
	    }
	};
	return singleBar;
}

var multiBar;
var hasRequiredMultiBar;

function requireMultiBar () {
	if (hasRequiredMultiBar) return multiBar;
	hasRequiredMultiBar = 1;
	const _Terminal = requireTerminal();
	const _BarElement = requireGenericBar();
	const _options = requireOptions();
	const _EventEmitter = require$$0$1;

	// Progress-Bar constructor
	multiBar = class MultiBar extends _EventEmitter{

	    constructor(options, preset){
	        super();

	        // list of bars
	        this.bars = [];

	        // parse+store options
	        this.options = _options.parse(options, preset);

	        // disable synchronous updates
	        this.options.synchronousUpdate = false;

	        // store terminal instance
	        this.terminal = (this.options.terminal) ? this.options.terminal : new _Terminal(this.options.stream);

	        // the update timer
	        this.timer = null;

	        // progress bar active ?
	        this.isActive = false;

	        // update interval
	        this.schedulingRate = (this.terminal.isTTY() ? this.options.throttleTime : this.options.notTTYSchedule);

	        // logging output buffer
	        this.loggingBuffer = [];

	        // callback used for gracefulExit
	        this.sigintCallback = null;
	    }

	    // add a new bar to the stack
	    create(total, startValue, payload, barOptions={}){
	        // create new bar element and merge global options + overrides
	        // use the same global terminal instance for all instances
	        const bar = new _BarElement(Object.assign(
	            {}, 

	            // global options
	            this.options, 

	            // terminal instance
	            {
	                terminal: this.terminal
	            },

	            // overrides
	            barOptions,
	        ));

	        // store bar
	        this.bars.push(bar);

	        // progress updates are only visible in TTY mode!
	        if (this.options.noTTYOutput === false && this.terminal.isTTY() === false){
	            return bar;
	        }

	        // add handler to restore cursor settings (stop the bar) on SIGINT/SIGTERM ?
	        if (this.sigintCallback === null && this.options.gracefulExit){
	            this.sigintCallback = this.stop.bind(this);
	            process.once('SIGINT', this.sigintCallback);
	            process.once('SIGTERM', this.sigintCallback);
	        }
	        
	        // multiprogress already active ?
	        if (!this.isActive){
	            // hide the cursor ?
	            if (this.options.hideCursor === true){
	                this.terminal.cursor(false);
	            }

	            // disable line wrapping ?
	            if (this.options.linewrap === false){
	                this.terminal.lineWrapping(false);
	            }
	    
	            // initialize update timer
	            this.timer = setTimeout(this.update.bind(this), this.schedulingRate);
	        }

	        // set flag
	        this.isActive = true;

	        // start progress bar
	        bar.start(total, startValue, payload);

	        // trigger event
	        this.emit('start');

	        // return new instance
	        return bar;
	    }

	    // remove a bar from the stack
	    remove(bar){
	        // find element
	        const index = this.bars.indexOf(bar);

	        // element found ?
	        if (index < 0){
	            return false;
	        }

	        // remove element
	        this.bars.splice(index, 1);

	        // force update
	        this.update();

	        // clear bottom
	        this.terminal.newline();
	        this.terminal.clearBottom();

	        return true;
	    }

	    // internal update routine
	    update(){
	        // stop timer
	        if (this.timer){
	            clearTimeout(this.timer);
	            this.timer = null;
	        }

	        // trigger event
	        this.emit('update-pre');
	        
	        // reset cursor
	        this.terminal.cursorRelativeReset();

	        // trigger event
	        this.emit('redraw-pre');

	        // content within logging buffer ?
	        if (this.loggingBuffer.length > 0){
	            this.terminal.clearLine();

	            // flush logging buffer and write content to terminal
	            while (this.loggingBuffer.length > 0){
	                this.terminal.write(this.loggingBuffer.shift(), true);
	            }
	        }

	        // update each bar
	        for (let i=0; i< this.bars.length; i++){
	            // add new line ?
	            if (i > 0){
	                this.terminal.newline();
	            }

	            // render
	            this.bars[i].render();
	        }

	        // trigger event
	        this.emit('redraw-post');

	        // add new line in notty mode!
	        if (this.options.noTTYOutput && this.terminal.isTTY() === false){
	            this.terminal.newline();
	            this.terminal.newline();
	        }

	        // next update
	        this.timer = setTimeout(this.update.bind(this), this.schedulingRate);

	        // trigger event
	        this.emit('update-post');

	        // stop if stopOnComplete and all bars stopped
	        if (this.options.stopOnComplete && !this.bars.find(bar => bar.isActive)) {
	            this.stop();
	        }
	    }

	    stop(){

	        // stop timer
	        clearTimeout(this.timer);
	        this.timer = null;

	        // remove sigint listener
	        if (this.sigintCallback){
	            process.removeListener('SIGINT', this.sigintCallback);
	            process.removeListener('SIGTERM', this.sigintCallback);
	            this.sigintCallback = null;
	        }

	        // set flag
	        this.isActive = false;

	        // cursor hidden ?
	        if (this.options.hideCursor === true){
	            this.terminal.cursor(true);
	        }

	        // re-enable line wrpaping ?
	        if (this.options.linewrap === false){
	            this.terminal.lineWrapping(true);
	        }

	        // reset cursor
	        this.terminal.cursorRelativeReset();

	        // trigger event
	        this.emit('stop-pre-clear');

	        // clear line on complete ?
	        if (this.options.clearOnComplete){
	            // clear all bars
	            this.terminal.clearBottom();
	            
	        // or show final progress ?
	        }else {
	            // update each bar
	            for (let i=0; i< this.bars.length; i++){
	                // add new line ?
	                if (i > 0){
	                    this.terminal.newline();
	                }

	                // trigger final rendering
	                this.bars[i].render();

	                // stop
	                this.bars[i].stop();
	            }

	            // new line on complete
	            this.terminal.newline();
	        }

	        // trigger event
	        this.emit('stop');
	    }

	    log(s){
	        // push content into logging buffer
	        this.loggingBuffer.push(s);
	    }
	};
	return multiBar;
}

var legacy;
var hasRequiredLegacy;

function requireLegacy () {
	if (hasRequiredLegacy) return legacy;
	hasRequiredLegacy = 1;
	// cli-progress legacy style as of 1.x
	legacy = {
	    format: 'progress [{bar}] {percentage}% | ETA: {eta}s | {value}/{total}',
	    barCompleteChar: '=',
	    barIncompleteChar: '-'
	};
	return legacy;
}

var shadesClassic;
var hasRequiredShadesClassic;

function requireShadesClassic () {
	if (hasRequiredShadesClassic) return shadesClassic;
	hasRequiredShadesClassic = 1;
	// cli-progress legacy style as of 1.x
	shadesClassic = {
	    format: ' {bar} {percentage}% | ETA: {eta}s | {value}/{total}',
	    barCompleteChar: '\u2588',
	    barIncompleteChar: '\u2591'
	};
	return shadesClassic;
}

var shadesGrey;
var hasRequiredShadesGrey;

function requireShadesGrey () {
	if (hasRequiredShadesGrey) return shadesGrey;
	hasRequiredShadesGrey = 1;
	// cli-progress legacy style as of 1.x
	shadesGrey = {
	    format: ' \u001b[90m{bar}\u001b[0m {percentage}% | ETA: {eta}s | {value}/{total}',
	    barCompleteChar: '\u2588',
	    barIncompleteChar: '\u2591'
	};
	return shadesGrey;
}

var rect;
var hasRequiredRect;

function requireRect () {
	if (hasRequiredRect) return rect;
	hasRequiredRect = 1;
	rect = {
	    format: ' {bar}\u25A0 {percentage}% | ETA: {eta}s | {value}/{total}',
	    barCompleteChar: '\u25A0',
	    barIncompleteChar: ' '
	};
	return rect;
}

var presets;
var hasRequiredPresets;

function requirePresets () {
	if (hasRequiredPresets) return presets;
	hasRequiredPresets = 1;
	const _legacy = requireLegacy();
	const _shades_classic = requireShadesClassic();
	const _shades_grey = requireShadesGrey();
	const _rect = requireRect();

	presets = {
	    legacy: _legacy,
	    shades_classic: _shades_classic,
	    shades_grey: _shades_grey,
	    rect: _rect
	};
	return presets;
}

var cliProgress;
var hasRequiredCliProgress;

function requireCliProgress () {
	if (hasRequiredCliProgress) return cliProgress;
	hasRequiredCliProgress = 1;
	const _SingleBar = requireSingleBar();
	const _MultiBar = requireMultiBar();
	const _Presets = requirePresets();
	const _Formatter = requireFormatter();
	const _defaultFormatValue = requireFormatValue();
	const _defaultFormatBar = requireFormatBar();
	const _defaultFormatTime = requireFormatTime();

	// sub-module access
	cliProgress = {
	    Bar: _SingleBar,
	    SingleBar: _SingleBar,
	    MultiBar: _MultiBar,
	    Presets: _Presets,
	    Format: {
	        Formatter: _Formatter,
	        BarFormat: _defaultFormatBar,
	        ValueFormat: _defaultFormatValue,
	        TimeFormat: _defaultFormatTime
	    }
	};
	return cliProgress;
}

var cliProgressExports = requireCliProgress();

const FIG_CHECK = a.green("\u25C9");
const FIG_UNCHECK = a.gray("\u25CC");
const FIG_POINTER = a.cyan("\u276F ");
const FIG_NO_POINTER = "  ";
const FIG_BLOCK = a.bold.dim.gray("\u2503");
function ansiRegex({ onlyFirst = false } = {}) {
  const pattern = [
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
  ].join("|");
  return new RegExp(pattern, onlyFirst ? void 0 : "g");
}
const stripAnsi = (str) => typeof str === "string" ? str.replace(ansiRegex(), "") : str;
function visualLength(str) {
  if (str === "")
    return 0;
  str = stripAnsi(str);
  let width = 0;
  for (let i = 0; i < str.length; i++) {
    const code = str.codePointAt(i);
    if (!code)
      continue;
    if (code <= 31 || code >= 127 && code <= 159)
      continue;
    if (code >= 768 && code <= 879)
      continue;
    if (code > 65535)
      i++;
    width += 1;
  }
  return width;
}
function visualPadStart(str, pad, char = " ") {
  return str.padStart(pad - visualLength(str) + str.length, char);
}
function visualPadEnd(str, pad, char = " ") {
  return str.padEnd(pad - visualLength(str) + str.length, char);
}
function formatTable(lines, align, spaces = "  ") {
  const maxLen = [];
  lines.forEach((line) => {
    line.forEach((char, i) => {
      const len = visualLength(char);
      if (!maxLen[i] || maxLen[i] < len)
        maxLen[i] = len;
    });
  });
  return lines.map((line) => line.map((chars, i) => {
    const pad = align[i] === "R" ? visualPadStart : visualPadEnd;
    return pad(chars, maxLen[i]);
  }).join(spaces));
}
function colorizeVersionDiff(from, to, hightlightRange = true) {
  let leadingWildcard = "";
  let fromLeadingWildcard = "";
  if (/^[~^]/.test(to)) {
    leadingWildcard = to[0];
    to = to.slice(1);
  }
  if (/^[~^]/.test(from)) {
    fromLeadingWildcard = from[0];
    from = from.slice(1);
  }
  const partsToColor = to.split(".");
  const partsToCompare = from.split(".");
  let i = partsToColor.findIndex((part, i2) => part !== partsToCompare[i2]);
  i = i >= 0 ? i : partsToColor.length;
  let diffType = null;
  try {
    diffType = getDiff(new semverExports.SemVer(from), new semverExports.SemVer(to));
  } catch {
  }
  const color = DiffColorMap[diffType || "patch"];
  const middot = i > 0 && i < partsToColor.length ? "." : "";
  const leadingColor = leadingWildcard === fromLeadingWildcard || !hightlightRange ? "gray" : "yellow";
  return a[leadingColor](leadingWildcard) + partsToColor.slice(0, i).join(".") + middot + a[color](partsToColor.slice(i).join(".")).trim();
}
function createSliceRender() {
  const buffer = [];
  return {
    push(...lines) {
      buffer.push(...lines);
    },
    render(selectedDepIndex) {
      let {
        rows: remainHeight,
        columns: availableWidth
      } = process$1.stdout;
      const lines = buffer.length < remainHeight - 1 ? buffer : [...buffer, { content: a.yellow("  -- END --") }];
      remainHeight -= 1;
      let i = 0;
      while (i < lines.length) {
        const curr = lines[i];
        if (curr.fixed) {
          console.log(curr.content);
          remainHeight -= 1;
          i++;
        } else {
          break;
        }
      }
      const remainLines = lines.slice(i);
      let focusedLineIndex = 0;
      let depIndex = 0;
      for (const line of remainLines) {
        if (line.content.includes(FIG_CHECK) || line.content.includes(FIG_UNCHECK))
          depIndex += 1;
        if (depIndex === selectedDepIndex)
          break;
        else
          focusedLineIndex += 1;
      }
      let slice;
      if (remainHeight < 1 || remainLines.length === 0 || remainLines.length <= remainHeight || lines.some((x) => Math.ceil(visualLength(x.content) / availableWidth) > 1)) {
        slice = remainLines;
      } else {
        const half = Math.floor((remainHeight - 1) / 2);
        const f = focusedLineIndex - half;
        const b = focusedLineIndex + remainHeight - half - remainLines.length;
        const start = Math.max(0, b <= 0 ? f : f - b);
        slice = remainLines.slice(start, start + remainHeight);
      }
      console.log(slice.map((x) => x.content).join("\n"));
    }
  };
}
function colorizeNodeCompatibility(nodeVersionCompatibility) {
  if (!nodeVersionCompatibility)
    return "";
  return nodeVersionCompatibility.compatible ? a.dim(nodeVersionCompatibility.semver) : a.red(nodeVersionCompatibility.semver);
}

function createMultiProgressBar() {
  return new cliProgressExports.MultiBar({
    clearOnComplete: true,
    hideCursor: true,
    format: `{type} {bar} {value}/{total} ${a.gray("{name}")}`,
    linewrap: false,
    barsize: 40
  }, cliProgressExports.Presets.shades_grey);
}

const msPerMinute = 60 * 1e3;
const msPerHour = msPerMinute * 60;
const msPerDay = msPerHour * 24;
const msPerMonth = msPerDay * 30;
const msPerYear = msPerDay * 365;
function toDate(date) {
  return +new Date(date);
}
function timeDifference(from, to = +/* @__PURE__ */ new Date()) {
  if (!from)
    return "";
  if (typeof from === "string")
    from = toDate(from);
  const elapsed = to - from;
  if (elapsed < msPerDay)
    return a.gray("\u2A7D1d");
  else if (elapsed < msPerMonth)
    return a.green`~${Math.round(elapsed / msPerDay)}d`;
  else if (elapsed < msPerYear)
    return a.yellow`~${Math.round(elapsed / msPerMonth)}mo`;
  else
    return a.red`~${+(elapsed / msPerYear).toFixed(1)}y`;
}

const SORT_CHOICES = [
  "time-asc",
  "time-desc",
  "diff-asc",
  "diff-desc",
  "name-asc",
  "name-desc"
];
function parseSortOption(option) {
  return option.split("-");
}
function sortDepChanges(changes, option, grouped) {
  const [sortKey, order = "asc"] = parseSortOption(option);
  let sorted = changes.concat().sort((a, b) => {
    if (sortKey === "time") {
      if (a.targetVersionTime && b.targetVersionTime) {
        const at = toDate(a.targetVersionTime);
        const bt = toDate(b.targetVersionTime);
        return bt - at;
      }
    } else if (sortKey === "name") {
      return a.name.localeCompare(b.name);
    } else if (sortKey === "diff") {
      return DiffMap[a.diff || ""] - DiffMap[b.diff || ""];
    }
    return 0;
  });
  sorted = order === "desc" ? sorted.reverse() : sorted;
  if (grouped) {
    const order2 = Object.keys(DependenciesTypeShortMap);
    sorted = sorted.sort((a, b) => {
      const ai = order2.indexOf(a.source);
      const bi = order2.indexOf(b.source);
      return ai - bi;
    });
  }
  return sorted;
}

function renderChange(change, interactive, grouped = false, timediff = true, nodecompat = true) {
  const update = change.update && (!interactive || interactive.isChecked(change));
  const pre = interactive ? [
    interactive.isSelected(change) ? FIG_POINTER : FIG_NO_POINTER,
    interactive.isChecked(change) ? FIG_CHECK : FIG_UNCHECK
  ].join("") : " ";
  let name = change.name;
  if (change.aliasName)
    name = a.dim`${change.aliasName} ← ` + change.name;
  return [
    `${pre} ${update ? change.provenanceDowngraded ? a.bgRed(name) : name : a.gray(name)}`,
    grouped ? "" : a.gray(DependenciesTypeShortMap[change.source]),
    timediff ? timeDifference(change.currentVersionTime) : "",
    a.gray(change.currentVersion),
    update ? a.dim.gray("\u2192") : "",
    update ? colorizeVersionDiff(change.currentVersion, change.targetVersion) : a.gray.strikethrough(change.targetVersion),
    update && timediff ? timeDifference(change.targetVersionTime) : "",
    change.latestVersionAvailable && semver.minVersion(change.targetVersion).toString() !== change.latestVersionAvailable ? a.dim.magenta`(${change.latestVersionAvailable} available)` : "",
    nodecompat ? colorizeNodeCompatibility(change.nodeCompatibleVersion) : "",
    change.provenanceDowngraded ? `\u{1F9A0} ${a.bold.green(formatProvenance(change.currentProvenance))} ${a.dim.gray`→`} ${a.bold.red(formatProvenance(change.targetProvenance))}` : ""
  ];
}
function formatProvenance(value) {
  return value === "trustedPublisher" ? "trusted" : value ? "provenance" : "untrusted";
}
function renderChanges(pkg, options, interactive) {
  const { resolved, relative: filepath } = pkg;
  const lines = [];
  const errLines = [];
  let changes = options.all ? resolved : resolved.filter((i) => i.update);
  const {
    sort = "diff-asc",
    group = true
  } = options;
  if (changes.length) {
    const diffCounts = {};
    changes.filter((dep) => !interactive || interactive.isChecked(dep)).forEach(({ diff }) => {
      if (!diff)
        return;
      if (!diffCounts[diff])
        diffCounts[diff] = 0;
      diffCounts[diff] += 1;
    });
    changes = sortDepChanges(changes, sort, group);
    const diffEntries = Object.keys(diffCounts).length ? Object.entries(diffCounts).map(([key, value]) => `${a[DiffColorMap[key || "patch"]](value)} ${key}`).join(", ") : a.dim("no change");
    const displayName = pkg.name?.startsWith("pnpm-catalog:") ? a.dim("pnpm-catalog:") + a.yellow(pkg.name.slice("pnpm-catalog:".length)) : pkg.name ? a.cyan(pkg.name) : a.red("\u203A") + a.dim(` ${filepath || ""}`.trimEnd());
    lines.push(
      `${displayName} ${a.dim("-")} ${diffEntries}`,
      ""
    );
    const table = formatTable(
      changes.map((c2) => renderChange(
        c2,
        interactive,
        group,
        options.timediff ?? true,
        options.nodecompat ?? true
      )),
      "LLRRRRRLL"
    );
    const changeToTable = new Map(changes.map((change, idx) => [change, table[idx]]));
    if (group) {
      const groups = /* @__PURE__ */ new Map();
      for (const change of changes) {
        const key = change.source;
        if (!groups.has(key))
          groups.set(key, []);
        groups.get(key).push(change);
      }
      for (const key of Object.keys(DependenciesTypeShortMap)) {
        const group2 = groups.get(key);
        if (!group2)
          continue;
        if (lines.at(-1) !== "")
          lines.push("");
        lines.push(`  ${a.blue(key)}`);
        lines.push(...group2.map((change) => `  ${changeToTable.get(change)}`));
      }
    } else {
      lines.push(...table);
    }
    if (changes.some((c2) => c2.provenanceDowngraded)) {
      lines.push(a.yellow.bold`\n🦠 The package provenance has been downgraded, which may indicate a risk of malicious publishing. Please carefully review the package contents and check community feedback.`);
    }
    lines.push("");
  } else if (options.all) {
    lines.push(`${a.cyan(pkg.name)} ${a.dim(filepath)}`);
    lines.push();
    lines.push(a.gray("  \u2713 up to date"));
  }
  const errors = pkg.resolved.filter((i) => i.resolveError != null);
  if (errors.length) {
    lines.push();
    for (const dep of errors)
      errLines.push(...renderResolveError(dep));
    lines.push();
  }
  return {
    lines,
    errLines
  };
}
function renderResolveError(dep) {
  const lines = [];
  if (dep.resolveError == null)
    return lines;
  if (dep.resolveError === "404") {
    lines.push(a.red`> ${a.underline(dep.name)} not found`);
  } else if (dep.resolveError === "invalid_range") ; else {
    lines.push(a.red`> ${a.underline(dep.name)} unknown error`);
    lines.push(a.red(dep.resolveError.toString()));
  }
  return lines;
}
function outputErr(errLines) {
  console.error(a.inverse.red.bold` ERROR `);
  console.error();
  console.error(errLines.join("\n"));
  console.error();
}
function renderPackages(resolvePkgs, options) {
  const lines = [""];
  const errLines = [];
  resolvePkgs.forEach((pkg) => {
    const result = renderChanges(pkg, options);
    lines.push(...result.lines);
    errLines.push(...result.errLines);
  });
  return { lines, errLines };
}

async function promptInteractive(pkgs, options) {
  const {
    sort = "diff-asc",
    group = true,
    timediff = true
  } = options;
  const checked = /* @__PURE__ */ new Set();
  pkgs.forEach((pkg) => {
    pkg.resolved.forEach((dep) => {
      if (dep.update && !dep.provenanceDowngraded) {
        checked.add(dep);
      } else if (dep.latestVersionAvailable) {
        dep.update = true;
        updateTargetVersion(dep, dep.latestVersionAvailable, void 0, options.includeLocked);
      }
    });
  });
  if (flatDeps().length === 0)
    return [];
  const promise = createControlledPromise();
  sortDeps();
  let renderer = createListRenderer();
  registerInput();
  renderer.render();
  return await promise.finally(() => {
    renderer = {
      render: () => {
      },
      onKey: () => false
    };
  });
  function flatDeps() {
    return pkgs.flatMap((pkg) => pkg.resolved.filter((dep) => dep.update));
  }
  function sortDeps() {
    pkgs.forEach((pkg) => {
      pkg.resolved = sortDepChanges(pkg.resolved, sort, group);
    });
  }
  function createListRenderer(initialSelected) {
    const deps = flatDeps();
    let index = 0;
    if (initialSelected)
      index = Math.max(0, deps.findIndex((dep) => dep === initialSelected));
    const ctx = {
      isChecked: (dep) => checked.has(dep),
      isSelected: (dep) => dep === deps[index]
    };
    return {
      render() {
        const sr = createSliceRender();
        const Y = (v) => a.bold.green(v);
        console.clear();
        sr.push({ content: `${FIG_BLOCK} ${a.gray`${Y("\u2191\u2193")} to select, ${Y("space")} to toggle, ${Y("\u2192")} to change version`}`, fixed: true });
        sr.push({ content: `${FIG_BLOCK} ${a.gray`${Y("enter")} to confirm, ${Y("esc")} to cancel, ${Y("a")} to select/unselect all`}`, fixed: true });
        sr.push({ content: "", fixed: true });
        pkgs.forEach((pkg) => {
          sr.push(...renderChanges(pkg, options, ctx).lines.map((x) => ({ content: x })));
        });
        sr.render(index);
      },
      onKey(key) {
        switch (key.name) {
          case "escape":
            process$1.exit();
          case "enter":
          case "return":
            console.clear();
            pkgs.forEach((pkg) => {
              pkg.resolved.forEach((dep) => {
                dep.update = ctx.isChecked(dep);
              });
            });
            promise.resolve(pkgs);
            break;
          case "up":
          case "k":
            index = (index - 1 + deps.length) % deps.length;
            return true;
          case "down":
          case "j":
            index = (index + 1) % deps.length;
            return true;
          case "space": {
            const dep = deps[index];
            if (checked.has(dep))
              checked.delete(dep);
            else
              checked.add(dep);
            return true;
          }
          case "right":
          case "l":
            renderer = createVersionSelectRender(deps[index]);
            return true;
          case "a":
            if (deps.every((dep) => checked.has(dep)))
              checked.clear();
            else
              deps.forEach((dep) => checked.add(dep));
            return true;
        }
      }
    };
  }
  function createVersionSelectRender(dep) {
    const versions = Object.entries({
      minor: getVersionOfRange(dep, "minor"),
      patch: getVersionOfRange(dep, "patch"),
      ...dep.pkgData.tags
    }).map(([name, version]) => {
      if (!version)
        return void 0;
      const targetVersion = getPrefixedVersion(dep.currentVersion, version);
      if (!targetVersion || targetVersion === dep.currentVersion)
        return void 0;
      return {
        name,
        version,
        time: dep.pkgData.time?.[version],
        targetVersion: getPrefixedVersion(dep.currentVersion, version)
      };
    }).filter(notNullish);
    let index = 0;
    return {
      render() {
        console.clear();
        console.log(`${FIG_BLOCK} ${a.gray`Select a version for ${a.green.bold(dep.name)}${a.gray` (current ${dep.currentVersion})`}`}`);
        console.log();
        console.log(
          formatTable(versions.map((v, idx) => {
            return [
              (index === idx ? FIG_POINTER : FIG_NO_POINTER) + (index === idx ? v.name : a.gray(v.name)),
              timediff ? timeDifference(dep.currentVersionTime) : "",
              a.gray(dep.currentVersion),
              a.dim.gray("\u2192"),
              colorizeVersionDiff(dep.currentVersion, v.targetVersion),
              timediff ? timeDifference(v.time) : ""
            ];
          }), "LLLL").join("\n")
        );
      },
      onKey(key) {
        switch (key.name) {
          case "escape":
            renderer = createListRenderer(dep);
            return true;
          case "up":
          case "k":
            index = (index - 1 + versions.length) % versions.length;
            return true;
          case "down":
          case "j":
            index = (index + 1) % versions.length;
            return true;
          // confirm
          case "enter":
          case "return":
          case "left":
          case "right":
          case "h":
          case "l":
            updateTargetVersion(dep, versions[index].version, void 0, options.includeLocked);
            sortDeps();
            renderer = createListRenderer(dep);
            return true;
        }
      }
    };
  }
  function registerInput() {
    process$1.stdin.resume();
    process$1.stdin.setEncoding("utf8");
    readline.emitKeypressEvents(process$1.stdin);
    if (process$1.stdin.isTTY)
      process$1.stdin.setRawMode(true);
    process$1.stdin.on("keypress", (str, key) => {
      if (key.ctrl && key.name === "c")
        process$1.exit();
      const result = renderer.onKey(key);
      if (result && typeof result !== "boolean")
        renderer = result;
      if (result)
        renderer.render();
    });
  }
}

async function check(options) {
  let exitCode = 0;
  const bars = options.loglevel === "silent" ? null : createMultiProgressBar();
  let packagesBar;
  const depBar = bars?.create(1, 0);
  let resolvePkgs = [];
  await CheckPackages(options, {
    afterPackagesLoaded(pkgs) {
      packagesBar = options.recursive && pkgs.length ? bars?.create(pkgs.length, 0, { type: a.cyan("pkg"), name: a.cyan(pkgs[0].name) }) : void 0;
    },
    beforePackageStart(pkg) {
      packagesBar?.increment(0, { name: a.cyan(pkg.name) });
      depBar?.start(pkg.deps.length, 0, { type: a.green("dep"), name: "" });
    },
    beforePackageWrite() {
      return false;
    },
    afterPackageEnd(pkg) {
      packagesBar?.increment(1);
      depBar?.stop();
      resolvePkgs.push(pkg);
    },
    onDependencyResolved(pkgName, name, progress) {
      depBar?.update(progress, { name });
    }
  });
  bars?.stop();
  if (options.interactive)
    resolvePkgs = await promptInteractive(resolvePkgs, options);
  const { lines, errLines } = renderPackages(resolvePkgs, options);
  const hasChanges = resolvePkgs.length && resolvePkgs.some((i) => i.resolved.some((j) => j.update));
  if (!hasChanges) {
    if (errLines.length)
      outputErr(errLines);
    else
      console.log(a.green("dependencies are already up-to-date"));
    return exitCode;
  }
  console.log(lines.join("\n"));
  if (!options.all) {
    const counter = resolvePkgs.reduce((counter2, pkg) => {
      for (let i = 0; i < pkg.resolved.length; i++) {
        if (pkg.resolved[i].update)
          return ++counter2;
      }
      return counter2;
    }, 0);
    const last = resolvePkgs.length - counter;
    if (last === 1)
      console.log(a.green("dependencies are already up-to-date in one package\n"));
    else if (last > 0)
      console.log(a.green(`dependencies are already up-to-date in ${last} packages
`));
  }
  if (errLines.length)
    outputErr(errLines);
  if (options.interactive && !options.write) {
    options.write = await prompts([
      {
        name: "write",
        type: "confirm",
        initial: true,
        message: a.green("write to package.json")
      }
    ]).then((r) => r.write);
  }
  if (options.write) {
    for (const pkg of resolvePkgs) {
      for (const addon of options.addons || builtinAddons) {
        await addon.postprocess?.(pkg, options);
      }
      await writePackage(pkg, options);
    }
  }
  if (!options.write) {
    console.log();
    if (options.mode === "default")
      console.log(`Run ${a.cyan("taze major")} to check major updates`);
    if (hasChanges) {
      if (options.failOnOutdated)
        exitCode = 1;
      console.log(`Add ${a.green("-w")} to write to package.json`);
    }
    console.log();
  } else if (hasChanges) {
    let packageManager;
    if (!options.install && !options.update && !options.interactive) {
      packageManager = await detect();
      console.log(
        a.yellow`ℹ changes written to package.json, run ${a.cyan`${packageManager} i`} to install updates.`
      );
    }
    if (options.install || options.update || options.interactive)
      console.log(a.yellow("\u2139 changes written to package.json"));
    if (options.interactive && !options.install) {
      options.install = await prompts([
        {
          name: "install",
          type: "confirm",
          initial: true,
          message: a.green("install now")
        }
      ]).then((r) => r.install);
    }
    if (options.install) {
      console.log(a.magenta("installing..."));
      console.log();
      await run(parseNi, []);
    }
    if (options.update) {
      packageManager ||= await detect();
      console.log(a.magenta("updating..."));
      console.log();
      await run(parseNup, [
        options.recursive && "-r",
        packageManager === "pnpm" && "--no-save"
      ].filter(Boolean));
    }
  }
  return exitCode;
}

async function checkGlobal(options) {
  let exitCode = 0;
  let resolvePkgs = [];
  const globalPkgs = await Promise.all([
    loadGlobalNpmPackage(options),
    loadGlobalPnpmPackage(options)
  ]);
  const pkgs = globalPkgs.flat(1);
  const bars = options.loglevel === "silent" ? null : createMultiProgressBar();
  await Promise.all(pkgs.map(async (pkg) => {
    const depBar = bars?.create(pkg.deps.length, 0, { type: a.green(pkg.agent) });
    await resolvePackage(
      pkg,
      options,
      () => true,
      (_pkgName, name, progress) => depBar?.update(progress, { name })
    );
  }));
  bars?.stop();
  resolvePkgs = pkgs;
  if (options.interactive)
    resolvePkgs = await promptInteractive(resolvePkgs, options);
  const { lines, errLines } = renderPackages(resolvePkgs, options);
  const hasChanges = resolvePkgs.length && resolvePkgs.some((i) => i.resolved.some((j) => j.update));
  if (!hasChanges) {
    if (errLines.length)
      outputErr(errLines);
    else
      console.log(a.green("dependencies are already up-to-date"));
    return exitCode;
  }
  console.log(lines.join("\n"));
  if (errLines.length)
    outputErr(errLines);
  if (options.interactive && !options.install) {
    options.install = await prompts([
      {
        name: "install",
        type: "confirm",
        initial: true,
        message: a.green("install now")
      }
    ]).then((r) => r.install);
  }
  if (!options.write) {
    console.log();
    if (options.mode === "default")
      console.log(`Add ${a.green("major")} to check major updates`);
    if (hasChanges) {
      if (options.failOnOutdated)
        exitCode = 1;
      console.log(`Add ${a.green("-i")} to update global dependency`);
    }
    console.log();
  }
  if (options.install) {
    console.log(a.magenta("installing..."));
    console.log();
    for (const pkg of resolvePkgs)
      await installPkg(pkg);
  }
  return exitCode;
}
async function loadGlobalPnpmPackage(options) {
  let pnpmStdout;
  try {
    pnpmStdout = (await exec("pnpm", ["ls", "--global", "--depth=0", "--json"], { throwOnError: true })).stdout;
  } catch {
    return [];
  }
  const pnpmOuts = JSON.parse(pnpmStdout).filter((it) => it.dependencies != null);
  const filter = createDependenciesFilter(options.include, options.exclude);
  const pkgMetas = pnpmOuts.map(
    (pnpmOut) => Object.entries(pnpmOut.dependencies).filter(([_name, i]) => i?.version).map(([name, i]) => ({
      name,
      currentVersion: `^${i.version}`,
      update: filter(name),
      source: "dependencies"
    }))
  ).map((deps, i) => ({
    agent: "pnpm",
    type: "global",
    private: true,
    resolved: [],
    raw: null,
    version: "",
    filepath: "",
    relative: "",
    deps,
    name: a.red`pnpm` + a.gray.dim` (global) ` + a.gray.dim(pnpmOuts[i].path)
  }));
  return pkgMetas;
}
async function loadGlobalNpmPackage(options) {
  const { stdout } = await exec("npm", ["ls", "--global", "--depth=0", "--json"], { throwOnError: true });
  const npmOut = JSON.parse(stdout);
  const filter = createDependenciesFilter(options.include, options.exclude);
  const deps = Object.entries(npmOut.dependencies).filter(([_name, i]) => i?.version).map(([name, i]) => ({
    name,
    currentVersion: `^${i.version}`,
    update: filter(name),
    source: "dependencies"
  }));
  return {
    agent: "npm",
    private: true,
    type: "global",
    resolved: [],
    raw: null,
    version: "",
    filepath: "",
    relative: "",
    deps,
    name: a.red`npm` + a.gray.dim` (global)`
  };
}
async function installPkg(pkg) {
  const changes = pkg.resolved.filter((i) => i.update);
  if (!changes.length)
    return;
  const dependencies = dumpDependencies(changes, "dependencies");
  const updateArgs = Object.entries(dependencies).map(([name, version]) => `${name}@${version}`);
  const install = getCommand(pkg.agent, "global", [...updateArgs]);
  await exec(install.command, install.args, { throwOnError: true });
}

var cjs;
var hasRequiredCjs;

function requireCjs () {
	if (hasRequiredCjs) return cjs;
	hasRequiredCjs = 1;

	var isMergeableObject = function isMergeableObject(value) {
		return isNonNullObject(value)
			&& !isSpecial(value)
	};

	function isNonNullObject(value) {
		return !!value && typeof value === 'object'
	}

	function isSpecial(value) {
		var stringValue = Object.prototype.toString.call(value);

		return stringValue === '[object RegExp]'
			|| stringValue === '[object Date]'
			|| isReactElement(value)
	}

	// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
	var canUseSymbol = typeof Symbol === 'function' && Symbol.for;
	var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;

	function isReactElement(value) {
		return value.$$typeof === REACT_ELEMENT_TYPE
	}

	function emptyTarget(val) {
		return Array.isArray(val) ? [] : {}
	}

	function cloneUnlessOtherwiseSpecified(value, options) {
		return (options.clone !== false && options.isMergeableObject(value))
			? deepmerge(emptyTarget(value), value, options)
			: value
	}

	function defaultArrayMerge(target, source, options) {
		return target.concat(source).map(function(element) {
			return cloneUnlessOtherwiseSpecified(element, options)
		})
	}

	function getMergeFunction(key, options) {
		if (!options.customMerge) {
			return deepmerge
		}
		var customMerge = options.customMerge(key);
		return typeof customMerge === 'function' ? customMerge : deepmerge
	}

	function getEnumerableOwnPropertySymbols(target) {
		return Object.getOwnPropertySymbols
			? Object.getOwnPropertySymbols(target).filter(function(symbol) {
				return Object.propertyIsEnumerable.call(target, symbol)
			})
			: []
	}

	function getKeys(target) {
		return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))
	}

	function propertyIsOnObject(object, property) {
		try {
			return property in object
		} catch(_) {
			return false
		}
	}

	// Protects from prototype poisoning and unexpected merging up the prototype chain.
	function propertyIsUnsafe(target, key) {
		return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,
			&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,
				&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.
	}

	function mergeObject(target, source, options) {
		var destination = {};
		if (options.isMergeableObject(target)) {
			getKeys(target).forEach(function(key) {
				destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
			});
		}
		getKeys(source).forEach(function(key) {
			if (propertyIsUnsafe(target, key)) {
				return
			}

			if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
				destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
			} else {
				destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
			}
		});
		return destination
	}

	function deepmerge(target, source, options) {
		options = options || {};
		options.arrayMerge = options.arrayMerge || defaultArrayMerge;
		options.isMergeableObject = options.isMergeableObject || isMergeableObject;
		// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()
		// implementations can use it. The caller may not replace it.
		options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;

		var sourceIsArray = Array.isArray(source);
		var targetIsArray = Array.isArray(target);
		var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;

		if (!sourceAndTargetTypesMatch) {
			return cloneUnlessOtherwiseSpecified(source, options)
		} else if (sourceIsArray) {
			return options.arrayMerge(target, source, options)
		} else {
			return mergeObject(target, source, options)
		}
	}

	deepmerge.all = function deepmergeAll(array, options) {
		if (!Array.isArray(array)) {
			throw new Error('first argument should be an array')
		}

		return array.reduce(function(prev, next) {
			return deepmerge(prev, next, options)
		}, {})
	};

	var deepmerge_1 = deepmerge;

	cjs = deepmerge_1;
	return cjs;
}

var cjsExports = requireCjs();
const deepmerge = /*@__PURE__*/getDefaultExportFromCjs(cjsExports);

const debug = _debug("taze:config");
function normalizeConfig(options) {
  if ("default" in options)
    options = options.default;
  options.ignorePaths = toArray(options.ignorePaths);
  options.exclude = toArray(options.exclude);
  options.include = toArray(options.include);
  if (options.silent)
    options.loglevel = "silent";
  return options;
}
async function resolveConfig(options) {
  const defaults = DEFAULT_CHECK_OPTIONS;
  options = normalizeConfig(options);
  const loader = createConfigLoader({
    sources: [
      {
        files: [
          "taze.config"
        ]
      },
      {
        files: [
          ".tazerc"
        ],
        extensions: ["json", ""]
      }
    ],
    cwd: options.cwd || process$1.cwd(),
    merge: false
  });
  const config = await loader.load();
  if (!config.sources.length)
    return deepmerge(defaults, options);
  debug(`config file found ${config.sources[0]}`);
  const configOptions = normalizeConfig(config.config);
  return deepmerge(deepmerge(defaults, configOptions), options);
}

const cli = cac("taze");
cli.command("[mode]", "Keeps your deps fresh").option("--cwd, -C <cwd>", "specify the current working directory").option("--loglevel <level>", `log level (${LOG_LEVELS.join("|")})`).option("--fail-on-outdated", "exit with code 1 if outdated dependencies are found").option("--silent, -s", "complete silent").option("--recursive, -r", "recursively search for package.json in subdirectories").option("--force, -f", "force fetching from server, bypass cache").option("--ignore-paths <paths>", "ignore paths for search package.json").option("--ignore-other-workspaces", "ignore package.json that in other workspaces (with their own .git,pnpm-workspace.yaml,etc.)", { default: true }).option("--include, -n <deps>", "only included dependencies will be checked for updates").option("--exclude, -x <deps>", "exclude dependencies to be checked, will override --include options").option("--write, -w", "write to package.json").option("--global, -g", "update global packages").option("--interactive, -I", "interactive mode").option("--install, -i", "install directly after bumping").option("--update, -u", "update directly after bumping").option("--all, -a", "show all packages up to date info").option("--sort <type>", `sort by most outdated absolute or relative to dependency (${SORT_CHOICES.join("|")})`).option("--group", "group dependencies by source on display").option("--include-locked, -l", "include locked dependencies & devDependencies").option("--timediff", "show time difference between the current and the updated version").option("--nodecompat", "show package compatibility with current node version").option("--peer", "Include peerDependencies in the update process").action(async (mode, options) => {
  if (mode) {
    if (!MODE_CHOICES.includes(mode)) {
      console.error(`Invalid mode: ${mode}. Please use one of the following: ${MODE_CHOICES.join("|")}`);
      process$1.exit(1);
    }
    options.mode = mode;
  }
  const resolved = await resolveConfig(options);
  let exitCode;
  if (options.global)
    exitCode = await checkGlobal(resolved);
  else
    exitCode = await check(resolved);
  process$1.exit(exitCode);
});
cli.help();
cli.version(pkgJson.version);
cli.parse();
restoreCursor();
