待做:
日志部分
单元测试
交易哈希分配模块->细粒度锁+预缓冲模式  
    订单请求 → GetHashForOrder(poolID)
                ↓
            检查缓冲是否充足？(每隔一定时间自动触发一次补充，条件是最近30分钟没有订单并且缓冲数<1000，当有订单的时候刷新时间)
                ↓
            不足 → 异步预加载(哈希补充模式，当前区块高度-一个随机数，每次获取1000个交易哈希)
                ↓
            从队列Pop一个
                ↓
            持久化到数据库
                ↓
            返回哈希


功能完善后需要进行完整集成测试

考虑奖池量级问题预估数量
是否有一件商品一次下单购买多件的需求
同一件商品开奖后，直接继续下一轮？重复开奖

类生产者 消费者模式
10个哈希池(更新模式为 当半小时没有订单时 刷新一次，应该不需要补充)
lottery只需要从哈希池遍历取出可用的哈希值使用，每个哈希池仅有1000个哈希，商品最高1000个开一次奖，所以即使1000次都抽中同一个池子，也可以满足开奖条件


2025 10 17 需要完善的
hash_manager  获取一个可用哈希 判断是否已经被使用 可以直接从奖池的结构体判断，而不是在哈希池判断
或者在调用 gethash接口的时候传入奖池id(唯一)  hash_manager保留  但是这样相当于同一份使用记录 保存了两遍， 双倍开销

lottery pools创建竞争问题

使用-race检测数据竞争
使用pprof进行性能分析

待办事项: lottery.go 订单方案 每次回调插入一条记录到user_hash 然后更新内存里 奖池的金额和订单数，
每次重启都要计算一次 并且将已售份数和金额更新到ProductPool 奖池表
额外功能   每隔一段时间将金额和份数  落库到ProductPool  所以该库的金额和份数会有一定的延迟，内存是实时的，但是均不可靠
最可靠的是user_hash
