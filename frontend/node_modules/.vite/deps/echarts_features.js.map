{
  "version": 3,
  "sources": ["../../.pnpm/zrender@6.0.0/node_modules/zrender/lib/tool/convertPath.js", "../../.pnpm/zrender@6.0.0/node_modules/zrender/lib/tool/dividePath.js", "../../.pnpm/zrender@6.0.0/node_modules/zrender/lib/tool/morphPath.js", "../../.pnpm/echarts@6.0.0/node_modules/echarts/lib/animation/morphTransitionHelper.js", "../../.pnpm/echarts@6.0.0/node_modules/echarts/lib/animation/universalTransition.js", "../../.pnpm/echarts@6.0.0/node_modules/echarts/lib/scale/breakImpl.js", "../../.pnpm/echarts@6.0.0/node_modules/echarts/lib/component/axis/axisBreakHelperImpl.js", "../../.pnpm/echarts@6.0.0/node_modules/echarts/lib/component/axis/installBreak.js", "../../.pnpm/echarts@6.0.0/node_modules/echarts/lib/coord/cartesian/legacyContainLabel.js"],
  "sourcesContent": ["import { cubicSubdivide } from '../core/curve.js';\nimport PathProxy from '../core/PathProxy.js';\nvar CMD = PathProxy.CMD;\nfunction aroundEqual(a, b) {\n    return Math.abs(a - b) < 1e-5;\n}\nexport function pathToBezierCurves(path) {\n    var data = path.data;\n    var len = path.len();\n    var bezierArrayGroups = [];\n    var currentSubpath;\n    var xi = 0;\n    var yi = 0;\n    var x0 = 0;\n    var y0 = 0;\n    function createNewSubpath(x, y) {\n        if (currentSubpath && currentSubpath.length > 2) {\n            bezierArrayGroups.push(currentSubpath);\n        }\n        currentSubpath = [x, y];\n    }\n    function addLine(x0, y0, x1, y1) {\n        if (!(aroundEqual(x0, x1) && aroundEqual(y0, y1))) {\n            currentSubpath.push(x0, y0, x1, y1, x1, y1);\n        }\n    }\n    function addArc(startAngle, endAngle, cx, cy, rx, ry) {\n        var delta = Math.abs(endAngle - startAngle);\n        var len = Math.tan(delta / 4) * 4 / 3;\n        var dir = endAngle < startAngle ? -1 : 1;\n        var c1 = Math.cos(startAngle);\n        var s1 = Math.sin(startAngle);\n        var c2 = Math.cos(endAngle);\n        var s2 = Math.sin(endAngle);\n        var x1 = c1 * rx + cx;\n        var y1 = s1 * ry + cy;\n        var x4 = c2 * rx + cx;\n        var y4 = s2 * ry + cy;\n        var hx = rx * len * dir;\n        var hy = ry * len * dir;\n        currentSubpath.push(x1 - hx * s1, y1 + hy * c1, x4 + hx * s2, y4 - hy * c2, x4, y4);\n    }\n    var x1;\n    var y1;\n    var x2;\n    var y2;\n    for (var i = 0; i < len;) {\n        var cmd = data[i++];\n        var isFirst = i === 1;\n        if (isFirst) {\n            xi = data[i];\n            yi = data[i + 1];\n            x0 = xi;\n            y0 = yi;\n            if (cmd === CMD.L || cmd === CMD.C || cmd === CMD.Q) {\n                currentSubpath = [x0, y0];\n            }\n        }\n        switch (cmd) {\n            case CMD.M:\n                xi = x0 = data[i++];\n                yi = y0 = data[i++];\n                createNewSubpath(x0, y0);\n                break;\n            case CMD.L:\n                x1 = data[i++];\n                y1 = data[i++];\n                addLine(xi, yi, x1, y1);\n                xi = x1;\n                yi = y1;\n                break;\n            case CMD.C:\n                currentSubpath.push(data[i++], data[i++], data[i++], data[i++], xi = data[i++], yi = data[i++]);\n                break;\n            case CMD.Q:\n                x1 = data[i++];\n                y1 = data[i++];\n                x2 = data[i++];\n                y2 = data[i++];\n                currentSubpath.push(xi + 2 / 3 * (x1 - xi), yi + 2 / 3 * (y1 - yi), x2 + 2 / 3 * (x1 - x2), y2 + 2 / 3 * (y1 - y2), x2, y2);\n                xi = x2;\n                yi = y2;\n                break;\n            case CMD.A:\n                var cx = data[i++];\n                var cy = data[i++];\n                var rx = data[i++];\n                var ry = data[i++];\n                var startAngle = data[i++];\n                var endAngle = data[i++] + startAngle;\n                i += 1;\n                var anticlockwise = !data[i++];\n                x1 = Math.cos(startAngle) * rx + cx;\n                y1 = Math.sin(startAngle) * ry + cy;\n                if (isFirst) {\n                    x0 = x1;\n                    y0 = y1;\n                    createNewSubpath(x0, y0);\n                }\n                else {\n                    addLine(xi, yi, x1, y1);\n                }\n                xi = Math.cos(endAngle) * rx + cx;\n                yi = Math.sin(endAngle) * ry + cy;\n                var step = (anticlockwise ? -1 : 1) * Math.PI / 2;\n                for (var angle = startAngle; anticlockwise ? angle > endAngle : angle < endAngle; angle += step) {\n                    var nextAngle = anticlockwise ? Math.max(angle + step, endAngle)\n                        : Math.min(angle + step, endAngle);\n                    addArc(angle, nextAngle, cx, cy, rx, ry);\n                }\n                break;\n            case CMD.R:\n                x0 = xi = data[i++];\n                y0 = yi = data[i++];\n                x1 = x0 + data[i++];\n                y1 = y0 + data[i++];\n                createNewSubpath(x1, y0);\n                addLine(x1, y0, x1, y1);\n                addLine(x1, y1, x0, y1);\n                addLine(x0, y1, x0, y0);\n                addLine(x0, y0, x1, y0);\n                break;\n            case CMD.Z:\n                currentSubpath && addLine(xi, yi, x0, y0);\n                xi = x0;\n                yi = y0;\n                break;\n        }\n    }\n    if (currentSubpath && currentSubpath.length > 2) {\n        bezierArrayGroups.push(currentSubpath);\n    }\n    return bezierArrayGroups;\n}\nfunction adpativeBezier(x0, y0, x1, y1, x2, y2, x3, y3, out, scale) {\n    if (aroundEqual(x0, x1) && aroundEqual(y0, y1) && aroundEqual(x2, x3) && aroundEqual(y2, y3)) {\n        out.push(x3, y3);\n        return;\n    }\n    var PIXEL_DISTANCE = 2 / scale;\n    var PIXEL_DISTANCE_SQR = PIXEL_DISTANCE * PIXEL_DISTANCE;\n    var dx = x3 - x0;\n    var dy = y3 - y0;\n    var d = Math.sqrt(dx * dx + dy * dy);\n    dx /= d;\n    dy /= d;\n    var dx1 = x1 - x0;\n    var dy1 = y1 - y0;\n    var dx2 = x2 - x3;\n    var dy2 = y2 - y3;\n    var cp1LenSqr = dx1 * dx1 + dy1 * dy1;\n    var cp2LenSqr = dx2 * dx2 + dy2 * dy2;\n    if (cp1LenSqr < PIXEL_DISTANCE_SQR && cp2LenSqr < PIXEL_DISTANCE_SQR) {\n        out.push(x3, y3);\n        return;\n    }\n    var projLen1 = dx * dx1 + dy * dy1;\n    var projLen2 = -dx * dx2 - dy * dy2;\n    var d1Sqr = cp1LenSqr - projLen1 * projLen1;\n    var d2Sqr = cp2LenSqr - projLen2 * projLen2;\n    if (d1Sqr < PIXEL_DISTANCE_SQR && projLen1 >= 0\n        && d2Sqr < PIXEL_DISTANCE_SQR && projLen2 >= 0) {\n        out.push(x3, y3);\n        return;\n    }\n    var tmpSegX = [];\n    var tmpSegY = [];\n    cubicSubdivide(x0, x1, x2, x3, 0.5, tmpSegX);\n    cubicSubdivide(y0, y1, y2, y3, 0.5, tmpSegY);\n    adpativeBezier(tmpSegX[0], tmpSegY[0], tmpSegX[1], tmpSegY[1], tmpSegX[2], tmpSegY[2], tmpSegX[3], tmpSegY[3], out, scale);\n    adpativeBezier(tmpSegX[4], tmpSegY[4], tmpSegX[5], tmpSegY[5], tmpSegX[6], tmpSegY[6], tmpSegX[7], tmpSegY[7], out, scale);\n}\nexport function pathToPolygons(path, scale) {\n    var bezierArrayGroups = pathToBezierCurves(path);\n    var polygons = [];\n    scale = scale || 1;\n    for (var i = 0; i < bezierArrayGroups.length; i++) {\n        var beziers = bezierArrayGroups[i];\n        var polygon = [];\n        var x0 = beziers[0];\n        var y0 = beziers[1];\n        polygon.push(x0, y0);\n        for (var k = 2; k < beziers.length;) {\n            var x1 = beziers[k++];\n            var y1 = beziers[k++];\n            var x2 = beziers[k++];\n            var y2 = beziers[k++];\n            var x3 = beziers[k++];\n            var y3 = beziers[k++];\n            adpativeBezier(x0, y0, x1, y1, x2, y2, x3, y3, polygon, scale);\n            x0 = x3;\n            y0 = y3;\n        }\n        polygons.push(polygon);\n    }\n    return polygons;\n}\n", "import { fromPoints } from '../core/bbox.js';\nimport BoundingRect from '../core/BoundingRect.js';\nimport Point from '../core/Point.js';\nimport { map } from '../core/util.js';\nimport Polygon from '../graphic/shape/Polygon.js';\nimport Rect from '../graphic/shape/Rect.js';\nimport Sector from '../graphic/shape/Sector.js';\nimport { pathToPolygons } from './convertPath.js';\nimport { clonePath } from './path.js';\nfunction getDividingGrids(dimSize, rowDim, count) {\n    var rowSize = dimSize[rowDim];\n    var columnSize = dimSize[1 - rowDim];\n    var ratio = Math.abs(rowSize / columnSize);\n    var rowCount = Math.ceil(Math.sqrt(ratio * count));\n    var columnCount = Math.floor(count / rowCount);\n    if (columnCount === 0) {\n        columnCount = 1;\n        rowCount = count;\n    }\n    var grids = [];\n    for (var i = 0; i < rowCount; i++) {\n        grids.push(columnCount);\n    }\n    var currentCount = rowCount * columnCount;\n    var remained = count - currentCount;\n    if (remained > 0) {\n        for (var i = 0; i < remained; i++) {\n            grids[i % rowCount] += 1;\n        }\n    }\n    return grids;\n}\nfunction divideSector(sectorShape, count, outShapes) {\n    var r0 = sectorShape.r0;\n    var r = sectorShape.r;\n    var startAngle = sectorShape.startAngle;\n    var endAngle = sectorShape.endAngle;\n    var angle = Math.abs(endAngle - startAngle);\n    var arcLen = angle * r;\n    var deltaR = r - r0;\n    var isAngleRow = arcLen > Math.abs(deltaR);\n    var grids = getDividingGrids([arcLen, deltaR], isAngleRow ? 0 : 1, count);\n    var rowSize = (isAngleRow ? angle : deltaR) / grids.length;\n    for (var row = 0; row < grids.length; row++) {\n        var columnSize = (isAngleRow ? deltaR : angle) / grids[row];\n        for (var column = 0; column < grids[row]; column++) {\n            var newShape = {};\n            if (isAngleRow) {\n                newShape.startAngle = startAngle + rowSize * row;\n                newShape.endAngle = startAngle + rowSize * (row + 1);\n                newShape.r0 = r0 + columnSize * column;\n                newShape.r = r0 + columnSize * (column + 1);\n            }\n            else {\n                newShape.startAngle = startAngle + columnSize * column;\n                newShape.endAngle = startAngle + columnSize * (column + 1);\n                newShape.r0 = r0 + rowSize * row;\n                newShape.r = r0 + rowSize * (row + 1);\n            }\n            newShape.clockwise = sectorShape.clockwise;\n            newShape.cx = sectorShape.cx;\n            newShape.cy = sectorShape.cy;\n            outShapes.push(newShape);\n        }\n    }\n}\nfunction divideRect(rectShape, count, outShapes) {\n    var width = rectShape.width;\n    var height = rectShape.height;\n    var isHorizontalRow = width > height;\n    var grids = getDividingGrids([width, height], isHorizontalRow ? 0 : 1, count);\n    var rowSizeDim = isHorizontalRow ? 'width' : 'height';\n    var columnSizeDim = isHorizontalRow ? 'height' : 'width';\n    var rowDim = isHorizontalRow ? 'x' : 'y';\n    var columnDim = isHorizontalRow ? 'y' : 'x';\n    var rowSize = rectShape[rowSizeDim] / grids.length;\n    for (var row = 0; row < grids.length; row++) {\n        var columnSize = rectShape[columnSizeDim] / grids[row];\n        for (var column = 0; column < grids[row]; column++) {\n            var newShape = {};\n            newShape[rowDim] = row * rowSize;\n            newShape[columnDim] = column * columnSize;\n            newShape[rowSizeDim] = rowSize;\n            newShape[columnSizeDim] = columnSize;\n            newShape.x += rectShape.x;\n            newShape.y += rectShape.y;\n            outShapes.push(newShape);\n        }\n    }\n}\nfunction crossProduct2d(x1, y1, x2, y2) {\n    return x1 * y2 - x2 * y1;\n}\nfunction lineLineIntersect(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y) {\n    var mx = a2x - a1x;\n    var my = a2y - a1y;\n    var nx = b2x - b1x;\n    var ny = b2y - b1y;\n    var nmCrossProduct = crossProduct2d(nx, ny, mx, my);\n    if (Math.abs(nmCrossProduct) < 1e-6) {\n        return null;\n    }\n    var b1a1x = a1x - b1x;\n    var b1a1y = a1y - b1y;\n    var p = crossProduct2d(b1a1x, b1a1y, nx, ny) / nmCrossProduct;\n    if (p < 0 || p > 1) {\n        return null;\n    }\n    return new Point(p * mx + a1x, p * my + a1y);\n}\nfunction projPtOnLine(pt, lineA, lineB) {\n    var dir = new Point();\n    Point.sub(dir, lineB, lineA);\n    dir.normalize();\n    var dir2 = new Point();\n    Point.sub(dir2, pt, lineA);\n    var len = dir2.dot(dir);\n    return len;\n}\nfunction addToPoly(poly, pt) {\n    var last = poly[poly.length - 1];\n    if (last && last[0] === pt[0] && last[1] === pt[1]) {\n        return;\n    }\n    poly.push(pt);\n}\nfunction splitPolygonByLine(points, lineA, lineB) {\n    var len = points.length;\n    var intersections = [];\n    for (var i = 0; i < len; i++) {\n        var p0 = points[i];\n        var p1 = points[(i + 1) % len];\n        var intersectionPt = lineLineIntersect(p0[0], p0[1], p1[0], p1[1], lineA.x, lineA.y, lineB.x, lineB.y);\n        if (intersectionPt) {\n            intersections.push({\n                projPt: projPtOnLine(intersectionPt, lineA, lineB),\n                pt: intersectionPt,\n                idx: i\n            });\n        }\n    }\n    if (intersections.length < 2) {\n        return [{ points: points }, { points: points }];\n    }\n    intersections.sort(function (a, b) {\n        return a.projPt - b.projPt;\n    });\n    var splitPt0 = intersections[0];\n    var splitPt1 = intersections[intersections.length - 1];\n    if (splitPt1.idx < splitPt0.idx) {\n        var tmp = splitPt0;\n        splitPt0 = splitPt1;\n        splitPt1 = tmp;\n    }\n    var splitPt0Arr = [splitPt0.pt.x, splitPt0.pt.y];\n    var splitPt1Arr = [splitPt1.pt.x, splitPt1.pt.y];\n    var newPolyA = [splitPt0Arr];\n    var newPolyB = [splitPt1Arr];\n    for (var i = splitPt0.idx + 1; i <= splitPt1.idx; i++) {\n        addToPoly(newPolyA, points[i].slice());\n    }\n    addToPoly(newPolyA, splitPt1Arr);\n    addToPoly(newPolyA, splitPt0Arr);\n    for (var i = splitPt1.idx + 1; i <= splitPt0.idx + len; i++) {\n        addToPoly(newPolyB, points[i % len].slice());\n    }\n    addToPoly(newPolyB, splitPt0Arr);\n    addToPoly(newPolyB, splitPt1Arr);\n    return [{\n            points: newPolyA\n        }, {\n            points: newPolyB\n        }];\n}\nfunction binaryDividePolygon(polygonShape) {\n    var points = polygonShape.points;\n    var min = [];\n    var max = [];\n    fromPoints(points, min, max);\n    var boundingRect = new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);\n    var width = boundingRect.width;\n    var height = boundingRect.height;\n    var x = boundingRect.x;\n    var y = boundingRect.y;\n    var pt0 = new Point();\n    var pt1 = new Point();\n    if (width > height) {\n        pt0.x = pt1.x = x + width / 2;\n        pt0.y = y;\n        pt1.y = y + height;\n    }\n    else {\n        pt0.y = pt1.y = y + height / 2;\n        pt0.x = x;\n        pt1.x = x + width;\n    }\n    return splitPolygonByLine(points, pt0, pt1);\n}\nfunction binaryDivideRecursive(divider, shape, count, out) {\n    if (count === 1) {\n        out.push(shape);\n    }\n    else {\n        var mid = Math.floor(count / 2);\n        var sub = divider(shape);\n        binaryDivideRecursive(divider, sub[0], mid, out);\n        binaryDivideRecursive(divider, sub[1], count - mid, out);\n    }\n    return out;\n}\nexport function clone(path, count) {\n    var paths = [];\n    for (var i = 0; i < count; i++) {\n        paths.push(clonePath(path));\n    }\n    return paths;\n}\nfunction copyPathProps(source, target) {\n    target.setStyle(source.style);\n    target.z = source.z;\n    target.z2 = source.z2;\n    target.zlevel = source.zlevel;\n}\nfunction polygonConvert(points) {\n    var out = [];\n    for (var i = 0; i < points.length;) {\n        out.push([points[i++], points[i++]]);\n    }\n    return out;\n}\nexport function split(path, count) {\n    var outShapes = [];\n    var shape = path.shape;\n    var OutShapeCtor;\n    switch (path.type) {\n        case 'rect':\n            divideRect(shape, count, outShapes);\n            OutShapeCtor = Rect;\n            break;\n        case 'sector':\n            divideSector(shape, count, outShapes);\n            OutShapeCtor = Sector;\n            break;\n        case 'circle':\n            divideSector({\n                r0: 0, r: shape.r, startAngle: 0, endAngle: Math.PI * 2,\n                cx: shape.cx, cy: shape.cy\n            }, count, outShapes);\n            OutShapeCtor = Sector;\n            break;\n        default:\n            var m = path.getComputedTransform();\n            var scale = m ? Math.sqrt(Math.max(m[0] * m[0] + m[1] * m[1], m[2] * m[2] + m[3] * m[3])) : 1;\n            var polygons = map(pathToPolygons(path.getUpdatedPathProxy(), scale), function (poly) { return polygonConvert(poly); });\n            var polygonCount = polygons.length;\n            if (polygonCount === 0) {\n                binaryDivideRecursive(binaryDividePolygon, {\n                    points: polygons[0]\n                }, count, outShapes);\n            }\n            else if (polygonCount === count) {\n                for (var i = 0; i < polygonCount; i++) {\n                    outShapes.push({\n                        points: polygons[i]\n                    });\n                }\n            }\n            else {\n                var totalArea_1 = 0;\n                var items = map(polygons, function (poly) {\n                    var min = [];\n                    var max = [];\n                    fromPoints(poly, min, max);\n                    var area = (max[1] - min[1]) * (max[0] - min[0]);\n                    totalArea_1 += area;\n                    return { poly: poly, area: area };\n                });\n                items.sort(function (a, b) { return b.area - a.area; });\n                var left = count;\n                for (var i = 0; i < polygonCount; i++) {\n                    var item = items[i];\n                    if (left <= 0) {\n                        break;\n                    }\n                    var selfCount = i === polygonCount - 1\n                        ? left\n                        : Math.ceil(item.area / totalArea_1 * count);\n                    if (selfCount < 0) {\n                        continue;\n                    }\n                    binaryDivideRecursive(binaryDividePolygon, {\n                        points: item.poly\n                    }, selfCount, outShapes);\n                    left -= selfCount;\n                }\n                ;\n            }\n            OutShapeCtor = Polygon;\n            break;\n    }\n    if (!OutShapeCtor) {\n        return clone(path, count);\n    }\n    var out = [];\n    for (var i = 0; i < outShapes.length; i++) {\n        var subPath = new OutShapeCtor();\n        subPath.setShape(outShapes[i]);\n        copyPathProps(path, subPath);\n        out.push(subPath);\n    }\n    return out;\n}\n", "import { cubicSubdivide } from '../core/curve.js';\nimport Path from '../graphic/Path.js';\nimport { defaults, map } from '../core/util.js';\nimport { lerp } from '../core/vector.js';\nimport { clonePath } from './path.js';\nimport Transformable from '../core/Transformable.js';\nimport { split } from './dividePath.js';\nimport { pathToBezierCurves } from './convertPath.js';\nfunction alignSubpath(subpath1, subpath2) {\n    var len1 = subpath1.length;\n    var len2 = subpath2.length;\n    if (len1 === len2) {\n        return [subpath1, subpath2];\n    }\n    var tmpSegX = [];\n    var tmpSegY = [];\n    var shorterPath = len1 < len2 ? subpath1 : subpath2;\n    var shorterLen = Math.min(len1, len2);\n    var diff = Math.abs(len2 - len1) / 6;\n    var shorterBezierCount = (shorterLen - 2) / 6;\n    var eachCurveSubDivCount = Math.ceil(diff / shorterBezierCount) + 1;\n    var newSubpath = [shorterPath[0], shorterPath[1]];\n    var remained = diff;\n    for (var i = 2; i < shorterLen;) {\n        var x0 = shorterPath[i - 2];\n        var y0 = shorterPath[i - 1];\n        var x1 = shorterPath[i++];\n        var y1 = shorterPath[i++];\n        var x2 = shorterPath[i++];\n        var y2 = shorterPath[i++];\n        var x3 = shorterPath[i++];\n        var y3 = shorterPath[i++];\n        if (remained <= 0) {\n            newSubpath.push(x1, y1, x2, y2, x3, y3);\n            continue;\n        }\n        var actualSubDivCount = Math.min(remained, eachCurveSubDivCount - 1) + 1;\n        for (var k = 1; k <= actualSubDivCount; k++) {\n            var p = k / actualSubDivCount;\n            cubicSubdivide(x0, x1, x2, x3, p, tmpSegX);\n            cubicSubdivide(y0, y1, y2, y3, p, tmpSegY);\n            x0 = tmpSegX[3];\n            y0 = tmpSegY[3];\n            newSubpath.push(tmpSegX[1], tmpSegY[1], tmpSegX[2], tmpSegY[2], x0, y0);\n            x1 = tmpSegX[5];\n            y1 = tmpSegY[5];\n            x2 = tmpSegX[6];\n            y2 = tmpSegY[6];\n        }\n        remained -= actualSubDivCount - 1;\n    }\n    return shorterPath === subpath1 ? [newSubpath, subpath2] : [subpath1, newSubpath];\n}\nfunction createSubpath(lastSubpathSubpath, otherSubpath) {\n    var len = lastSubpathSubpath.length;\n    var lastX = lastSubpathSubpath[len - 2];\n    var lastY = lastSubpathSubpath[len - 1];\n    var newSubpath = [];\n    for (var i = 0; i < otherSubpath.length;) {\n        newSubpath[i++] = lastX;\n        newSubpath[i++] = lastY;\n    }\n    return newSubpath;\n}\nexport function alignBezierCurves(array1, array2) {\n    var _a;\n    var lastSubpath1;\n    var lastSubpath2;\n    var newArray1 = [];\n    var newArray2 = [];\n    for (var i = 0; i < Math.max(array1.length, array2.length); i++) {\n        var subpath1 = array1[i];\n        var subpath2 = array2[i];\n        var newSubpath1 = void 0;\n        var newSubpath2 = void 0;\n        if (!subpath1) {\n            newSubpath1 = createSubpath(lastSubpath1 || subpath2, subpath2);\n            newSubpath2 = subpath2;\n        }\n        else if (!subpath2) {\n            newSubpath2 = createSubpath(lastSubpath2 || subpath1, subpath1);\n            newSubpath1 = subpath1;\n        }\n        else {\n            _a = alignSubpath(subpath1, subpath2), newSubpath1 = _a[0], newSubpath2 = _a[1];\n            lastSubpath1 = newSubpath1;\n            lastSubpath2 = newSubpath2;\n        }\n        newArray1.push(newSubpath1);\n        newArray2.push(newSubpath2);\n    }\n    return [newArray1, newArray2];\n}\nexport function centroid(array) {\n    var signedArea = 0;\n    var cx = 0;\n    var cy = 0;\n    var len = array.length;\n    for (var i = 0, j = len - 2; i < len; j = i, i += 2) {\n        var x0 = array[j];\n        var y0 = array[j + 1];\n        var x1 = array[i];\n        var y1 = array[i + 1];\n        var a = x0 * y1 - x1 * y0;\n        signedArea += a;\n        cx += (x0 + x1) * a;\n        cy += (y0 + y1) * a;\n    }\n    if (signedArea === 0) {\n        return [array[0] || 0, array[1] || 0];\n    }\n    return [cx / signedArea / 3, cy / signedArea / 3, signedArea];\n}\nfunction findBestRingOffset(fromSubBeziers, toSubBeziers, fromCp, toCp) {\n    var bezierCount = (fromSubBeziers.length - 2) / 6;\n    var bestScore = Infinity;\n    var bestOffset = 0;\n    var len = fromSubBeziers.length;\n    var len2 = len - 2;\n    for (var offset = 0; offset < bezierCount; offset++) {\n        var cursorOffset = offset * 6;\n        var score = 0;\n        for (var k = 0; k < len; k += 2) {\n            var idx = k === 0 ? cursorOffset : ((cursorOffset + k - 2) % len2 + 2);\n            var x0 = fromSubBeziers[idx] - fromCp[0];\n            var y0 = fromSubBeziers[idx + 1] - fromCp[1];\n            var x1 = toSubBeziers[k] - toCp[0];\n            var y1 = toSubBeziers[k + 1] - toCp[1];\n            var dx = x1 - x0;\n            var dy = y1 - y0;\n            score += dx * dx + dy * dy;\n        }\n        if (score < bestScore) {\n            bestScore = score;\n            bestOffset = offset;\n        }\n    }\n    return bestOffset;\n}\nfunction reverse(array) {\n    var newArr = [];\n    var len = array.length;\n    for (var i = 0; i < len; i += 2) {\n        newArr[i] = array[len - i - 2];\n        newArr[i + 1] = array[len - i - 1];\n    }\n    return newArr;\n}\nfunction findBestMorphingRotation(fromArr, toArr, searchAngleIteration, searchAngleRange) {\n    var result = [];\n    var fromNeedsReverse;\n    for (var i = 0; i < fromArr.length; i++) {\n        var fromSubpathBezier = fromArr[i];\n        var toSubpathBezier = toArr[i];\n        var fromCp = centroid(fromSubpathBezier);\n        var toCp = centroid(toSubpathBezier);\n        if (fromNeedsReverse == null) {\n            fromNeedsReverse = fromCp[2] < 0 !== toCp[2] < 0;\n        }\n        var newFromSubpathBezier = [];\n        var newToSubpathBezier = [];\n        var bestAngle = 0;\n        var bestScore = Infinity;\n        var tmpArr = [];\n        var len = fromSubpathBezier.length;\n        if (fromNeedsReverse) {\n            fromSubpathBezier = reverse(fromSubpathBezier);\n        }\n        var offset = findBestRingOffset(fromSubpathBezier, toSubpathBezier, fromCp, toCp) * 6;\n        var len2 = len - 2;\n        for (var k = 0; k < len2; k += 2) {\n            var idx = (offset + k) % len2 + 2;\n            newFromSubpathBezier[k + 2] = fromSubpathBezier[idx] - fromCp[0];\n            newFromSubpathBezier[k + 3] = fromSubpathBezier[idx + 1] - fromCp[1];\n        }\n        newFromSubpathBezier[0] = fromSubpathBezier[offset] - fromCp[0];\n        newFromSubpathBezier[1] = fromSubpathBezier[offset + 1] - fromCp[1];\n        if (searchAngleIteration > 0) {\n            var step = searchAngleRange / searchAngleIteration;\n            for (var angle = -searchAngleRange / 2; angle <= searchAngleRange / 2; angle += step) {\n                var sa = Math.sin(angle);\n                var ca = Math.cos(angle);\n                var score = 0;\n                for (var k = 0; k < fromSubpathBezier.length; k += 2) {\n                    var x0 = newFromSubpathBezier[k];\n                    var y0 = newFromSubpathBezier[k + 1];\n                    var x1 = toSubpathBezier[k] - toCp[0];\n                    var y1 = toSubpathBezier[k + 1] - toCp[1];\n                    var newX1 = x1 * ca - y1 * sa;\n                    var newY1 = x1 * sa + y1 * ca;\n                    tmpArr[k] = newX1;\n                    tmpArr[k + 1] = newY1;\n                    var dx = newX1 - x0;\n                    var dy = newY1 - y0;\n                    score += dx * dx + dy * dy;\n                }\n                if (score < bestScore) {\n                    bestScore = score;\n                    bestAngle = angle;\n                    for (var m = 0; m < tmpArr.length; m++) {\n                        newToSubpathBezier[m] = tmpArr[m];\n                    }\n                }\n            }\n        }\n        else {\n            for (var i_1 = 0; i_1 < len; i_1 += 2) {\n                newToSubpathBezier[i_1] = toSubpathBezier[i_1] - toCp[0];\n                newToSubpathBezier[i_1 + 1] = toSubpathBezier[i_1 + 1] - toCp[1];\n            }\n        }\n        result.push({\n            from: newFromSubpathBezier,\n            to: newToSubpathBezier,\n            fromCp: fromCp,\n            toCp: toCp,\n            rotation: -bestAngle\n        });\n    }\n    return result;\n}\nexport function isCombineMorphing(path) {\n    return path.__isCombineMorphing;\n}\nexport function isMorphing(el) {\n    return el.__morphT >= 0;\n}\nvar SAVED_METHOD_PREFIX = '__mOriginal_';\nfunction saveAndModifyMethod(obj, methodName, modifiers) {\n    var savedMethodName = SAVED_METHOD_PREFIX + methodName;\n    var originalMethod = obj[savedMethodName] || obj[methodName];\n    if (!obj[savedMethodName]) {\n        obj[savedMethodName] = obj[methodName];\n    }\n    var replace = modifiers.replace;\n    var after = modifiers.after;\n    var before = modifiers.before;\n    obj[methodName] = function () {\n        var args = arguments;\n        var res;\n        before && before.apply(this, args);\n        if (replace) {\n            res = replace.apply(this, args);\n        }\n        else {\n            res = originalMethod.apply(this, args);\n        }\n        after && after.apply(this, args);\n        return res;\n    };\n}\nfunction restoreMethod(obj, methodName) {\n    var savedMethodName = SAVED_METHOD_PREFIX + methodName;\n    if (obj[savedMethodName]) {\n        obj[methodName] = obj[savedMethodName];\n        obj[savedMethodName] = null;\n    }\n}\nfunction applyTransformOnBeziers(bezierCurves, mm) {\n    for (var i = 0; i < bezierCurves.length; i++) {\n        var subBeziers = bezierCurves[i];\n        for (var k = 0; k < subBeziers.length;) {\n            var x = subBeziers[k];\n            var y = subBeziers[k + 1];\n            subBeziers[k++] = mm[0] * x + mm[2] * y + mm[4];\n            subBeziers[k++] = mm[1] * x + mm[3] * y + mm[5];\n        }\n    }\n}\nfunction prepareMorphPath(fromPath, toPath) {\n    var fromPathProxy = fromPath.getUpdatedPathProxy();\n    var toPathProxy = toPath.getUpdatedPathProxy();\n    var _a = alignBezierCurves(pathToBezierCurves(fromPathProxy), pathToBezierCurves(toPathProxy)), fromBezierCurves = _a[0], toBezierCurves = _a[1];\n    var fromPathTransform = fromPath.getComputedTransform();\n    var toPathTransform = toPath.getComputedTransform();\n    function updateIdentityTransform() {\n        this.transform = null;\n    }\n    fromPathTransform && applyTransformOnBeziers(fromBezierCurves, fromPathTransform);\n    toPathTransform && applyTransformOnBeziers(toBezierCurves, toPathTransform);\n    saveAndModifyMethod(toPath, 'updateTransform', { replace: updateIdentityTransform });\n    toPath.transform = null;\n    var morphingData = findBestMorphingRotation(fromBezierCurves, toBezierCurves, 10, Math.PI);\n    var tmpArr = [];\n    saveAndModifyMethod(toPath, 'buildPath', { replace: function (path) {\n            var t = toPath.__morphT;\n            var onet = 1 - t;\n            var newCp = [];\n            for (var i = 0; i < morphingData.length; i++) {\n                var item = morphingData[i];\n                var from = item.from;\n                var to = item.to;\n                var angle = item.rotation * t;\n                var fromCp = item.fromCp;\n                var toCp = item.toCp;\n                var sa = Math.sin(angle);\n                var ca = Math.cos(angle);\n                lerp(newCp, fromCp, toCp, t);\n                for (var m = 0; m < from.length; m += 2) {\n                    var x0_1 = from[m];\n                    var y0_1 = from[m + 1];\n                    var x1 = to[m];\n                    var y1 = to[m + 1];\n                    var x = x0_1 * onet + x1 * t;\n                    var y = y0_1 * onet + y1 * t;\n                    tmpArr[m] = (x * ca - y * sa) + newCp[0];\n                    tmpArr[m + 1] = (x * sa + y * ca) + newCp[1];\n                }\n                var x0 = tmpArr[0];\n                var y0 = tmpArr[1];\n                path.moveTo(x0, y0);\n                for (var m = 2; m < from.length;) {\n                    var x1 = tmpArr[m++];\n                    var y1 = tmpArr[m++];\n                    var x2 = tmpArr[m++];\n                    var y2 = tmpArr[m++];\n                    var x3 = tmpArr[m++];\n                    var y3 = tmpArr[m++];\n                    if (x0 === x1 && y0 === y1 && x2 === x3 && y2 === y3) {\n                        path.lineTo(x3, y3);\n                    }\n                    else {\n                        path.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n                    }\n                    x0 = x3;\n                    y0 = y3;\n                }\n            }\n        } });\n}\nexport function morphPath(fromPath, toPath, animationOpts) {\n    if (!fromPath || !toPath) {\n        return toPath;\n    }\n    var oldDone = animationOpts.done;\n    var oldDuring = animationOpts.during;\n    prepareMorphPath(fromPath, toPath);\n    toPath.__morphT = 0;\n    function restoreToPath() {\n        restoreMethod(toPath, 'buildPath');\n        restoreMethod(toPath, 'updateTransform');\n        toPath.__morphT = -1;\n        toPath.createPathProxy();\n        toPath.dirtyShape();\n    }\n    toPath.animateTo({\n        __morphT: 1\n    }, defaults({\n        during: function (p) {\n            toPath.dirtyShape();\n            oldDuring && oldDuring(p);\n        },\n        done: function () {\n            restoreToPath();\n            oldDone && oldDone();\n        }\n    }, animationOpts));\n    return toPath;\n}\nfunction hilbert(x, y, minX, minY, maxX, maxY) {\n    var bits = 16;\n    x = (maxX === minX) ? 0 : Math.round(32767 * (x - minX) / (maxX - minX));\n    y = (maxY === minY) ? 0 : Math.round(32767 * (y - minY) / (maxY - minY));\n    var d = 0;\n    var tmp;\n    for (var s = (1 << bits) / 2; s > 0; s /= 2) {\n        var rx = 0;\n        var ry = 0;\n        if ((x & s) > 0) {\n            rx = 1;\n        }\n        if ((y & s) > 0) {\n            ry = 1;\n        }\n        d += s * s * ((3 * rx) ^ ry);\n        if (ry === 0) {\n            if (rx === 1) {\n                x = s - 1 - x;\n                y = s - 1 - y;\n            }\n            tmp = x;\n            x = y;\n            y = tmp;\n        }\n    }\n    return d;\n}\nfunction sortPaths(pathList) {\n    var xMin = Infinity;\n    var yMin = Infinity;\n    var xMax = -Infinity;\n    var yMax = -Infinity;\n    var cps = map(pathList, function (path) {\n        var rect = path.getBoundingRect();\n        var m = path.getComputedTransform();\n        var x = rect.x + rect.width / 2 + (m ? m[4] : 0);\n        var y = rect.y + rect.height / 2 + (m ? m[5] : 0);\n        xMin = Math.min(x, xMin);\n        yMin = Math.min(y, yMin);\n        xMax = Math.max(x, xMax);\n        yMax = Math.max(y, yMax);\n        return [x, y];\n    });\n    var items = map(cps, function (cp, idx) {\n        return {\n            cp: cp,\n            z: hilbert(cp[0], cp[1], xMin, yMin, xMax, yMax),\n            path: pathList[idx]\n        };\n    });\n    return items.sort(function (a, b) { return a.z - b.z; }).map(function (item) { return item.path; });\n}\n;\nfunction defaultDividePath(param) {\n    return split(param.path, param.count);\n}\nfunction createEmptyReturn() {\n    return {\n        fromIndividuals: [],\n        toIndividuals: [],\n        count: 0\n    };\n}\nexport function combineMorph(fromList, toPath, animationOpts) {\n    var fromPathList = [];\n    function addFromPath(fromList) {\n        for (var i = 0; i < fromList.length; i++) {\n            var from = fromList[i];\n            if (isCombineMorphing(from)) {\n                addFromPath(from.childrenRef());\n            }\n            else if (from instanceof Path) {\n                fromPathList.push(from);\n            }\n        }\n    }\n    addFromPath(fromList);\n    var separateCount = fromPathList.length;\n    if (!separateCount) {\n        return createEmptyReturn();\n    }\n    var dividePath = animationOpts.dividePath || defaultDividePath;\n    var toSubPathList = dividePath({\n        path: toPath, count: separateCount\n    });\n    if (toSubPathList.length !== separateCount) {\n        console.error('Invalid morphing: unmatched splitted path');\n        return createEmptyReturn();\n    }\n    fromPathList = sortPaths(fromPathList);\n    toSubPathList = sortPaths(toSubPathList);\n    var oldDone = animationOpts.done;\n    var oldDuring = animationOpts.during;\n    var individualDelay = animationOpts.individualDelay;\n    var identityTransform = new Transformable();\n    for (var i = 0; i < separateCount; i++) {\n        var from = fromPathList[i];\n        var to = toSubPathList[i];\n        to.parent = toPath;\n        to.copyTransform(identityTransform);\n        if (!individualDelay) {\n            prepareMorphPath(from, to);\n        }\n    }\n    toPath.__isCombineMorphing = true;\n    toPath.childrenRef = function () {\n        return toSubPathList;\n    };\n    function addToSubPathListToZr(zr) {\n        for (var i = 0; i < toSubPathList.length; i++) {\n            toSubPathList[i].addSelfToZr(zr);\n        }\n    }\n    saveAndModifyMethod(toPath, 'addSelfToZr', {\n        after: function (zr) {\n            addToSubPathListToZr(zr);\n        }\n    });\n    saveAndModifyMethod(toPath, 'removeSelfFromZr', {\n        after: function (zr) {\n            for (var i = 0; i < toSubPathList.length; i++) {\n                toSubPathList[i].removeSelfFromZr(zr);\n            }\n        }\n    });\n    function restoreToPath() {\n        toPath.__isCombineMorphing = false;\n        toPath.__morphT = -1;\n        toPath.childrenRef = null;\n        restoreMethod(toPath, 'addSelfToZr');\n        restoreMethod(toPath, 'removeSelfFromZr');\n    }\n    var toLen = toSubPathList.length;\n    if (individualDelay) {\n        var animating_1 = toLen;\n        var eachDone = function () {\n            animating_1--;\n            if (animating_1 === 0) {\n                restoreToPath();\n                oldDone && oldDone();\n            }\n        };\n        for (var i = 0; i < toLen; i++) {\n            var indivdualAnimationOpts = individualDelay ? defaults({\n                delay: (animationOpts.delay || 0) + individualDelay(i, toLen, fromPathList[i], toSubPathList[i]),\n                done: eachDone\n            }, animationOpts) : animationOpts;\n            morphPath(fromPathList[i], toSubPathList[i], indivdualAnimationOpts);\n        }\n    }\n    else {\n        toPath.__morphT = 0;\n        toPath.animateTo({\n            __morphT: 1\n        }, defaults({\n            during: function (p) {\n                for (var i = 0; i < toLen; i++) {\n                    var child = toSubPathList[i];\n                    child.__morphT = toPath.__morphT;\n                    child.dirtyShape();\n                }\n                oldDuring && oldDuring(p);\n            },\n            done: function () {\n                restoreToPath();\n                for (var i = 0; i < fromList.length; i++) {\n                    restoreMethod(fromList[i], 'updateTransform');\n                }\n                oldDone && oldDone();\n            }\n        }, animationOpts));\n    }\n    if (toPath.__zr) {\n        addToSubPathListToZr(toPath.__zr);\n    }\n    return {\n        fromIndividuals: fromPathList,\n        toIndividuals: toSubPathList,\n        count: toLen\n    };\n}\nexport function separateMorph(fromPath, toPathList, animationOpts) {\n    var toLen = toPathList.length;\n    var fromPathList = [];\n    var dividePath = animationOpts.dividePath || defaultDividePath;\n    function addFromPath(fromList) {\n        for (var i = 0; i < fromList.length; i++) {\n            var from = fromList[i];\n            if (isCombineMorphing(from)) {\n                addFromPath(from.childrenRef());\n            }\n            else if (from instanceof Path) {\n                fromPathList.push(from);\n            }\n        }\n    }\n    if (isCombineMorphing(fromPath)) {\n        addFromPath(fromPath.childrenRef());\n        var fromLen = fromPathList.length;\n        if (fromLen < toLen) {\n            var k = 0;\n            for (var i = fromLen; i < toLen; i++) {\n                fromPathList.push(clonePath(fromPathList[k++ % fromLen]));\n            }\n        }\n        fromPathList.length = toLen;\n    }\n    else {\n        fromPathList = dividePath({ path: fromPath, count: toLen });\n        var fromPathTransform = fromPath.getComputedTransform();\n        for (var i = 0; i < fromPathList.length; i++) {\n            fromPathList[i].setLocalTransform(fromPathTransform);\n        }\n        if (fromPathList.length !== toLen) {\n            console.error('Invalid morphing: unmatched splitted path');\n            return createEmptyReturn();\n        }\n    }\n    fromPathList = sortPaths(fromPathList);\n    toPathList = sortPaths(toPathList);\n    var individualDelay = animationOpts.individualDelay;\n    for (var i = 0; i < toLen; i++) {\n        var indivdualAnimationOpts = individualDelay ? defaults({\n            delay: (animationOpts.delay || 0) + individualDelay(i, toLen, fromPathList[i], toPathList[i])\n        }, animationOpts) : animationOpts;\n        morphPath(fromPathList[i], toPathList[i], indivdualAnimationOpts);\n    }\n    return {\n        fromIndividuals: fromPathList,\n        toIndividuals: toPathList,\n        count: toPathList.length\n    };\n}\nexport { split as defaultDividePath };\n", "\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { separateMorph, combineMorph, morphPath, isCombineMorphing } from 'zrender/lib/tool/morphPath.js';\nimport { Path } from '../util/graphic.js';\nimport { defaults, isArray } from 'zrender/lib/core/util.js';\nimport { getAnimationConfig } from './basicTransition.js';\nimport { clonePath } from 'zrender/lib/tool/path.js';\nfunction isMultiple(elements) {\n  return isArray(elements[0]);\n}\nfunction prepareMorphBatches(one, many) {\n  var batches = [];\n  var batchCount = one.length;\n  for (var i = 0; i < batchCount; i++) {\n    batches.push({\n      one: one[i],\n      many: []\n    });\n  }\n  for (var i = 0; i < many.length; i++) {\n    var len = many[i].length;\n    var k = void 0;\n    for (k = 0; k < len; k++) {\n      batches[k % batchCount].many.push(many[i][k]);\n    }\n  }\n  var off = 0;\n  // If one has more paths than each one of many. average them.\n  for (var i = batchCount - 1; i >= 0; i--) {\n    if (!batches[i].many.length) {\n      var moveFrom = batches[off].many;\n      if (moveFrom.length <= 1) {\n        // Not enough\n        // Start from the first one.\n        if (off) {\n          off = 0;\n        } else {\n          return batches;\n        }\n      }\n      var len = moveFrom.length;\n      var mid = Math.ceil(len / 2);\n      batches[i].many = moveFrom.slice(mid, len);\n      batches[off].many = moveFrom.slice(0, mid);\n      off++;\n    }\n  }\n  return batches;\n}\nvar pathDividers = {\n  clone: function (params) {\n    var ret = [];\n    // Fitting the alpha\n    var approxOpacity = 1 - Math.pow(1 - params.path.style.opacity, 1 / params.count);\n    for (var i = 0; i < params.count; i++) {\n      var cloned = clonePath(params.path);\n      cloned.setStyle('opacity', approxOpacity);\n      ret.push(cloned);\n    }\n    return ret;\n  },\n  // Use the default divider\n  split: null\n};\nexport function applyMorphAnimation(from, to, divideShape, seriesModel, dataIndex, animateOtherProps) {\n  if (!from.length || !to.length) {\n    return;\n  }\n  var updateAnimationCfg = getAnimationConfig('update', seriesModel, dataIndex);\n  if (!(updateAnimationCfg && updateAnimationCfg.duration > 0)) {\n    return;\n  }\n  var animationDelay = seriesModel.getModel('universalTransition').get('delay');\n  var animationCfg = Object.assign({\n    // Need to setToFinal so the further calculation based on the style can be correct.\n    // Like emphasis color.\n    setToFinal: true\n  }, updateAnimationCfg);\n  var many;\n  var one;\n  if (isMultiple(from)) {\n    // manyToOne\n    many = from;\n    one = to;\n  }\n  if (isMultiple(to)) {\n    // oneToMany\n    many = to;\n    one = from;\n  }\n  function morphOneBatch(batch, fromIsMany, animateIndex, animateCount, forceManyOne) {\n    var batchMany = batch.many;\n    var batchOne = batch.one;\n    if (batchMany.length === 1 && !forceManyOne) {\n      // Is one to one\n      var batchFrom = fromIsMany ? batchMany[0] : batchOne;\n      var batchTo = fromIsMany ? batchOne : batchMany[0];\n      if (isCombineMorphing(batchFrom)) {\n        // Keep doing combine animation.\n        morphOneBatch({\n          many: [batchFrom],\n          one: batchTo\n        }, true, animateIndex, animateCount, true);\n      } else {\n        var individualAnimationCfg = animationDelay ? defaults({\n          delay: animationDelay(animateIndex, animateCount)\n        }, animationCfg) : animationCfg;\n        morphPath(batchFrom, batchTo, individualAnimationCfg);\n        animateOtherProps(batchFrom, batchTo, batchFrom, batchTo, individualAnimationCfg);\n      }\n    } else {\n      var separateAnimationCfg = defaults({\n        dividePath: pathDividers[divideShape],\n        individualDelay: animationDelay && function (idx, count, fromPath, toPath) {\n          return animationDelay(idx + animateIndex, animateCount);\n        }\n      }, animationCfg);\n      var _a = fromIsMany ? combineMorph(batchMany, batchOne, separateAnimationCfg) : separateMorph(batchOne, batchMany, separateAnimationCfg),\n        fromIndividuals = _a.fromIndividuals,\n        toIndividuals = _a.toIndividuals;\n      var count = fromIndividuals.length;\n      for (var k = 0; k < count; k++) {\n        var individualAnimationCfg = animationDelay ? defaults({\n          delay: animationDelay(k, count)\n        }, animationCfg) : animationCfg;\n        animateOtherProps(fromIndividuals[k], toIndividuals[k], fromIsMany ? batchMany[k] : batch.one, fromIsMany ? batch.one : batchMany[k], individualAnimationCfg);\n      }\n    }\n  }\n  var fromIsMany = many ? many === from\n  // Is one to one. If the path number not match. also needs do merge and separate morphing.\n  : from.length > to.length;\n  var morphBatches = many ? prepareMorphBatches(one, many) : prepareMorphBatches(fromIsMany ? to : from, [fromIsMany ? from : to]);\n  var animateCount = 0;\n  for (var i = 0; i < morphBatches.length; i++) {\n    animateCount += morphBatches[i].many.length;\n  }\n  var animateIndex = 0;\n  for (var i = 0; i < morphBatches.length; i++) {\n    morphOneBatch(morphBatches[i], fromIsMany, animateIndex, animateCount);\n    animateIndex += morphBatches[i].many.length;\n  }\n}\nexport function getPathList(elements) {\n  if (!elements) {\n    return [];\n  }\n  if (isArray(elements)) {\n    var pathList_1 = [];\n    for (var i = 0; i < elements.length; i++) {\n      pathList_1.push(getPathList(elements[i]));\n    }\n    return pathList_1;\n  }\n  var pathList = [];\n  elements.traverse(function (el) {\n    if (el instanceof Path && !el.disableMorphing && !el.invisible && !el.ignore) {\n      pathList.push(el);\n    }\n  });\n  return pathList;\n}", "\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// Universal transitions that can animate between any shapes(series) and any properties in any amounts.\nimport { SERIES_UNIVERSAL_TRANSITION_PROP } from '../model/Series.js';\nimport { createHashMap, each, map, filter, isArray, extend } from 'zrender/lib/core/util.js';\nimport { applyMorphAnimation, getPathList } from './morphTransitionHelper.js';\nimport Path from 'zrender/lib/graphic/Path.js';\nimport { initProps } from '../util/graphic.js';\nimport DataDiffer from '../data/DataDiffer.js';\nimport { makeInner, normalizeToArray } from '../util/model.js';\nimport { warn } from '../util/log.js';\nimport { getAnimationConfig, getOldStyle } from './basicTransition.js';\nimport Displayable from 'zrender/lib/graphic/Displayable.js';\nvar DATA_COUNT_THRESHOLD = 1e4;\nvar TRANSITION_NONE = 0;\nvar TRANSITION_P2C = 1;\nvar TRANSITION_C2P = 2;\n;\nvar getUniversalTransitionGlobalStore = makeInner();\nfunction getDimension(data, visualDimension) {\n  var dimensions = data.dimensions;\n  for (var i = 0; i < dimensions.length; i++) {\n    var dimInfo = data.getDimensionInfo(dimensions[i]);\n    if (dimInfo && dimInfo.otherDims[visualDimension] === 0) {\n      return dimensions[i];\n    }\n  }\n}\n// get value by dimension. (only get value of itemGroupId or childGroupId, so convert it to string)\nfunction getValueByDimension(data, dataIndex, dimension) {\n  var dimInfo = data.getDimensionInfo(dimension);\n  var dimOrdinalMeta = dimInfo && dimInfo.ordinalMeta;\n  if (dimInfo) {\n    var value = data.get(dimInfo.name, dataIndex);\n    if (dimOrdinalMeta) {\n      return dimOrdinalMeta.categories[value] || value + '';\n    }\n    return value + '';\n  }\n}\nfunction getGroupId(data, dataIndex, dataGroupId, isChild) {\n  // try to get groupId from encode\n  var visualDimension = isChild ? 'itemChildGroupId' : 'itemGroupId';\n  var groupIdDim = getDimension(data, visualDimension);\n  if (groupIdDim) {\n    var groupId = getValueByDimension(data, dataIndex, groupIdDim);\n    return groupId;\n  }\n  // try to get groupId from raw data item\n  var rawDataItem = data.getRawDataItem(dataIndex);\n  var property = isChild ? 'childGroupId' : 'groupId';\n  if (rawDataItem && rawDataItem[property]) {\n    return rawDataItem[property] + '';\n  }\n  // fallback\n  if (isChild) {\n    return;\n  }\n  // try to use series.dataGroupId as groupId, otherwise use dataItem's id as groupId\n  return dataGroupId || data.getId(dataIndex);\n}\n// flatten all data items from different serieses into one arrary\nfunction flattenDataDiffItems(list) {\n  var items = [];\n  each(list, function (seriesInfo) {\n    var data = seriesInfo.data;\n    var dataGroupId = seriesInfo.dataGroupId;\n    if (data.count() > DATA_COUNT_THRESHOLD) {\n      if (process.env.NODE_ENV !== 'production') {\n        warn('Universal transition is disabled on large data > 10k.');\n      }\n      return;\n    }\n    var indices = data.getIndices();\n    for (var dataIndex = 0; dataIndex < indices.length; dataIndex++) {\n      items.push({\n        data: data,\n        groupId: getGroupId(data, dataIndex, dataGroupId, false),\n        childGroupId: getGroupId(data, dataIndex, dataGroupId, true),\n        divide: seriesInfo.divide,\n        dataIndex: dataIndex\n      });\n    }\n  });\n  return items;\n}\nfunction fadeInElement(newEl, newSeries, newIndex) {\n  newEl.traverse(function (el) {\n    if (el instanceof Path) {\n      // TODO use fade in animation for target element.\n      initProps(el, {\n        style: {\n          opacity: 0\n        }\n      }, newSeries, {\n        dataIndex: newIndex,\n        isFrom: true\n      });\n    }\n  });\n}\nfunction removeEl(el) {\n  if (el.parent) {\n    // Bake parent transform to element.\n    // So it can still have proper transform to transition after it's removed.\n    var computedTransform = el.getComputedTransform();\n    el.setLocalTransform(computedTransform);\n    el.parent.remove(el);\n  }\n}\nfunction stopAnimation(el) {\n  el.stopAnimation();\n  if (el.isGroup) {\n    el.traverse(function (child) {\n      child.stopAnimation();\n    });\n  }\n}\nfunction animateElementStyles(el, dataIndex, seriesModel) {\n  var animationConfig = getAnimationConfig('update', seriesModel, dataIndex);\n  animationConfig && el.traverse(function (child) {\n    if (child instanceof Displayable) {\n      var oldStyle = getOldStyle(child);\n      if (oldStyle) {\n        child.animateFrom({\n          style: oldStyle\n        }, animationConfig);\n      }\n    }\n  });\n}\nfunction isAllIdSame(oldDiffItems, newDiffItems) {\n  var len = oldDiffItems.length;\n  if (len !== newDiffItems.length) {\n    return false;\n  }\n  for (var i = 0; i < len; i++) {\n    var oldItem = oldDiffItems[i];\n    var newItem = newDiffItems[i];\n    if (oldItem.data.getId(oldItem.dataIndex) !== newItem.data.getId(newItem.dataIndex)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction transitionBetween(oldList, newList, api) {\n  var oldDiffItems = flattenDataDiffItems(oldList);\n  var newDiffItems = flattenDataDiffItems(newList);\n  function updateMorphingPathProps(from, to, rawFrom, rawTo, animationCfg) {\n    if (rawFrom || from) {\n      to.animateFrom({\n        style: rawFrom && rawFrom !== from\n        // dividingMethod like clone may override the style(opacity)\n        // So extend it to raw style.\n        ? extend(extend({}, rawFrom.style), from.style) : from.style\n      }, animationCfg);\n    }\n  }\n  var hasMorphAnimation = false;\n  /**\n   * With groupId and childGroupId, we can build parent-child relationships between dataItems.\n   * However, we should mind the parent-child \"direction\" between old and new options.\n   *\n   * For example, suppose we have two dataItems from two series.data:\n   *\n   * dataA: [                          dataB: [\n   *   {                                 {\n   *     value: 5,                         value: 3,\n   *     groupId: 'creatures',             groupId: 'animals',\n   *     childGroupId: 'animals'           childGroupId: 'dogs'\n   *   },                                },\n   *   ...                               ...\n   * ]                                 ]\n   *\n   * where dataA is belong to optionA and dataB is belong to optionB.\n   *\n   * When we `setOption(optionB)` from optionA, we choose childGroupId of dataItemA and groupId of\n   * dataItemB as keys so the two keys are matched (both are 'animals'), then universalTransition\n   * will work. This derection is \"parent -> child\".\n   *\n   * If we `setOption(optionA)` from optionB, we also choose groupId of dataItemB and childGroupId\n   * of dataItemA as keys and universalTransition will work. This derection is \"child -> parent\".\n   *\n   * If there is no childGroupId specified, which means no multiLevelDrillDown/Up is needed and no\n   * parent-child relationship exists. This direction is \"none\".\n   *\n   * So we need to know whether to use groupId or childGroupId as the key when we call the keyGetter\n   * functions. Thus, we need to decide the direction first.\n   *\n   * The rule is:\n   *\n   * if (all childGroupIds in oldDiffItems and all groupIds in newDiffItems have common value) {\n   *   direction = 'parent -> child';\n   * } else if (all groupIds in oldDiffItems and all childGroupIds in newDiffItems have common value) {\n   *   direction = 'child -> parent';\n   * } else {\n   *   direction = 'none';\n   * }\n   */\n  var direction = TRANSITION_NONE;\n  // find all groupIds and childGroupIds from oldDiffItems\n  var oldGroupIds = createHashMap();\n  var oldChildGroupIds = createHashMap();\n  oldDiffItems.forEach(function (item) {\n    item.groupId && oldGroupIds.set(item.groupId, true);\n    item.childGroupId && oldChildGroupIds.set(item.childGroupId, true);\n  });\n  // traverse newDiffItems and decide the direction according to the rule\n  for (var i = 0; i < newDiffItems.length; i++) {\n    var newGroupId = newDiffItems[i].groupId;\n    if (oldChildGroupIds.get(newGroupId)) {\n      direction = TRANSITION_P2C;\n      break;\n    }\n    var newChildGroupId = newDiffItems[i].childGroupId;\n    if (newChildGroupId && oldGroupIds.get(newChildGroupId)) {\n      direction = TRANSITION_C2P;\n      break;\n    }\n  }\n  function createKeyGetter(isOld, onlyGetId) {\n    return function (diffItem) {\n      var data = diffItem.data;\n      var dataIndex = diffItem.dataIndex;\n      // TODO if specified dim\n      if (onlyGetId) {\n        return data.getId(dataIndex);\n      }\n      if (isOld) {\n        return direction === TRANSITION_P2C ? diffItem.childGroupId : diffItem.groupId;\n      } else {\n        return direction === TRANSITION_C2P ? diffItem.childGroupId : diffItem.groupId;\n      }\n    };\n  }\n  // Use id if it's very likely to be an one to one animation\n  // It's more robust than groupId\n  // TODO Check if key dimension is specified.\n  var useId = isAllIdSame(oldDiffItems, newDiffItems);\n  var isElementStillInChart = {};\n  if (!useId) {\n    // We may have different diff strategy with basicTransition if we use other dimension as key.\n    // If so, we can't simply check if oldEl is same with newEl. We need a map to check if oldEl is still being used in the new chart.\n    // We can't use the elements that already being morphed. Let it keep it's original basic transition.\n    for (var i = 0; i < newDiffItems.length; i++) {\n      var newItem = newDiffItems[i];\n      var el = newItem.data.getItemGraphicEl(newItem.dataIndex);\n      if (el) {\n        isElementStillInChart[el.id] = true;\n      }\n    }\n  }\n  function updateOneToOne(newIndex, oldIndex) {\n    var oldItem = oldDiffItems[oldIndex];\n    var newItem = newDiffItems[newIndex];\n    var newSeries = newItem.data.hostModel;\n    // TODO Mark this elements is morphed and don't morph them anymore\n    var oldEl = oldItem.data.getItemGraphicEl(oldItem.dataIndex);\n    var newEl = newItem.data.getItemGraphicEl(newItem.dataIndex);\n    // Can't handle same elements.\n    if (oldEl === newEl) {\n      newEl && animateElementStyles(newEl, newItem.dataIndex, newSeries);\n      return;\n    }\n    if (\n    // We can't use the elements that already being morphed\n    oldEl && isElementStillInChart[oldEl.id]) {\n      return;\n    }\n    if (newEl) {\n      // TODO: If keep animating the group in case\n      // some of the elements don't want to be morphed.\n      // TODO Label?\n      stopAnimation(newEl);\n      if (oldEl) {\n        stopAnimation(oldEl);\n        // If old element is doing leaving animation. stop it and remove it immediately.\n        removeEl(oldEl);\n        hasMorphAnimation = true;\n        applyMorphAnimation(getPathList(oldEl), getPathList(newEl), newItem.divide, newSeries, newIndex, updateMorphingPathProps);\n      } else {\n        fadeInElement(newEl, newSeries, newIndex);\n      }\n    }\n    // else keep oldEl leaving animation.\n  }\n  new DataDiffer(oldDiffItems, newDiffItems, createKeyGetter(true, useId), createKeyGetter(false, useId), null, 'multiple').update(updateOneToOne).updateManyToOne(function (newIndex, oldIndices) {\n    var newItem = newDiffItems[newIndex];\n    var newData = newItem.data;\n    var newSeries = newData.hostModel;\n    var newEl = newData.getItemGraphicEl(newItem.dataIndex);\n    var oldElsList = filter(map(oldIndices, function (idx) {\n      return oldDiffItems[idx].data.getItemGraphicEl(oldDiffItems[idx].dataIndex);\n    }), function (oldEl) {\n      return oldEl && oldEl !== newEl && !isElementStillInChart[oldEl.id];\n    });\n    if (newEl) {\n      stopAnimation(newEl);\n      if (oldElsList.length) {\n        // If old element is doing leaving animation. stop it and remove it immediately.\n        each(oldElsList, function (oldEl) {\n          stopAnimation(oldEl);\n          removeEl(oldEl);\n        });\n        hasMorphAnimation = true;\n        applyMorphAnimation(getPathList(oldElsList), getPathList(newEl), newItem.divide, newSeries, newIndex, updateMorphingPathProps);\n      } else {\n        fadeInElement(newEl, newSeries, newItem.dataIndex);\n      }\n    }\n    // else keep oldEl leaving animation.\n  }).updateOneToMany(function (newIndices, oldIndex) {\n    var oldItem = oldDiffItems[oldIndex];\n    var oldEl = oldItem.data.getItemGraphicEl(oldItem.dataIndex);\n    // We can't use the elements that already being morphed\n    if (oldEl && isElementStillInChart[oldEl.id]) {\n      return;\n    }\n    var newElsList = filter(map(newIndices, function (idx) {\n      return newDiffItems[idx].data.getItemGraphicEl(newDiffItems[idx].dataIndex);\n    }), function (el) {\n      return el && el !== oldEl;\n    });\n    var newSeris = newDiffItems[newIndices[0]].data.hostModel;\n    if (newElsList.length) {\n      each(newElsList, function (newEl) {\n        return stopAnimation(newEl);\n      });\n      if (oldEl) {\n        stopAnimation(oldEl);\n        // If old element is doing leaving animation. stop it and remove it immediately.\n        removeEl(oldEl);\n        hasMorphAnimation = true;\n        applyMorphAnimation(getPathList(oldEl), getPathList(newElsList), oldItem.divide,\n        // Use divide on old.\n        newSeris, newIndices[0], updateMorphingPathProps);\n      } else {\n        each(newElsList, function (newEl) {\n          return fadeInElement(newEl, newSeris, newIndices[0]);\n        });\n      }\n    }\n    // else keep oldEl leaving animation.\n  }).updateManyToMany(function (newIndices, oldIndices) {\n    // If two data are same and both have groupId.\n    // Normally they should be diff by id.\n    new DataDiffer(oldIndices, newIndices, function (rawIdx) {\n      return oldDiffItems[rawIdx].data.getId(oldDiffItems[rawIdx].dataIndex);\n    }, function (rawIdx) {\n      return newDiffItems[rawIdx].data.getId(newDiffItems[rawIdx].dataIndex);\n    }).update(function (newIndex, oldIndex) {\n      // Use the original index\n      updateOneToOne(newIndices[newIndex], oldIndices[oldIndex]);\n    }).execute();\n  }).execute();\n  if (hasMorphAnimation) {\n    each(newList, function (_a) {\n      var data = _a.data;\n      var seriesModel = data.hostModel;\n      var view = seriesModel && api.getViewOfSeriesModel(seriesModel);\n      var animationCfg = getAnimationConfig('update', seriesModel, 0); // use 0 index.\n      if (view && seriesModel.isAnimationEnabled() && animationCfg && animationCfg.duration > 0) {\n        view.group.traverse(function (el) {\n          if (el instanceof Path && !el.animators.length) {\n            // We can't accept there still exists element that has no animation\n            // if universalTransition is enabled\n            el.animateFrom({\n              style: {\n                opacity: 0\n              }\n            }, animationCfg);\n          }\n        });\n      }\n    });\n  }\n}\nfunction getSeriesTransitionKey(series) {\n  var seriesKey = series.getModel('universalTransition').get('seriesKey');\n  if (!seriesKey) {\n    // Use series id by default.\n    return series.id;\n  }\n  return seriesKey;\n}\nfunction convertArraySeriesKeyToString(seriesKey) {\n  if (isArray(seriesKey)) {\n    // Order independent.\n    return seriesKey.sort().join(',');\n  }\n  return seriesKey;\n}\nfunction getDivideShapeFromData(data) {\n  if (data.hostModel) {\n    return data.hostModel.getModel('universalTransition').get('divideShape');\n  }\n}\nfunction findTransitionSeriesBatches(globalStore, params) {\n  var updateBatches = createHashMap();\n  var oldDataMap = createHashMap();\n  // Map that only store key in array seriesKey.\n  // Which is used to query the old data when transition from one to multiple series.\n  var oldDataMapForSplit = createHashMap();\n  each(globalStore.oldSeries, function (series, idx) {\n    var oldDataGroupId = globalStore.oldDataGroupIds[idx];\n    var oldData = globalStore.oldData[idx];\n    var transitionKey = getSeriesTransitionKey(series);\n    var transitionKeyStr = convertArraySeriesKeyToString(transitionKey);\n    oldDataMap.set(transitionKeyStr, {\n      dataGroupId: oldDataGroupId,\n      data: oldData\n    });\n    if (isArray(transitionKey)) {\n      // Same key can't in different array seriesKey.\n      each(transitionKey, function (key) {\n        oldDataMapForSplit.set(key, {\n          key: transitionKeyStr,\n          dataGroupId: oldDataGroupId,\n          data: oldData\n        });\n      });\n    }\n  });\n  function checkTransitionSeriesKeyDuplicated(transitionKeyStr) {\n    if (updateBatches.get(transitionKeyStr)) {\n      warn(\"Duplicated seriesKey in universalTransition \" + transitionKeyStr);\n    }\n  }\n  each(params.updatedSeries, function (series) {\n    if (series.isUniversalTransitionEnabled() && series.isAnimationEnabled()) {\n      var newDataGroupId = series.get('dataGroupId');\n      var newData = series.getData();\n      var transitionKey = getSeriesTransitionKey(series);\n      var transitionKeyStr = convertArraySeriesKeyToString(transitionKey);\n      // Only transition between series with same id.\n      var oldData = oldDataMap.get(transitionKeyStr);\n      // string transition key is the best match.\n      if (oldData) {\n        if (process.env.NODE_ENV !== 'production') {\n          checkTransitionSeriesKeyDuplicated(transitionKeyStr);\n        }\n        // TODO check if data is same?\n        updateBatches.set(transitionKeyStr, {\n          oldSeries: [{\n            dataGroupId: oldData.dataGroupId,\n            divide: getDivideShapeFromData(oldData.data),\n            data: oldData.data\n          }],\n          newSeries: [{\n            dataGroupId: newDataGroupId,\n            divide: getDivideShapeFromData(newData),\n            data: newData\n          }]\n        });\n      } else {\n        // Transition from multiple series.\n        // e.g. 'female', 'male' -> ['female', 'male']\n        if (isArray(transitionKey)) {\n          if (process.env.NODE_ENV !== 'production') {\n            checkTransitionSeriesKeyDuplicated(transitionKeyStr);\n          }\n          var oldSeries_1 = [];\n          each(transitionKey, function (key) {\n            var oldData = oldDataMap.get(key);\n            if (oldData.data) {\n              oldSeries_1.push({\n                dataGroupId: oldData.dataGroupId,\n                divide: getDivideShapeFromData(oldData.data),\n                data: oldData.data\n              });\n            }\n          });\n          if (oldSeries_1.length) {\n            updateBatches.set(transitionKeyStr, {\n              oldSeries: oldSeries_1,\n              newSeries: [{\n                dataGroupId: newDataGroupId,\n                data: newData,\n                divide: getDivideShapeFromData(newData)\n              }]\n            });\n          }\n        } else {\n          // Try transition to multiple series.\n          // e.g. ['female', 'male'] -> 'female', 'male'\n          var oldData_1 = oldDataMapForSplit.get(transitionKey);\n          if (oldData_1) {\n            var batch = updateBatches.get(oldData_1.key);\n            if (!batch) {\n              batch = {\n                oldSeries: [{\n                  dataGroupId: oldData_1.dataGroupId,\n                  data: oldData_1.data,\n                  divide: getDivideShapeFromData(oldData_1.data)\n                }],\n                newSeries: []\n              };\n              updateBatches.set(oldData_1.key, batch);\n            }\n            batch.newSeries.push({\n              dataGroupId: newDataGroupId,\n              data: newData,\n              divide: getDivideShapeFromData(newData)\n            });\n          }\n        }\n      }\n    }\n  });\n  return updateBatches;\n}\nfunction querySeries(series, finder) {\n  for (var i = 0; i < series.length; i++) {\n    var found = finder.seriesIndex != null && finder.seriesIndex === series[i].seriesIndex || finder.seriesId != null && finder.seriesId === series[i].id;\n    if (found) {\n      return i;\n    }\n  }\n}\nfunction transitionSeriesFromOpt(transitionOpt, globalStore, params, api) {\n  var from = [];\n  var to = [];\n  each(normalizeToArray(transitionOpt.from), function (finder) {\n    var idx = querySeries(globalStore.oldSeries, finder);\n    if (idx >= 0) {\n      from.push({\n        dataGroupId: globalStore.oldDataGroupIds[idx],\n        data: globalStore.oldData[idx],\n        // TODO can specify divideShape in transition.\n        divide: getDivideShapeFromData(globalStore.oldData[idx]),\n        groupIdDim: finder.dimension\n      });\n    }\n  });\n  each(normalizeToArray(transitionOpt.to), function (finder) {\n    var idx = querySeries(params.updatedSeries, finder);\n    if (idx >= 0) {\n      var data = params.updatedSeries[idx].getData();\n      to.push({\n        dataGroupId: globalStore.oldDataGroupIds[idx],\n        data: data,\n        divide: getDivideShapeFromData(data),\n        groupIdDim: finder.dimension\n      });\n    }\n  });\n  if (from.length > 0 && to.length > 0) {\n    transitionBetween(from, to, api);\n  }\n}\nexport function installUniversalTransition(registers) {\n  registers.registerUpdateLifecycle('series:beforeupdate', function (ecMOdel, api, params) {\n    each(normalizeToArray(params.seriesTransition), function (transOpt) {\n      each(normalizeToArray(transOpt.to), function (finder) {\n        var series = params.updatedSeries;\n        for (var i = 0; i < series.length; i++) {\n          if (finder.seriesIndex != null && finder.seriesIndex === series[i].seriesIndex || finder.seriesId != null && finder.seriesId === series[i].id) {\n            series[i][SERIES_UNIVERSAL_TRANSITION_PROP] = true;\n          }\n        }\n      });\n    });\n  });\n  registers.registerUpdateLifecycle('series:transition', function (ecModel, api, params) {\n    // TODO api provide an namespace that can save stuff per instance\n    var globalStore = getUniversalTransitionGlobalStore(api);\n    // TODO multiple to multiple series.\n    if (globalStore.oldSeries && params.updatedSeries && params.optionChanged) {\n      // TODO transitionOpt was used in an old implementation and can be removed now\n      // Use give transition config if its' give;\n      var transitionOpt = params.seriesTransition;\n      if (transitionOpt) {\n        each(normalizeToArray(transitionOpt), function (opt) {\n          transitionSeriesFromOpt(opt, globalStore, params, api);\n        });\n      } else {\n        // Else guess from series based on transition series key.\n        var updateBatches_1 = findTransitionSeriesBatches(globalStore, params);\n        each(updateBatches_1.keys(), function (key) {\n          var batch = updateBatches_1.get(key);\n          transitionBetween(batch.oldSeries, batch.newSeries, api);\n        });\n      }\n      // Reset\n      each(params.updatedSeries, function (series) {\n        // Reset;\n        if (series[SERIES_UNIVERSAL_TRANSITION_PROP]) {\n          series[SERIES_UNIVERSAL_TRANSITION_PROP] = false;\n        }\n      });\n    }\n    // Save all series of current update. Not only the updated one.\n    var allSeries = ecModel.getSeries();\n    var savedSeries = globalStore.oldSeries = [];\n    var savedDataGroupIds = globalStore.oldDataGroupIds = [];\n    var savedData = globalStore.oldData = [];\n    for (var i = 0; i < allSeries.length; i++) {\n      var data = allSeries[i].getData();\n      // Only save the data that can have transition.\n      // Avoid large data costing too much extra memory\n      if (data.count() < DATA_COUNT_THRESHOLD) {\n        savedSeries.push(allSeries[i]);\n        savedDataGroupIds.push(allSeries[i].get('dataGroupId'));\n        savedData.push(data);\n      }\n    }\n  });\n}", "\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { assert, clone, each, find, isString, map, trim } from 'zrender/lib/core/util.js';\nimport { error } from '../util/log.js';\nimport { registerScaleBreakHelperImpl } from './break.js';\nimport { round as fixRound } from '../util/number.js';\n/**\n * @caution\n *  Must not export anything except `installScaleBreakHelper`\n */\nvar ScaleBreakContextImpl = /** @class */function () {\n  function ScaleBreakContextImpl() {\n    // [CAVEAT]: Should set only by `ScaleBreakContext#setBreaks`!\n    this.breaks = [];\n    // [CAVEAT]: Should update only by `ScaleBreakContext#update`!\n    // They are the values that scaleExtent[0] and scaleExtent[1] are mapped to a numeric axis\n    // that breaks are applied, primarily for optimization of `Scale#normalize`.\n    this._elapsedExtent = [Infinity, -Infinity];\n  }\n  ScaleBreakContextImpl.prototype.setBreaks = function (parsed) {\n    // @ts-ignore\n    this.breaks = parsed.breaks;\n  };\n  /**\n   * [CAVEAT]: Must be called immediately each time scale extent and breaks are updated!\n   */\n  ScaleBreakContextImpl.prototype.update = function (scaleExtent) {\n    updateAxisBreakGapReal(this, scaleExtent);\n    var elapsedExtent = this._elapsedExtent;\n    elapsedExtent[0] = this.elapse(scaleExtent[0]);\n    elapsedExtent[1] = this.elapse(scaleExtent[1]);\n  };\n  ScaleBreakContextImpl.prototype.hasBreaks = function () {\n    return !!this.breaks.length;\n  };\n  /**\n   * When iteratively generating ticks by nice interval, currently the `interval`, which is\n   * calculated by break-elapsed extent span, is probably very small comparing to the original\n   * extent, leading to a large number of iteration and tick generation, even over `safeLimit`.\n   * Thus stepping over breaks is necessary in that loop.\n   *\n   * \"Nice\" should be ensured on ticks when step over the breaks. Thus this method returns\n   * a integer multiple of the \"nice tick interval\".\n   *\n   * This method does little work; it is just for unifying and restricting the behavior.\n   */\n  ScaleBreakContextImpl.prototype.calcNiceTickMultiple = function (tickVal, estimateNiceMultiple) {\n    for (var idx = 0; idx < this.breaks.length; idx++) {\n      var brk = this.breaks[idx];\n      if (brk.vmin < tickVal && tickVal < brk.vmax) {\n        var multiple = estimateNiceMultiple(tickVal, brk.vmax);\n        if (process.env.NODE_ENV !== 'production') {\n          // If not, it may cause dead loop or not nice tick.\n          assert(multiple >= 0 && Math.round(multiple) === multiple);\n        }\n        return multiple;\n      }\n    }\n    return 0;\n  };\n  ScaleBreakContextImpl.prototype.getExtentSpan = function () {\n    return this._elapsedExtent[1] - this._elapsedExtent[0];\n  };\n  ScaleBreakContextImpl.prototype.normalize = function (val) {\n    var elapsedSpan = this._elapsedExtent[1] - this._elapsedExtent[0];\n    // The same logic as `Scale#normalize`.\n    if (elapsedSpan === 0) {\n      return 0.5;\n    }\n    return (this.elapse(val) - this._elapsedExtent[0]) / elapsedSpan;\n  };\n  ScaleBreakContextImpl.prototype.scale = function (val) {\n    return this.unelapse(val * (this._elapsedExtent[1] - this._elapsedExtent[0]) + this._elapsedExtent[0]);\n  };\n  /**\n   * Suppose:\n   *    AXIS_BREAK_LAST_BREAK_END_BASE: 0\n   *    AXIS_BREAK_ELAPSED_BASE: 0\n   *    breaks: [\n   *        {start: -400, end: -300, gap: 27},\n   *        {start: -100, end: 100, gap: 10},\n   *        {start: 200, end: 400, gap: 300},\n   *    ]\n   * The mapping will be:\n   *        |        |\n   *    400 +   ->   +  237\n   *     |  |        |   |  (gap: 300)\n   *    200 +   ->   + -63\n   *        |        |\n   *    100 +   ->   + -163\n   *     |  |        |   |  (gap: 10)\n   *   -100 +   ->   + -173\n   *        |        |\n   *   -300 +   ->   + -373\n   *     |  |        |   |  (gap: 27)\n   *   -400 +   ->   + -400\n   *        |        |\n   *   origianl     elapsed\n   *\n   * Note:\n   *   The mapping has nothing to do with \"scale extent\".\n   */\n  ScaleBreakContextImpl.prototype.elapse = function (val) {\n    // If the value is in the break, return the normalized value in the break\n    var elapsedVal = AXIS_BREAK_ELAPSED_BASE;\n    var lastBreakEnd = AXIS_BREAK_LAST_BREAK_END_BASE;\n    var stillOver = true;\n    for (var i = 0; i < this.breaks.length; i++) {\n      var brk = this.breaks[i];\n      if (val <= brk.vmax) {\n        if (val > brk.vmin) {\n          elapsedVal += brk.vmin - lastBreakEnd + (val - brk.vmin) / (brk.vmax - brk.vmin) * brk.gapReal;\n        } else {\n          elapsedVal += val - lastBreakEnd;\n        }\n        lastBreakEnd = brk.vmax;\n        stillOver = false;\n        break;\n      }\n      elapsedVal += brk.vmin - lastBreakEnd + brk.gapReal;\n      lastBreakEnd = brk.vmax;\n    }\n    if (stillOver) {\n      elapsedVal += val - lastBreakEnd;\n    }\n    return elapsedVal;\n  };\n  ScaleBreakContextImpl.prototype.unelapse = function (elapsedVal) {\n    var lastElapsedEnd = AXIS_BREAK_ELAPSED_BASE;\n    var lastBreakEnd = AXIS_BREAK_LAST_BREAK_END_BASE;\n    var stillOver = true;\n    var unelapsedVal = 0;\n    for (var i = 0; i < this.breaks.length; i++) {\n      var brk = this.breaks[i];\n      var elapsedStart = lastElapsedEnd + brk.vmin - lastBreakEnd;\n      var elapsedEnd = elapsedStart + brk.gapReal;\n      if (elapsedVal <= elapsedEnd) {\n        if (elapsedVal > elapsedStart) {\n          unelapsedVal = brk.vmin + (elapsedVal - elapsedStart) / (elapsedEnd - elapsedStart) * (brk.vmax - brk.vmin);\n        } else {\n          unelapsedVal = lastBreakEnd + elapsedVal - lastElapsedEnd;\n        }\n        lastBreakEnd = brk.vmax;\n        stillOver = false;\n        break;\n      }\n      lastElapsedEnd = elapsedEnd;\n      lastBreakEnd = brk.vmax;\n    }\n    if (stillOver) {\n      unelapsedVal = lastBreakEnd + elapsedVal - lastElapsedEnd;\n    }\n    return unelapsedVal;\n  };\n  return ScaleBreakContextImpl;\n}();\n;\nfunction createScaleBreakContext() {\n  return new ScaleBreakContextImpl();\n}\n// Both can start with any finite value, and are not necessaryily equal. But they need to\n// be the same in `axisBreakElapse` and `axisBreakUnelapse` respectively.\nvar AXIS_BREAK_ELAPSED_BASE = 0;\nvar AXIS_BREAK_LAST_BREAK_END_BASE = 0;\n/**\n * `gapReal` in brkCtx.breaks will be calculated.\n */\nfunction updateAxisBreakGapReal(brkCtx, scaleExtent) {\n  // Considered the effect:\n  //  - Use dataZoom to move some of the breaks outside the extent.\n  //  - Some scenarios that `series.clip: false`.\n  //\n  // How to calculate `prctBrksGapRealSum`:\n  //  Based on the formula:\n  //      xxx.span = brk.vmax - brk.vmin\n  //      xxx.tpPrct.val / xxx.tpAbs.val means ParsedAxisBreak['gapParsed']['val']\n  //      .S/.E means a break that is semi in scaleExtent[0] or scaleExtent[1]\n  //      valP = (\n  //          + (fullyInExtBrksSum.tpAbs.gapReal - fullyInExtBrksSum.tpAbs.span)\n  //          + (semiInExtBrk.S.tpAbs.gapReal - semiInExtBrk.S.tpAbs.span) * semiInExtBrk.S.tpAbs.inExtFrac\n  //          + (semiInExtBrk.E.tpAbs.gapReal - semiInExtBrk.E.tpAbs.span) * semiInExtBrk.E.tpAbs.inExtFrac\n  //      )\n  //      valQ = (\n  //          - fullyInExtBrksSum.tpPrct.span\n  //          - semiInExtBrk.S.tpPrct.span * semiInExtBrk.S.tpPrct.inExtFrac\n  //          - semiInExtBrk.E.tpPrct.span * semiInExtBrk.E.tpPrct.inExtFrac\n  //      )\n  //      gapPrctSum = sum(xxx.tpPrct.val)\n  //      gapPrctSum = prctBrksGapRealSum / (\n  //          + (scaleExtent[1] - scaleExtent[0]) + valP + valQ\n  //          + fullyInExtBrksSum.tpPrct.gapReal\n  //          + semiInExtBrk.S.tpPrct.gapReal * semiInExtBrk.S.tpPrct.inExtFrac\n  //          + semiInExtBrk.E.tpPrct.gapReal * semiInExtBrk.E.tpPrct.inExtFrac\n  //      )\n  //  Assume:\n  //      xxx.tpPrct.gapReal = xxx.tpPrct.val / gapPrctSum * prctBrksGapRealSum\n  //         (NOTE: This is not accurate when semi-in-extent break exist because its\n  //         proportion is not linear, but this assumption approximately works.)\n  //  Derived as follows:\n  //      prctBrksGapRealSum = gapPrctSum * ( (scaleExtent[1] - scaleExtent[0]) + valP + valQ )\n  //          / (1\n  //              - fullyInExtBrksSum.tpPrct.val\n  //              - semiInExtBrk.S.tpPrct.val * semiInExtBrk.S.tpPrct.inExtFrac\n  //              - semiInExtBrk.E.tpPrct.val * semiInExtBrk.E.tpPrct.inExtFrac\n  //          )\n  var gapPrctSum = 0;\n  var fullyInExtBrksSum = {\n    tpAbs: {\n      span: 0,\n      val: 0\n    },\n    tpPrct: {\n      span: 0,\n      val: 0\n    }\n  };\n  var init = function () {\n    return {\n      has: false,\n      span: NaN,\n      inExtFrac: NaN,\n      val: NaN\n    };\n  };\n  var semiInExtBrk = {\n    S: {\n      tpAbs: init(),\n      tpPrct: init()\n    },\n    E: {\n      tpAbs: init(),\n      tpPrct: init()\n    }\n  };\n  each(brkCtx.breaks, function (brk) {\n    var gapParsed = brk.gapParsed;\n    if (gapParsed.type === 'tpPrct') {\n      gapPrctSum += gapParsed.val;\n    }\n    var clampedBrk = clampBreakByExtent(brk, scaleExtent);\n    if (clampedBrk) {\n      var vminClamped = clampedBrk.vmin !== brk.vmin;\n      var vmaxClamped = clampedBrk.vmax !== brk.vmax;\n      var clampedSpan = clampedBrk.vmax - clampedBrk.vmin;\n      if (vminClamped && vmaxClamped) {\n        // Do nothing, which simply makes the result `gapReal` cover the entire scaleExtent.\n        // This transform is not consistent with the other cases but practically works.\n      } else if (vminClamped || vmaxClamped) {\n        var sOrE = vminClamped ? 'S' : 'E';\n        semiInExtBrk[sOrE][gapParsed.type].has = true;\n        semiInExtBrk[sOrE][gapParsed.type].span = clampedSpan;\n        semiInExtBrk[sOrE][gapParsed.type].inExtFrac = clampedSpan / (brk.vmax - brk.vmin);\n        semiInExtBrk[sOrE][gapParsed.type].val = gapParsed.val;\n      } else {\n        fullyInExtBrksSum[gapParsed.type].span += clampedSpan;\n        fullyInExtBrksSum[gapParsed.type].val += gapParsed.val;\n      }\n    }\n  });\n  var prctBrksGapRealSum = gapPrctSum * (0 + (scaleExtent[1] - scaleExtent[0]) + (fullyInExtBrksSum.tpAbs.val - fullyInExtBrksSum.tpAbs.span) + (semiInExtBrk.S.tpAbs.has ? (semiInExtBrk.S.tpAbs.val - semiInExtBrk.S.tpAbs.span) * semiInExtBrk.S.tpAbs.inExtFrac : 0) + (semiInExtBrk.E.tpAbs.has ? (semiInExtBrk.E.tpAbs.val - semiInExtBrk.E.tpAbs.span) * semiInExtBrk.E.tpAbs.inExtFrac : 0) - fullyInExtBrksSum.tpPrct.span - (semiInExtBrk.S.tpPrct.has ? semiInExtBrk.S.tpPrct.span * semiInExtBrk.S.tpPrct.inExtFrac : 0) - (semiInExtBrk.E.tpPrct.has ? semiInExtBrk.E.tpPrct.span * semiInExtBrk.E.tpPrct.inExtFrac : 0)) / (1 - fullyInExtBrksSum.tpPrct.val - (semiInExtBrk.S.tpPrct.has ? semiInExtBrk.S.tpPrct.val * semiInExtBrk.S.tpPrct.inExtFrac : 0) - (semiInExtBrk.E.tpPrct.has ? semiInExtBrk.E.tpPrct.val * semiInExtBrk.E.tpPrct.inExtFrac : 0));\n  each(brkCtx.breaks, function (brk) {\n    var gapParsed = brk.gapParsed;\n    if (gapParsed.type === 'tpPrct') {\n      brk.gapReal = gapPrctSum !== 0\n      // prctBrksGapRealSum is supposed to be non-negative but add a safe guard\n      ? Math.max(prctBrksGapRealSum, 0) * gapParsed.val / gapPrctSum : 0;\n    }\n    if (gapParsed.type === 'tpAbs') {\n      brk.gapReal = gapParsed.val;\n    }\n    if (brk.gapReal == null) {\n      brk.gapReal = 0;\n    }\n  });\n}\nfunction pruneTicksByBreak(pruneByBreak, ticks, breaks, getValue, interval, scaleExtent) {\n  if (pruneByBreak === 'no') {\n    return;\n  }\n  each(breaks, function (brk) {\n    // break.vmin/vmax that out of extent must not impact the visible of\n    // normal ticks and labels.\n    var clampedBrk = clampBreakByExtent(brk, scaleExtent);\n    if (!clampedBrk) {\n      return;\n    }\n    // Remove some normal ticks to avoid zigzag shapes overlapping with split lines\n    // and to avoid break labels overlapping with normal tick labels (thouth it can\n    // also be avoided by `axisLabel.hideOverlap`).\n    // It's OK to O(n^2) since the number of `ticks` are small.\n    for (var j = ticks.length - 1; j >= 0; j--) {\n      var tick = ticks[j];\n      var val = getValue(tick);\n      // 1. Ensure there is no ticks inside `break.vmin` and `break.vmax`.\n      // 2. Use an empirically gap value here. Theoritically `zigzagAmplitude` is\n      //  supposed to be involved to provide better precision but it will brings\n      //  more complexity. The empirically gap value is conservative because break\n      //  labels and normal tick lables are prone to overlapping.\n      var gap = interval * 3 / 4;\n      if (val > clampedBrk.vmin - gap && val < clampedBrk.vmax + gap && (pruneByBreak !== 'preserve_extent_bound' || val !== scaleExtent[0] && val !== scaleExtent[1])) {\n        ticks.splice(j, 1);\n      }\n    }\n  });\n}\nfunction addBreaksToTicks(\n// The input ticks should be in accending order.\nticks, breaks, scaleExtent,\n// Keep the break ends at the same level to avoid an awkward appearance.\ngetTimeProps) {\n  each(breaks, function (brk) {\n    var clampedBrk = clampBreakByExtent(brk, scaleExtent);\n    if (!clampedBrk) {\n      return;\n    }\n    // - When neight `break.vmin` nor `break.vmax` is in scale extent,\n    //  break label should not be displayed and we do not add them to the result.\n    // - When only one of `break.vmin` and `break.vmax` is inside the extent and the\n    //  other is outsite, we comply with the extent and display only part of the breaks area,\n    //  because the extent might be determined by user settings (such as `axis.min/max`)\n    ticks.push({\n      value: clampedBrk.vmin,\n      \"break\": {\n        type: 'vmin',\n        parsedBreak: clampedBrk\n      },\n      time: getTimeProps ? getTimeProps(clampedBrk) : undefined\n    });\n    // When gap is 0, start tick overlap with end tick, but we still count both of them. Break\n    // area shape can address that overlapping. `axisLabel` need draw both start and end separately,\n    // otherwise it brings complexity to the logic of label overlapping resolving (e.g., when label\n    // rotated), and introduces inconsistency to users in `axisLabel.formatter` between gap is 0 or not.\n    ticks.push({\n      value: clampedBrk.vmax,\n      \"break\": {\n        type: 'vmax',\n        parsedBreak: clampedBrk\n      },\n      time: getTimeProps ? getTimeProps(clampedBrk) : undefined\n    });\n  });\n  if (breaks.length) {\n    ticks.sort(function (a, b) {\n      return a.value - b.value;\n    });\n  }\n}\n/**\n * If break and extent does not intersect, return null/undefined.\n * If the intersection is only a point at scaleExtent[0] or scaleExtent[1], return null/undefined.\n */\nfunction clampBreakByExtent(brk, scaleExtent) {\n  var vmin = Math.max(brk.vmin, scaleExtent[0]);\n  var vmax = Math.min(brk.vmax, scaleExtent[1]);\n  return vmin < vmax || vmin === vmax && vmin > scaleExtent[0] && vmin < scaleExtent[1] ? {\n    vmin: vmin,\n    vmax: vmax,\n    breakOption: brk.breakOption,\n    gapParsed: brk.gapParsed,\n    gapReal: brk.gapReal\n  } : null;\n}\nfunction parseAxisBreakOption(\n// raw user input breaks, retrieved from axis model.\nbreakOptionList, parse, opt) {\n  var parsedBreaks = [];\n  if (!breakOptionList) {\n    return {\n      breaks: parsedBreaks\n    };\n  }\n  function validatePercent(normalizedPercent, msg) {\n    if (normalizedPercent >= 0 && normalizedPercent < 1 - 1e-5) {\n      // Avoid division error.\n      return true;\n    }\n    if (process.env.NODE_ENV !== 'production') {\n      error(msg + \" must be >= 0 and < 1, rather than \" + normalizedPercent + \" .\");\n    }\n    return false;\n  }\n  each(breakOptionList, function (brkOption) {\n    if (!brkOption || brkOption.start == null || brkOption.end == null) {\n      if (process.env.NODE_ENV !== 'production') {\n        error('The input axis breaks start/end should not be empty.');\n      }\n      return;\n    }\n    if (brkOption.isExpanded) {\n      return;\n    }\n    var parsedBrk = {\n      breakOption: clone(brkOption),\n      vmin: parse(brkOption.start),\n      vmax: parse(brkOption.end),\n      gapParsed: {\n        type: 'tpAbs',\n        val: 0\n      },\n      gapReal: null\n    };\n    if (brkOption.gap != null) {\n      var isPrct = false;\n      if (isString(brkOption.gap)) {\n        var trimmedGap = trim(brkOption.gap);\n        if (trimmedGap.match(/%$/)) {\n          var normalizedPercent = parseFloat(trimmedGap) / 100;\n          if (!validatePercent(normalizedPercent, 'Percent gap')) {\n            normalizedPercent = 0;\n          }\n          parsedBrk.gapParsed.type = 'tpPrct';\n          parsedBrk.gapParsed.val = normalizedPercent;\n          isPrct = true;\n        }\n      }\n      if (!isPrct) {\n        var absolute = parse(brkOption.gap);\n        if (!isFinite(absolute) || absolute < 0) {\n          if (process.env.NODE_ENV !== 'production') {\n            error(\"Axis breaks gap must positive finite rather than (\" + brkOption.gap + \").\");\n          }\n          absolute = 0;\n        }\n        parsedBrk.gapParsed.type = 'tpAbs';\n        parsedBrk.gapParsed.val = absolute;\n      }\n    }\n    if (parsedBrk.vmin === parsedBrk.vmax) {\n      parsedBrk.gapParsed.type = 'tpAbs';\n      parsedBrk.gapParsed.val = 0;\n    }\n    if (opt && opt.noNegative) {\n      each(['vmin', 'vmax'], function (se) {\n        if (parsedBrk[se] < 0) {\n          if (process.env.NODE_ENV !== 'production') {\n            error(\"Axis break.\" + se + \" must not be negative.\");\n          }\n          parsedBrk[se] = 0;\n        }\n      });\n    }\n    // Ascending numerical order is the prerequisite of the calculation in Scale#normalize.\n    // User are allowed to input desending vmin/vmax for simplifying the usage.\n    if (parsedBrk.vmin > parsedBrk.vmax) {\n      var tmp = parsedBrk.vmax;\n      parsedBrk.vmax = parsedBrk.vmin;\n      parsedBrk.vmin = tmp;\n    }\n    parsedBreaks.push(parsedBrk);\n  });\n  // Ascending numerical order is the prerequisite of the calculation in Scale#normalize.\n  parsedBreaks.sort(function (item1, item2) {\n    return item1.vmin - item2.vmin;\n  });\n  // Make sure that the intervals in breaks are not overlap.\n  var lastEnd = -Infinity;\n  each(parsedBreaks, function (brk, idx) {\n    if (lastEnd > brk.vmin) {\n      if (process.env.NODE_ENV !== 'production') {\n        error('Axis breaks must not overlap.');\n      }\n      parsedBreaks[idx] = null;\n    }\n    lastEnd = brk.vmax;\n  });\n  return {\n    breaks: parsedBreaks.filter(function (brk) {\n      return !!brk;\n    })\n  };\n}\nfunction identifyAxisBreak(brk, identifier) {\n  return serializeAxisBreakIdentifier(identifier) === serializeAxisBreakIdentifier(brk);\n}\nfunction serializeAxisBreakIdentifier(identifier) {\n  // We use user input start/end to identify break. Considered cases like `start: new Date(xxx)`,\n  // Theoretically `Scale#parse` should be used here, but not used currently to reduce dependencies,\n  // since simply converting to string happens to be correct.\n  return identifier.start + '_\\0_' + identifier.end;\n}\n/**\n * - A break pair represents `[vmin, vmax]`,\n * - Only both vmin and vmax item exist, they are counted as a pair.\n */\nfunction retrieveAxisBreakPairs(itemList, getVisualAxisBreak, returnIdx) {\n  var idxPairList = [];\n  each(itemList, function (el, idx) {\n    var vBreak = getVisualAxisBreak(el);\n    if (vBreak && vBreak.type === 'vmin') {\n      idxPairList.push([idx]);\n    }\n  });\n  each(itemList, function (el, idx) {\n    var vBreak = getVisualAxisBreak(el);\n    if (vBreak && vBreak.type === 'vmax') {\n      var idxPair = find(idxPairList,\n      // parsedBreak may be changed, can only use breakOption to match them.\n      function (pr) {\n        return identifyAxisBreak(getVisualAxisBreak(itemList[pr[0]]).parsedBreak.breakOption, vBreak.parsedBreak.breakOption);\n      });\n      idxPair && idxPair.push(idx);\n    }\n  });\n  var result = [];\n  each(idxPairList, function (idxPair) {\n    if (idxPair.length === 2) {\n      result.push(returnIdx ? idxPair : [itemList[idxPair[0]], itemList[idxPair[1]]]);\n    }\n  });\n  return result;\n}\nfunction getTicksLogTransformBreak(tick, logBase, logOriginalBreaks, fixRoundingError) {\n  var vBreak;\n  var brkRoundingCriterion;\n  if (tick[\"break\"]) {\n    var brk = tick[\"break\"].parsedBreak;\n    var originalBreak = find(logOriginalBreaks, function (brk) {\n      return identifyAxisBreak(brk.breakOption, tick[\"break\"].parsedBreak.breakOption);\n    });\n    var vmin = fixRoundingError(Math.pow(logBase, brk.vmin), originalBreak.vmin);\n    var vmax = fixRoundingError(Math.pow(logBase, brk.vmax), originalBreak.vmax);\n    var gapParsed = {\n      type: brk.gapParsed.type,\n      val: brk.gapParsed.type === 'tpAbs' ? fixRound(Math.pow(logBase, brk.vmin + brk.gapParsed.val)) - vmin : brk.gapParsed.val\n    };\n    vBreak = {\n      type: tick[\"break\"].type,\n      parsedBreak: {\n        breakOption: brk.breakOption,\n        vmin: vmin,\n        vmax: vmax,\n        gapParsed: gapParsed,\n        gapReal: brk.gapReal\n      }\n    };\n    brkRoundingCriterion = originalBreak[tick[\"break\"].type];\n  }\n  return {\n    brkRoundingCriterion: brkRoundingCriterion,\n    vBreak: vBreak\n  };\n}\nfunction logarithmicParseBreaksFromOption(breakOptionList, logBase, parse) {\n  var opt = {\n    noNegative: true\n  };\n  var parsedOriginal = parseAxisBreakOption(breakOptionList, parse, opt);\n  var parsedLogged = parseAxisBreakOption(breakOptionList, parse, opt);\n  var loggedBase = Math.log(logBase);\n  parsedLogged.breaks = map(parsedLogged.breaks, function (brk) {\n    var vmin = Math.log(brk.vmin) / loggedBase;\n    var vmax = Math.log(brk.vmax) / loggedBase;\n    var gapParsed = {\n      type: brk.gapParsed.type,\n      val: brk.gapParsed.type === 'tpAbs' ? Math.log(brk.vmin + brk.gapParsed.val) / loggedBase - vmin : brk.gapParsed.val\n    };\n    return {\n      vmin: vmin,\n      vmax: vmax,\n      gapParsed: gapParsed,\n      gapReal: brk.gapReal,\n      breakOption: brk.breakOption\n    };\n  });\n  return {\n    parsedOriginal: parsedOriginal,\n    parsedLogged: parsedLogged\n  };\n}\nvar BREAK_MIN_MAX_TO_PARAM = {\n  vmin: 'start',\n  vmax: 'end'\n};\nfunction makeAxisLabelFormatterParamBreak(extraParam, vBreak) {\n  if (vBreak) {\n    extraParam = extraParam || {};\n    extraParam[\"break\"] = {\n      type: BREAK_MIN_MAX_TO_PARAM[vBreak.type],\n      start: vBreak.parsedBreak.vmin,\n      end: vBreak.parsedBreak.vmax\n    };\n  }\n  return extraParam;\n}\nexport function installScaleBreakHelper() {\n  registerScaleBreakHelperImpl({\n    createScaleBreakContext: createScaleBreakContext,\n    pruneTicksByBreak: pruneTicksByBreak,\n    addBreaksToTicks: addBreaksToTicks,\n    parseAxisBreakOption: parseAxisBreakOption,\n    identifyAxisBreak: identifyAxisBreak,\n    serializeAxisBreakIdentifier: serializeAxisBreakIdentifier,\n    retrieveAxisBreakPairs: retrieveAxisBreakPairs,\n    getTicksLogTransformBreak: getTicksLogTransformBreak,\n    logarithmicParseBreaksFromOption: logarithmicParseBreaksFromOption,\n    makeAxisLabelFormatterParamBreak: makeAxisLabelFormatterParamBreak\n  });\n}", "\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { makeInner } from '../../util/model.js';\nimport { assert, each, extend, find, map } from 'zrender/lib/core/util.js';\nimport { getScaleBreakHelper } from '../../scale/break.js';\nimport { subPixelOptimizeLine } from 'zrender/lib/graphic/helper/subPixelOptimize.js';\nimport { applyTransform } from 'zrender/lib/core/vector.js';\nimport * as matrixUtil from 'zrender/lib/core/matrix.js';\nimport { AXIS_BREAK_COLLAPSE_ACTION_TYPE, AXIS_BREAK_EXPAND_ACTION_TYPE, AXIS_BREAK_TOGGLE_ACTION_TYPE } from './axisAction.js';\nimport { labelIntersect, labelLayoutApplyTranslation } from '../../label/labelLayoutHelper.js';\nimport { registerAxisBreakHelperImpl } from './axisBreakHelper.js';\nimport { warn } from '../../util/log.js';\nimport { Group, Line, Point, Polygon, Polyline, WH, XY } from '../../util/graphic.js';\n/**\n * @caution\n *  Must not export anything except `installAxisBreakHelper`\n */\n/**\n * The zigzag shapes for axis breaks are generated according to some random\n * factors. It should persist as much as possible to avoid constantly\n * changing by every user operation.\n */\nvar viewCache = makeInner();\nfunction ensureVisualInCache(visualList, targetBreak) {\n  var visual = find(visualList, function (item) {\n    return getScaleBreakHelper().identifyAxisBreak(item.parsedBreak.breakOption, targetBreak.breakOption);\n  });\n  if (!visual) {\n    visualList.push(visual = {\n      zigzagRandomList: [],\n      parsedBreak: targetBreak,\n      shouldRemove: false\n    });\n  }\n  return visual;\n}\nfunction resetCacheVisualRemoveFlag(visualList) {\n  each(visualList, function (item) {\n    return item.shouldRemove = true;\n  });\n}\nfunction removeUnusedCacheVisual(visualList) {\n  for (var i = visualList.length - 1; i >= 0; i--) {\n    if (visualList[i].shouldRemove) {\n      visualList.splice(i, 1);\n    }\n  }\n}\nfunction rectCoordBuildBreakAxis(axisGroup, axisView, axisModel, coordSysRect, api) {\n  var axis = axisModel.axis;\n  if (axis.scale.isBlank() || !getScaleBreakHelper()) {\n    return;\n  }\n  var breakPairs = getScaleBreakHelper().retrieveAxisBreakPairs(axis.scale.getTicks({\n    breakTicks: 'only_break'\n  }), function (tick) {\n    return tick[\"break\"];\n  }, false);\n  if (!breakPairs.length) {\n    return;\n  }\n  var breakAreaModel = axisModel.getModel('breakArea');\n  var zigzagAmplitude = breakAreaModel.get('zigzagAmplitude');\n  var zigzagMinSpan = breakAreaModel.get('zigzagMinSpan');\n  var zigzagMaxSpan = breakAreaModel.get('zigzagMaxSpan');\n  // Use arbitrary value to avoid dead loop if user gives inappropriate settings.\n  zigzagMinSpan = Math.max(2, zigzagMinSpan || 0);\n  zigzagMaxSpan = Math.max(zigzagMinSpan, zigzagMaxSpan || 0);\n  var expandOnClick = breakAreaModel.get('expandOnClick');\n  var zigzagZ = breakAreaModel.get('zigzagZ');\n  var itemStyleModel = breakAreaModel.getModel('itemStyle');\n  var itemStyle = itemStyleModel.getItemStyle();\n  var borderColor = itemStyle.stroke;\n  var borderWidth = itemStyle.lineWidth;\n  var borderType = itemStyle.lineDash;\n  var color = itemStyle.fill;\n  var group = new Group({\n    ignoreModelZ: true\n  });\n  var isAxisHorizontal = axis.isHorizontal();\n  var cachedVisualList = viewCache(axisView).visualList || (viewCache(axisView).visualList = []);\n  resetCacheVisualRemoveFlag(cachedVisualList);\n  var _loop_1 = function (i) {\n    var parsedBreak = breakPairs[i][0][\"break\"].parsedBreak;\n    // Even if brk.gap is 0, we should also draw the breakArea because\n    // border is sometimes required to be visible (as a line)\n    var coords = [];\n    coords[0] = axis.toGlobalCoord(axis.dataToCoord(parsedBreak.vmin, true));\n    coords[1] = axis.toGlobalCoord(axis.dataToCoord(parsedBreak.vmax, true));\n    if (coords[1] < coords[0]) {\n      coords.reverse();\n    }\n    var cachedVisual = ensureVisualInCache(cachedVisualList, parsedBreak);\n    cachedVisual.shouldRemove = false;\n    var breakGroup = new Group();\n    addZigzagShapes(cachedVisual.zigzagRandomList, breakGroup, coords[0], coords[1], isAxisHorizontal, parsedBreak);\n    if (expandOnClick) {\n      breakGroup.on('click', function () {\n        var payload = {\n          type: AXIS_BREAK_EXPAND_ACTION_TYPE,\n          breaks: [{\n            start: parsedBreak.breakOption.start,\n            end: parsedBreak.breakOption.end\n          }]\n        };\n        payload[axis.dim + \"AxisIndex\"] = axisModel.componentIndex;\n        api.dispatchAction(payload);\n      });\n    }\n    breakGroup.silent = !expandOnClick;\n    group.add(breakGroup);\n  };\n  for (var i = 0; i < breakPairs.length; i++) {\n    _loop_1(i);\n  }\n  axisGroup.add(group);\n  removeUnusedCacheVisual(cachedVisualList);\n  function addZigzagShapes(zigzagRandomList, breakGroup, startCoord, endCoord, isAxisHorizontal, trimmedBreak) {\n    var polylineStyle = {\n      stroke: borderColor,\n      lineWidth: borderWidth,\n      lineDash: borderType,\n      fill: 'none'\n    };\n    var dimBrk = isAxisHorizontal ? 0 : 1;\n    var dimZigzag = 1 - dimBrk;\n    var zigzagCoordMax = coordSysRect[XY[dimZigzag]] + coordSysRect[WH[dimZigzag]];\n    // Apply `subPixelOptimizeLine` for alignning with break ticks.\n    function subPixelOpt(brkCoord) {\n      var pBrk = [];\n      var dummyP = [];\n      pBrk[dimBrk] = dummyP[dimBrk] = brkCoord;\n      pBrk[dimZigzag] = coordSysRect[XY[dimZigzag]];\n      dummyP[dimZigzag] = zigzagCoordMax;\n      var dummyShape = {\n        x1: pBrk[0],\n        y1: pBrk[1],\n        x2: dummyP[0],\n        y2: dummyP[1]\n      };\n      subPixelOptimizeLine(dummyShape, dummyShape, {\n        lineWidth: 1\n      });\n      pBrk[0] = dummyShape.x1;\n      pBrk[1] = dummyShape.y1;\n      return pBrk[dimBrk];\n    }\n    startCoord = subPixelOpt(startCoord);\n    endCoord = subPixelOpt(endCoord);\n    var pointsA = [];\n    var pointsB = [];\n    var isSwap = true;\n    var current = coordSysRect[XY[dimZigzag]];\n    for (var idx = 0;; idx++) {\n      // Use `isFirstPoint` `isLastPoint` to ensure the intersections between zigzag\n      // and axis are precise, thus it can join its axis tick correctly.\n      var isFirstPoint = current === coordSysRect[XY[dimZigzag]];\n      var isLastPoint = current >= zigzagCoordMax;\n      if (isLastPoint) {\n        current = zigzagCoordMax;\n      }\n      var pA = [];\n      var pB = [];\n      pA[dimBrk] = startCoord;\n      pB[dimBrk] = endCoord;\n      if (!isFirstPoint && !isLastPoint) {\n        pA[dimBrk] += isSwap ? -zigzagAmplitude : zigzagAmplitude;\n        pB[dimBrk] -= !isSwap ? -zigzagAmplitude : zigzagAmplitude;\n      }\n      pA[dimZigzag] = current;\n      pB[dimZigzag] = current;\n      pointsA.push(pA);\n      pointsB.push(pB);\n      var randomVal = void 0;\n      if (idx < zigzagRandomList.length) {\n        randomVal = zigzagRandomList[idx];\n      } else {\n        randomVal = Math.random();\n        zigzagRandomList.push(randomVal);\n      }\n      current += randomVal * (zigzagMaxSpan - zigzagMinSpan) + zigzagMinSpan;\n      isSwap = !isSwap;\n      if (isLastPoint) {\n        break;\n      }\n    }\n    var anidSuffix = getScaleBreakHelper().serializeAxisBreakIdentifier(trimmedBreak.breakOption);\n    // Create two polylines and add them to the breakGroup\n    breakGroup.add(new Polyline({\n      anid: \"break_a_\" + anidSuffix,\n      shape: {\n        points: pointsA\n      },\n      style: polylineStyle,\n      z: zigzagZ\n    }));\n    /* Add the second polyline and a polygon only if the gap is not zero\n     * Otherwise if the polyline is with dashed line or being opaque,\n     * it may not be constant with breaks with non-zero gaps. */\n    if (trimmedBreak.gapReal !== 0) {\n      breakGroup.add(new Polyline({\n        anid: \"break_b_\" + anidSuffix,\n        shape: {\n          // Not reverse to keep the dash stable when dragging resizing.\n          points: pointsB\n        },\n        style: polylineStyle,\n        z: zigzagZ\n      }));\n      // Creating the polygon that fills the area between the polylines\n      // From end to start for polygon.\n      var pointsB2 = pointsB.slice();\n      pointsB2.reverse();\n      var polygonPoints = pointsA.concat(pointsB2);\n      breakGroup.add(new Polygon({\n        anid: \"break_c_\" + anidSuffix,\n        shape: {\n          points: polygonPoints\n        },\n        style: {\n          fill: color,\n          opacity: itemStyle.opacity\n        },\n        z: zigzagZ\n      }));\n    }\n  }\n}\nfunction buildAxisBreakLine(axisModel, group, transformGroup, pathBaseProp) {\n  var axis = axisModel.axis;\n  var transform = transformGroup.transform;\n  assert(pathBaseProp.style);\n  var extent = axis.getExtent();\n  if (axis.inverse) {\n    extent = extent.slice();\n    extent.reverse();\n  }\n  var breakPairs = getScaleBreakHelper().retrieveAxisBreakPairs(axis.scale.getTicks({\n    breakTicks: 'only_break'\n  }), function (tick) {\n    return tick[\"break\"];\n  }, false);\n  var brkLayoutList = map(breakPairs, function (breakPair) {\n    var parsedBreak = breakPair[0][\"break\"].parsedBreak;\n    var coordPair = [axis.dataToCoord(parsedBreak.vmin, true), axis.dataToCoord(parsedBreak.vmax, true)];\n    coordPair[0] > coordPair[1] && coordPair.reverse();\n    return {\n      coordPair: coordPair,\n      brkId: getScaleBreakHelper().serializeAxisBreakIdentifier(parsedBreak.breakOption)\n    };\n  });\n  brkLayoutList.sort(function (layout1, layout2) {\n    return layout1.coordPair[0] - layout2.coordPair[0];\n  });\n  var ySegMin = extent[0];\n  var lastLayout = null;\n  for (var idx = 0; idx < brkLayoutList.length; idx++) {\n    var layout = brkLayoutList[idx];\n    var brkTirmmedMin = Math.max(layout.coordPair[0], extent[0]);\n    var brkTirmmedMax = Math.min(layout.coordPair[1], extent[1]);\n    if (ySegMin <= brkTirmmedMin) {\n      addSeg(ySegMin, brkTirmmedMin, lastLayout, layout);\n    }\n    ySegMin = brkTirmmedMax;\n    lastLayout = layout;\n  }\n  if (ySegMin <= extent[1]) {\n    addSeg(ySegMin, extent[1], lastLayout, null);\n  }\n  function addSeg(min, max, layout1, layout2) {\n    function trans(p1, p2) {\n      if (transform) {\n        applyTransform(p1, p1, transform);\n        applyTransform(p2, p2, transform);\n      }\n    }\n    function subPixelOptimizePP(p1, p2) {\n      var shape = {\n        x1: p1[0],\n        y1: p1[1],\n        x2: p2[0],\n        y2: p2[1]\n      };\n      subPixelOptimizeLine(shape, shape, pathBaseProp.style);\n      p1[0] = shape.x1;\n      p1[1] = shape.y1;\n      p2[0] = shape.x2;\n      p2[1] = shape.y2;\n    }\n    var lineP1 = [min, 0];\n    var lineP2 = [max, 0];\n    // dummy tick is used to align the line segment ends with axis ticks\n    // after `subPixelOptimizeLine` being applied.\n    var dummyTickEnd1 = [min, 5];\n    var dummyTickEnd2 = [max, 5];\n    trans(lineP1, dummyTickEnd1);\n    subPixelOptimizePP(lineP1, dummyTickEnd1);\n    trans(lineP2, dummyTickEnd2);\n    subPixelOptimizePP(lineP2, dummyTickEnd2);\n    // Apply it keeping the same as the normal axis line.\n    subPixelOptimizePP(lineP1, lineP2);\n    var seg = new Line(extend({\n      shape: {\n        x1: lineP1[0],\n        y1: lineP1[1],\n        x2: lineP2[0],\n        y2: lineP2[1]\n      }\n    }, pathBaseProp));\n    group.add(seg);\n    // Animation should be precise to be consistent with tick and split line animation.\n    seg.anid = \"breakLine_\" + (layout1 ? layout1.brkId : '\\0') + \"_\\0_\" + (layout2 ? layout2.brkId : '\\0');\n  }\n}\n/**\n * Resolve the overlap of a pair of labels.\n *\n * [CAUTION] Only label.x/y are allowed to change.\n */\nfunction adjustBreakLabelPair(axisInverse, axisRotation, layoutPair) {\n  if (find(layoutPair, function (item) {\n    return !item;\n  })) {\n    return;\n  }\n  var mtv = new Point();\n  if (!labelIntersect(layoutPair[0], layoutPair[1], mtv, {\n    // Assert `labelPair` is `[break_min, break_max]`.\n    // `axis.inverse: true` means a smaller scale value corresponds to a bigger value in axis.extent.\n    // The axisRotation indicates mtv direction of OBB intersecting.\n    direction: -(axisInverse ? axisRotation + Math.PI : axisRotation),\n    touchThreshold: 0,\n    // If need to resovle intersection align axis by moving labels according to MTV,\n    // the direction must not be opposite, otherwise cause misleading.\n    bidirectional: false\n  })) {\n    return;\n  }\n  // Rotate axis back to (1, 0) direction, to be a standard axis.\n  var axisStTrans = matrixUtil.create();\n  matrixUtil.rotate(axisStTrans, axisStTrans, -axisRotation);\n  var labelPairStTrans = map(layoutPair, function (layout) {\n    return layout.transform ? matrixUtil.mul(matrixUtil.create(), axisStTrans, layout.transform) : axisStTrans;\n  });\n  function isParallelToAxis(whIdx) {\n    // Assert label[0] and label[1] has the same rotation, so only use [0].\n    var localRect = layoutPair[0].localRect;\n    var labelVec0 = new Point(localRect[WH[whIdx]] * labelPairStTrans[0][0], localRect[WH[whIdx]] * labelPairStTrans[0][1]);\n    return Math.abs(labelVec0.y) < 1e-5;\n  }\n  // If overlapping, move pair[0] pair[1] apart a little. We need to calculate a ratio k to\n  // distribute mtv to pair[0] and pair[1]. This is to place the text gap as close as possible\n  // to the center of the break ticks, otherwise it might looks weird or misleading.\n  // - When labels' width/height are not parallel to axis (usually by rotation),\n  //  we can simply treat the k as `0.5`.\n  var k = 0.5;\n  // - When labels' width/height are parallel to axis, the width/height need to be considered,\n  //  since they may differ significantly. In this case we keep textAlign as 'center' rather\n  //  than 'left'/'right', due to considerations of space utilization for wide break.gap.\n  //  A sample case: break on xAxis(no inverse) is [200, 300000].\n  //  We calculate k based on the formula below:\n  //      Rotated axis and labels to the direction of (1, 0).\n  //      uval = ( (pair[0].insidePt - mtv*k) + (pair[1].insidePt + mtv*(1-k)) ) / 2 - brkCenter\n  //      0 <= k <= 1\n  //      |uval| should be as small as possible.\n  //  Derived as follows:\n  //      qval = (pair[0].insidePt + pair[1].insidePt + mtv) / 2 - brkCenter\n  //      k = (qval - uval) / mtv\n  //      min(qval, qval-mtv) <= uval <= max(qval, qval-mtv)\n  if (isParallelToAxis(0) || isParallelToAxis(1)) {\n    var rectSt = map(layoutPair, function (layout, idx) {\n      var rect = layout.localRect.clone();\n      rect.applyTransform(labelPairStTrans[idx]);\n      return rect;\n    });\n    var brkCenterSt = new Point();\n    brkCenterSt.copy(layoutPair[0].label).add(layoutPair[1].label).scale(0.5);\n    brkCenterSt.transform(axisStTrans);\n    var mtvSt = mtv.clone().transform(axisStTrans);\n    var insidePtSum = rectSt[0].x + rectSt[1].x + (mtvSt.x >= 0 ? rectSt[0].width : rectSt[1].width);\n    var qval = (insidePtSum + mtvSt.x) / 2 - brkCenterSt.x;\n    var uvalMin = Math.min(qval, qval - mtvSt.x);\n    var uvalMax = Math.max(qval, qval - mtvSt.x);\n    var uval = uvalMax < 0 ? uvalMax : uvalMin > 0 ? uvalMin : 0;\n    k = (qval - uval) / mtvSt.x;\n  }\n  var delta0 = new Point();\n  var delta1 = new Point();\n  Point.scale(delta0, mtv, -k);\n  Point.scale(delta1, mtv, 1 - k);\n  labelLayoutApplyTranslation(layoutPair[0], delta0);\n  labelLayoutApplyTranslation(layoutPair[1], delta1);\n}\nfunction updateModelAxisBreak(model, payload) {\n  var result = {\n    breaks: []\n  };\n  each(payload.breaks, function (inputBrk) {\n    if (!inputBrk) {\n      return;\n    }\n    var breakOption = find(model.get('breaks', true), function (brkOption) {\n      return getScaleBreakHelper().identifyAxisBreak(brkOption, inputBrk);\n    });\n    if (!breakOption) {\n      if (process.env.NODE_ENV !== 'production') {\n        warn(\"Can not find axis break by start: \" + inputBrk.start + \", end: \" + inputBrk.end);\n      }\n      return;\n    }\n    var actionType = payload.type;\n    var old = {\n      isExpanded: !!breakOption.isExpanded\n    };\n    breakOption.isExpanded = actionType === AXIS_BREAK_EXPAND_ACTION_TYPE ? true : actionType === AXIS_BREAK_COLLAPSE_ACTION_TYPE ? false : actionType === AXIS_BREAK_TOGGLE_ACTION_TYPE ? !breakOption.isExpanded : breakOption.isExpanded;\n    result.breaks.push({\n      start: breakOption.start,\n      end: breakOption.end,\n      isExpanded: !!breakOption.isExpanded,\n      old: old\n    });\n  });\n  return result;\n}\nexport function installAxisBreakHelper() {\n  registerAxisBreakHelperImpl({\n    adjustBreakLabelPair: adjustBreakLabelPair,\n    buildAxisBreakLine: buildAxisBreakLine,\n    rectCoordBuildBreakAxis: rectCoordBuildBreakAxis,\n    updateModelAxisBreak: updateModelAxisBreak\n  });\n}", "\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { installScaleBreakHelper } from '../../scale/breakImpl.js';\nimport { registerAction } from './axisAction.js';\nimport { installAxisBreakHelper } from './axisBreakHelperImpl.js';\nexport function installAxisBreak(registers) {\n  registerAction(registers);\n  installScaleBreakHelper();\n  installAxisBreakHelper();\n}", "\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport BoundingRect from 'zrender/lib/core/BoundingRect.js';\nimport { each } from 'zrender/lib/core/util.js';\nimport { registerLegacyGridContainLabelImpl } from './Grid.js';\nimport OrdinalScale from '../../scale/Ordinal.js';\nimport { makeLabelFormatter } from '../axisHelper.js';\n/**\n * [CAUTION] Never export methods other than `installLegacyGridContainLabel`.\n */\nexport function installLegacyGridContainLabel() {\n  registerLegacyGridContainLabelImpl(legacyLayOutGridByContained);\n}\n/**\n * The input gridRect and axes will be modified.\n */\nfunction legacyLayOutGridByContained(axesList, gridRect) {\n  each(axesList, function (axis) {\n    if (!axis.model.get(['axisLabel', 'inside'])) {\n      var labelUnionRect = estimateLabelUnionRect(axis);\n      if (labelUnionRect) {\n        var dim = axis.isHorizontal() ? 'height' : 'width';\n        var margin = axis.model.get(['axisLabel', 'margin']);\n        gridRect[dim] -= labelUnionRect[dim] + margin;\n        if (axis.position === 'top') {\n          gridRect.y += labelUnionRect.height + margin;\n        } else if (axis.position === 'left') {\n          gridRect.x += labelUnionRect.width + margin;\n        }\n      }\n    }\n  });\n}\n/**\n * @return Be null/undefined if no labels.\n */\nfunction estimateLabelUnionRect(axis) {\n  var axisModel = axis.model;\n  var scale = axis.scale;\n  if (!axisModel.get(['axisLabel', 'show']) || scale.isBlank()) {\n    return;\n  }\n  var realNumberScaleTicks;\n  var tickCount;\n  var categoryScaleExtent = scale.getExtent();\n  // Optimize for large category data, avoid call `getTicks()`.\n  if (scale instanceof OrdinalScale) {\n    tickCount = scale.count();\n  } else {\n    realNumberScaleTicks = scale.getTicks();\n    tickCount = realNumberScaleTicks.length;\n  }\n  var axisLabelModel = axis.getLabelModel();\n  var labelFormatter = makeLabelFormatter(axis);\n  var rect;\n  var step = 1;\n  // Simple optimization for large amount of category labels\n  if (tickCount > 40) {\n    step = Math.ceil(tickCount / 40);\n  }\n  for (var i = 0; i < tickCount; i += step) {\n    var tick = realNumberScaleTicks ? realNumberScaleTicks[i] : {\n      value: categoryScaleExtent[0] + i\n    };\n    var label = labelFormatter(tick, i);\n    var unrotatedSingleRect = axisLabelModel.getTextRect(label);\n    var singleRect = rotateTextRect(unrotatedSingleRect, axisLabelModel.get('rotate') || 0);\n    rect ? rect.union(singleRect) : rect = singleRect;\n  }\n  return rect;\n  function rotateTextRect(textRect, rotate) {\n    var rotateRadians = rotate * Math.PI / 180;\n    var beforeWidth = textRect.width;\n    var beforeHeight = textRect.height;\n    var afterWidth = beforeWidth * Math.abs(Math.cos(rotateRadians)) + Math.abs(beforeHeight * Math.sin(rotateRadians));\n    var afterHeight = beforeWidth * Math.abs(Math.sin(rotateRadians)) + Math.abs(beforeHeight * Math.cos(rotateRadians));\n    var rotatedRect = new BoundingRect(textRect.x, textRect.y, afterWidth, afterHeight);\n    return rotatedRect;\n  }\n}"],
  "mappings": "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",
  "names": ["x0", "y0", "x1", "y1", "startAngle", "endAngle", "cx", "cy", "rx", "ry", "len", "clone", "fromList", "i", "from", "fromIsMany", "animateIndex", "animateCount", "count", "newItem", "el", "oldData", "ScaleBreakContextImpl", "brk", "i", "isAxisHorizontal", "rotate"]
}
